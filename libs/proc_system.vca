*--------------------------------------------------------------------------------------------------------------------------------------------------------
* (ES) AUTOGENERADO - ¡¡ATENCIÓN!! - ¡¡NO PENSADO PARA EJECUTAR!! USAR SOLAMENTE PARA INTEGRAR CAMBIOS Y ALMACENAR CON HERRAMIENTAS SCM!!
* (EN) AUTOGENERATED - ATTENTION!! - NOT INTENDED FOR EXECUTION!! USE ONLY FOR MERGING CHANGES AND STORING WITH SCM TOOLS!!
*--------------------------------------------------------------------------------------------------------------------------------------------------------
*< FOXBIN2PRG: Version="1.19" SourceFile="proc_system.vcx" /> (Solo para binarios VFP 9 / Only for VFP 9 binaries)
*
*
DEFINE CLASS proclogger AS custom 
 	*< CLASSDATA: Baseclass="custom" Timestamp="" Scale="Pixels" Uniqueid="" />

	#INCLUDE "..\include\constdefines.h"
	*<DefinedPropArrayMethod>
		*m: release		&& Releases a FormSet or Form from memory.
		*m: save
		*m: selectedrestore
		*m: selectedstore
		*m: setnewval
		*m: setoldval
		*p: calias
		*p: ckeyexp
		*p: ctable		&& Table name
		*p: nselect
		*p: onewval
		*p: ooldval
	*</DefinedPropArrayMethod>

	calias = 
	ckeyexp = 
	ctable = 		&& Table name
	Name = "proclogger"
	nselect = 0
	onewval = .NULL.
	ooldval = .NULL.
	
	PROCEDURE Init
		LPARAMETERS lp_cTable, lp_cKeyExp, lp_cAlias
		
		IF VARTYPE(lp_cTable) = "C"
			this.cTable = lp_cTable
		ENDIF
		
		IF VARTYPE(lp_cKeyExp) = "C"
			this.cKeyExp = lp_cKeyExp
		ENDIF
		
		IF VARTYPE(lp_cAlias) = "C"
			this.cAlias = lp_cAlias
		ENDIF
		
		DODEFAULT()
	ENDPROC

	PROCEDURE release		&& Releases a FormSet or Form from memory.
		RELEASE this
	ENDPROC

	PROCEDURE save
		LPARAMETERS lp_cUser, lp_cAction
		LOCAL l_lAbort, l_cAction, l_cTable, l_nFields, i, l_cChanges, l_cKey, l_nId, l_oCaLogger, l_cUser
		
		l_cChanges = ""
		lp_cAction = ""
		
		DO CASE
			CASE ISNULL(this.oNewVal) AND ISNULL(this.oOldVal)
				l_lAbort = .T.
			CASE EMPTY(this.cKeyExp)
				l_lAbort = .T.
			CASE ISNULL(this.oNewVal)
				l_cAction = 'D'
			CASE ISNULL(this.oOldVal)
				l_cAction = 'I'
			OTHERWISE
				l_cAction = 'U'
		ENDCASE
		
		IF l_lAbort
			RETURN .T.
		ENDIF
		
		IF EMPTY(lp_cUser)
			l_cUser = g_Userid
		ELSE
			l_cUser = lp_cUser
		ENDIF
		
		this.SelectedStore()
		
		SELECT(this.cAlias)
		IF EMPTY(this.ctable)
			l_cTable = JUSTSTEM(DBF())
		ELSE
			l_cTable = UPPER(this.ctable)
		ENDIF
		
		IF l_cAction = 'U'
			l_nFields = FCOUNT()
			FOR i = 1 TO l_nFields
				IF EVALUATE("this.oOldVal."+FIELD(i)) <> EVALUATE("this.oNewVal."+FIELD(i))
					TRY && Prevent possible error when converting values to string
						l_cChanges = l_cChanges + FIELD(i) + CRLF + ;
								TRANSFORM(EVALUATE("this.oOldVal."+FIELD(i))) + CRLF + ;
								TRANSFORM(EVALUATE("this.oNewVal."+FIELD(i))) + CRLF + CRLF
					CATCH
						l_cChanges = "UNKNOWN"
					ENDTRY
				ENDIF
			ENDFOR
		ENDIF
		
		IF l_cAction <> 'U' OR NOT EMPTY(l_cChanges)
			lp_cAction = l_cAction
			TRY
				DO CASE
					CASE "(" $ this.cKeyExp
						* Is a expresson, not a field
						l_cKey = TRANSFORM(EVALUATE(this.cKeyExp))
					CASE l_cAction = 'I'
						l_cKey = TRANSFORM(EVALUATE("this.oNewVal."+this.cKeyExp))
					OTHERWISE
						l_cKey = TRANSFORM(EVALUATE("this.oOldVal."+this.cKeyExp))
				ENDCASE
			CATCH
				l_cKey = "UNKNOWN"
			ENDTRY
			l_oCaLogger = CREATEOBJECT("calogger")
			l_oCaLogger.Alias = SYS(2015)
			l_oCaLogger.ldontfill = .T.
			l_oCaLogger.CursorFill()
			l_nId = nextid("LOGGER")
			INSERT INTO (l_oCaLogger.Alias) ( ;
				lg_lgid, ;
				lg_table, ;
				lg_keyexp, ;
				lg_keyid, ;
				lg_when, ;
				lg_sysdate, ;
				lg_action, ;
				lg_user,;
				lg_changes) ;
				VALUES ( ;
				l_nId, ;
				l_cTable, ;
				this.cKeyExp, ;
				l_cKey, ;
				DATETIME(), ;
				sysdate(), ;
				l_cAction, ;
				l_cUser, ;
				l_cChanges)
			l_oCaLogger.DoTableUpdate()
			l_oCaLogger.DClose()
		ENDIF
		
		this.SelectedRestore()
		
		RETURN .T.
	ENDPROC

	PROCEDURE selectedrestore
		SELECT (this.nSelect)
	ENDPROC

	PROCEDURE selectedstore
		this.nSelect = SELECT()
	ENDPROC

	PROCEDURE setnewval
		LPARAMETERS lp_oNewVal, lp_lDeleted
		
		
		DO CASE
			CASE lp_lDeleted
				this.oNewVal = .NULL.
			CASE PCOUNT() = 1
				this.oNewVal = lp_oNewVal
			CASE NOT EMPTY(this.cAlias)
				this.SelectedStore()
				SELECT (this.cAlias)
				SCATTER MEMO NAME this.oNewVal
				this.SelectedRestore()
		ENDCASE
	ENDPROC

	PROCEDURE setoldval
		LPARAMETERS lp_cAlias, lp_lNew
		IF NOT EMPTY(lp_cAlias)
			this.cAlias = lp_cAlias
		ENDIF
		
		IF EMPTY(this.cAlias)
			RETURN .F.
		ENDIF
		
		IF lp_lNew
			this.oOldVal = .NULL.
		ELSE
			this.SelectedStore()
			SELECT (this.cAlias)
			SCATTER MEMO NAME this.oOldVal
			this.SelectedRestore()
		ENDIF
	ENDPROC

ENDDEFINE
