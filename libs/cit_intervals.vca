*--------------------------------------------------------------------------------------------------------------------------------------------------------
* (ES) AUTOGENERADO - ¡¡ATENCIÓN!! - ¡¡NO PENSADO PARA EJECUTAR!! USAR SOLAMENTE PARA INTEGRAR CAMBIOS Y ALMACENAR CON HERRAMIENTAS SCM!!
* (EN) AUTOGENERATED - ATTENTION!! - NOT INTENDED FOR EXECUTION!! USE ONLY FOR MERGING CHANGES AND STORING WITH SCM TOOLS!!
*--------------------------------------------------------------------------------------------------------------------------------------------------------
*< FOXBIN2PRG: Version="1.19" SourceFile="cit_intervals.vcx" /> (Solo para binarios VFP 9 / Only for VFP 9 binaries)
*
*
DEFINE CLASS cintervals AS custom 
 	*< CLASSDATA: Baseclass="custom" Timestamp="" Scale="Pixels" Uniqueid="" />

	*<DefinedPropArrayMethod>
		*m: assignadditionalvaluestonewinterval
		*m: assignaddtitionalvaluestotable
		*m: chooseintervals
		*m: choosemaininterval
		*m: createcomparedcursor
		*m: createnewcursor
		*m: getcomparedintervals
		*m: getcurrentintervals
		*m: getnewintervals
		*m: insertintocomparedintervals
		*m: overlapped
		*m: start
		*m: updateselectedintervals
		*p: cchooseintervalcaption
		*p: ccomparedintervals
		*p: ccurrentintervals
		*p: cfromdatefield
		*p: cmaindialogcaption
		*p: cnewintervals
		*p: ctablealias
		*p: ctodatefield
		*p: dfrom
		*p: dto
		*a: aweekday[7,0]
	*</DefinedPropArrayMethod>

	cchooseintervalcaption = Select
	ccomparedintervals = 
	ccurrentintervals = 
	cfromdatefield = 
	cmaindialogcaption = Select interval
	Name = "cintervals"
	
	PROCEDURE assignadditionalvaluestonewinterval
		LPARAMETERS lp_oData
		* Here assign another values to scattered object, in subclassed object
		
		RETURN .T.
	ENDPROC

	PROCEDURE assignaddtitionalvaluestotable
		LPARAMETERS lp_oData
		* Here assign another values to scattered object, in subclassed object
		
		RETURN .T.
	ENDPROC

	PROCEDURE chooseintervals
		* User get overview of new intervals. User can select and unselect intervals.
		
		LOCAL l_nSelect
		LOCAL ARRAY l_aGridDef(3,4)
		l_nSelect = SELECT()
		
		SELECT (this.cComparedIntervals)
		
		GO TOP
		
		l_aGridDef(1,1) = "lselected"
		l_aGridDef(1,2) = 22
		l_aGridDef(1,3) = ""
		l_aGridDef(1,4) = "CHK"
		l_aGridDef(2,1) = this.cFromDateField
		l_aGridDef(2,2) = 75
		l_aGridDef(2,3) = GetLangText("ADDRESS","TXT_FROM")
		l_aGridDef(2,4) = "TXT"
		l_aGridDef(3,1) = this.cToDateField
		l_aGridDef(3,2) = 75
		l_aGridDef(3,3) = GetLangText("ADDRESS","TXT_TO")
		l_aGridDef(3,4) = "TXT"
		
		l_cCaption = this.cChooseIntervalCaption
		
		DO FORM "forms\brwmulsel" WITH this.cComparedIntervals, l_aGridDef, l_cCaption TO l_nRetVal
		
		SELECT (l_nSelect)
		
		RETURN (l_nRetVal = 1)
	ENDPROC

	PROCEDURE choosemaininterval
		LPARAMETERS lp_dDefFrom, lp_dDefTo
		* Calls dialog form, where user can enter datum interval. User can select weekdays.
		* Selected interval, and weekdays are stored in this.dFrom, this.dTo and this.aWeekday.
		LOCAL l_dFrom, l_dTo, i, l_cDefFrom, l_cDefTo, l_lSuccess
		LOCAL ARRAY l_aDlg(9,8)
		
		l_aDlg(1,1) = "dFrom"
		l_aDlg(1,2) = GetLangText("EVENT","TXT_FROM")
		l_aDlg(1,3) = SqlCnv(EVL(lp_dDefFrom,{}))
		l_aDlg(1,4) = ""
		l_aDlg(1,6) = "NOT EMPTY(dFrom)"
		l_aDlg(2,1) = "dTo"
		l_aDlg(2,2) = GetLangText("EVENT","TXT_TO")
		l_aDlg(2,3) = SqlCnv(EVL(lp_dDefTo,{}))
		l_aDlg(2,4) = ""
		l_aDlg(2,6) = "dFrom <= dTo"
		l_aDlg(3,1) = "chkMonday"
		l_aDlg(3,2) = GetLangText("FUNC","TXT_MONDAY")
		l_aDlg(3,3) = ".T."
		l_aDlg(3,4) = "@C"
		l_aDlg(3,6) = ""
		l_aDlg(3,8) = "lMonday"
		l_aDlg(4,1) = "chkTuesday"
		l_aDlg(4,2) = GetLangText("FUNC","TXT_TUESDAY")
		l_aDlg(4,3) = ".T."
		l_aDlg(4,4) = "@C"
		l_aDlg(4,6) = ""
		l_aDlg(4,8) = "lTuesday"
		l_aDlg(5,1) = "chkWednesday"
		l_aDlg(5,2) = GetLangText("FUNC","TXT_WEDNESDAY")
		l_aDlg(5,3) = ".T."
		l_aDlg(5,4) = "@C"
		l_aDlg(5,6) = ""
		l_aDlg(5,8) = "lWednesday"
		l_aDlg(6,1) = "chkThursday"
		l_aDlg(6,2) = GetLangText("FUNC","TXT_THURSDAY")
		l_aDlg(6,3) = ".T."
		l_aDlg(6,4) = "@C"
		l_aDlg(6,6) = ""
		l_aDlg(6,8) = "lThursday"
		l_aDlg(7,1) = "chkFriday"
		l_aDlg(7,2) = GetLangText("FUNC","TXT_FRIDAY")
		l_aDlg(7,3) = ".T."
		l_aDlg(7,4) = "@C"
		l_aDlg(7,6) = ""
		l_aDlg(7,8) = "lFriday"
		l_aDlg(8,1) = "chkSaturday"
		l_aDlg(8,2) = GetLangText("FUNC","TXT_SATURDAY")
		l_aDlg(8,3) = ".T."
		l_aDlg(8,4) = "@C"
		l_aDlg(8,6) = ""
		l_aDlg(8,8) = "lSaturday"
		l_aDlg(9,1) = "chkSunday"
		l_aDlg(9,2) = GetLangText("FUNC","TXT_SUNDAY")
		l_aDlg(9,3) = ".T."
		l_aDlg(9,4) = "@C"
		l_aDlg(9,6) = ""
		l_aDlg(9,8) = "lSunday"
		
		IF Dialog(this.cMainDialogCaption,,@l_aDlg)
			this.dFrom = l_aDlg(1,8)
			this.dTo = l_aDlg(2,8)
		
			* Get selected weekdays into array
			FOR i = 1 TO 7
				this.aWeekday(i) = l_aDlg(i+2, 8)
			NEXT
		
			IF NOT EMPTY(this.dFrom) AND NOT EMPTY(this.dTo) AND this.dFrom <= this.dTo
				l_lSuccess = .T.
			ENDIF
		ENDIF
		
		RETURN l_lSuccess
	ENDPROC

	PROCEDURE createcomparedcursor
		LOCAL l_cFromDateField
		
		this.cComparedIntervals = SYS(2015)
		
		SELECT *, CAST(0=1 AS l NULL) AS lSelected FROM (this.cCurrentIntervals) WHERE 0=1 INTO CURSOR (this.cComparedIntervals) READWRITE
		
		IF USED(this.cComparedIntervals)
			l_cFromDateField = this.cFromDateField
			SELECT (this.cComparedIntervals)
			INDEX ON &l_cFromDateField TAG tag1
		ENDIF
		
		RETURN .T.
	ENDPROC

	PROCEDURE createnewcursor
		this.cNewIntervals = SYS(2015)
		SELECT * FROM (this.cCurrentIntervals) WHERE 0=1 INTO CURSOR (this.cNewIntervals) READWRITE
		
		RETURN .T.
	ENDPROC

	PROCEDURE getcomparedintervals
		* Takes existing intervals from temp cursor this.cCurrentIntervals and new intervals form this.cNewIntervals.
		* Result are intervals without possible overlapping in this.cComparedIntervals cursor.
		LOCAL l_nSelect, l_cOldNear, l_oOld, l_oNew
		LOCAL l_cFromDateField, l_cToDateField, l_lNewLeftPart, l_lNewRightPart, l_lOldInterval
		LOCAL ARRAY l_aResult(3,3)
		
		l_nSelect = SELECT()
		
		this.CreateComparedCursor()
		
		l_cOldNear = SET("NEAR")
		SET NEAR ON
		
		l_cFromDateField = this.cFromDateField
		l_cToDateField = this.cToDateField
		
		SELECT (this.cNewIntervals)
		SCAN
			SCATTER NAME l_oNew
			SELECT (this.cCurrentIntervals)
			= SEEK(l_oNew.&l_cFromDateField, this.cCurrentIntervals, "tag1")
			SCATTER NAME l_oOld
			DO WHILE this.Overlapped(l_oNew, l_oOld, @l_aResult) AND NOT EOF()
				l_lNewLeftPart = l_aResult(1,3)
				l_lNewRightPart = l_aResult(3,3)
				IF l_lNewLeftPart
					l_lOldInterval = .F.
					this.InsertIntoComparedIntervals(l_aResult(1,1), l_aResult(1,2), l_lOldInterval)
					l_oNew.&l_cFromDateField = l_aResult(1,2) + 1
				ENDIF
				l_lOldInterval = .T.		
				this.InsertIntoComparedIntervals(l_aResult(2,1), l_aResult(2,2), l_lOldInterval)
				l_oNew.&l_cFromDateField = l_aResult(2,2) + 1
				IF l_lNewRightPart
					l_oNew.&l_cFromDateField = l_aResult(3,1)
				ENDIF
				SELECT (this.cCurrentIntervals)
				SKIP
				SCATTER NAME l_oOld
			ENDDO
			IF l_oNew.&l_cFromDateField <= l_oNew.&l_cToDateField
				l_lOldInterval = .F.
				this.InsertIntoComparedIntervals(l_oNew.&l_cFromDateField, l_oNew.&l_cToDateField, l_lOldInterval)
			ENDIF
			SELECT (this.cNewIntervals)
		ENDSCAN
		
		SET NEAR &l_cOldNear
		
		SELECT (l_nSelect)
		
		RETURN .T.
	ENDPROC

	PROCEDURE getcurrentintervals
		LPARAMETERS lp_cSQL
		* Creates temp cursor, with existing intervals. this.cCurrentIntervals has cursos name.
		LOCAL l_nSelect, l_cFromDateField
		
		l_nSelect = SELECT()
		
		this.cCurrentIntervals = SYS(2015)
		&lp_cSql INTO CURSOR (this.cCurrentIntervals) READWRITE
		
		IF USED(this.cCurrentIntervals)
			l_cFromDateField = this.cFromDateField
			SELECT (this.cCurrentIntervals)
			INDEX ON &l_cFromDateField TAG tag1
		ENDIF
		
		SELECT (l_nSelect)
		
		RETURN .T.
	ENDPROC

	PROCEDURE getnewintervals
		* Makes new intervals, with from and to date and weekdays, which user has selected.
		* Intervals are stored in temp cursor with name in this.cNewIntervals.
		LOCAL l_cTempAlias, l_lIntervalFound, l_dFrom, l_dTo, l_dCurrentDate, l_cTypeDescription
		LOCAL l_cFromDateField, l_cToDateField, l_lDayChecked, l_lNextDayChecked, l_lIntervalFound, l_nSelected
		
		l_nSelected = SELECT()
		
		l_cFromDateField = this.cFromDateField
		l_cToDateField = this.cToDateField
		
		this.CreateNewCursor()
		l_dCurrentDate = this.dFrom
		l_dFrom = {}
		DO WHILE l_dCurrentDate <= this.dTo
			l_lDayChecked = this.aWeekDay(DOW(l_dCurrentDate,2))
			IF EMPTY(l_dFrom) AND l_lDayChecked
				l_dFrom = l_dCurrentDate
			ENDIF
			l_lNextDayChecked = this.aWeekDay(DOW(l_dCurrentDate+1,2))
			l_lIntervalFound = l_lDayChecked AND (NOT l_lNextDayChecked OR l_dCurrentDate = this.dTo)
			IF l_lIntervalFound
				l_dTo = l_dCurrentDate
				* Write data to cNewIntervals cursor
				SELECT (this.cCurrentIntervals)
				SCATTER NAME l_oData MEMO
				l_oData.&l_cFromDateField = l_dFrom
				l_oData.&l_cToDateField = l_dTo
				this.AssignAdditionalValuesToNewInterval(l_oData)
				SELECT (this.cNewIntervals)
				APPEND BLANK
				GATHER NAME l_oData MEMO
				l_dFrom = {}
			ENDIF
			l_dCurrentDate = l_dCurrentDate + 1
		ENDDO
		
		SELECT(l_nSelected)
		
		RETURN .T.
	ENDPROC

	PROCEDURE insertintocomparedintervals
		LPARAMETERS lp_dFrom, lp_dTo, lp_lOldInterval
		LOCAL l_nSelect, l_oData, l_cFromDateField, l_cToDateField
		
		l_nSelect = SELECT()
		
		SELECT (this.cNewIntervals)
		SCATTER NAME l_oData MEMO
		
		l_cFromDateField = this.cFromDateField
		l_cToDateField = this.cToDateField
		l_oData.&l_cFromDateField = lp_dFrom
		l_oData.&l_cToDateField = lp_dTo
		
		SELECT (this.cComparedIntervals)
		APPEND BLANK
		GATHER NAME l_oData MEMO
		
		IF lp_lOldInterval
			* Set lselected field as .NULL., when old interval is found, to disable checbox in browse dialog
			REPLACE lSelected WITH .NULL.
		ENDIF
		
		SELECT (l_nSelect)
		
		RETURN .T.
	ENDPROC

	PROCEDURE overlapped
		LPARAMETERS lp_oNew, lp_oOld, lp_aResult
		EXTERNAL ARRAY lp_aResult
		LOCAL l_lSuccess, l_cFromDateField, l_cToDateField
		LOCAL l_aInterval(2,2)
		
		l_cFromDateField = this.cFromDateField
		l_cToDateField = this.cToDateField
		
		l_aInterval(1,1) = lp_oNew.&l_cFromDateField
		l_aInterval(1,2) = lp_oNew.&l_cToDateField
		l_aInterval(2,1) = lp_oOld.&l_cFromDateField
		l_aInterval(2,2) = lp_oOld.&l_cToDateField
		IF l_aInterval(1,1) <= l_aInterval(2,2) AND l_aInterval(2,1) <= l_aInterval(1,2)
			lp_aResult(1,1) = MIN(l_aInterval(1,1), l_aInterval(2,1))
			lp_aResult(1,2) = MAX(l_aInterval(1,1), l_aInterval(2,1)) - 1
			lp_aResult(1,3) = lp_aResult(1,1) <= lp_aResult(1,2) AND BETWEEN(lp_aResult(1,1), l_aInterval(1,1), l_aInterval(1,2))
		
			lp_aResult(2,1) = MAX(l_aInterval(1,1), l_aInterval(2,1))
			lp_aResult(2,2) = MIN(l_aInterval(1,2), l_aInterval(2,2))
			lp_aResult(2,3) = lp_aResult(2,1) <= lp_aResult(2,2)
		
			lp_aResult(3,1) = MIN(l_aInterval(1,2), l_aInterval(2,2)) + 1
			lp_aResult(3,2) = MAX(l_aInterval(1,2), l_aInterval(2,2))
			lp_aResult(3,3) = lp_aResult(3,1) <= lp_aResult(3,2) AND BETWEEN(lp_aResult(3,1), l_aInterval(1,1), l_aInterval(1,2))
		
			l_lSuccess = .T.
		ENDIF
		
		RETURN l_lSuccess
	ENDPROC

	PROCEDURE start
		LPARAMETERS lp_dDefaultFrom, lp_dDefaultTo, lp_cTableAlias, lp_cSql, lp_cFromDateField, lp_cToDateField
		* Main method, which calls dialog to enter date interval, compares this interval with already existing intervals, 
		* and shows in browse to user new intervals, which would be written in table. User can choose, which intervals
		* would be written.
		LOCAL l_cSuccess, l_nSelect
		
		this.cTableAlias = lp_cTableAlias
		this.cFromDateField = lp_cFromDateField
		this.cToDateField = lp_cToDateField
		
		l_nSelect = SELECT()
		
		l_lSuccess = this.ChooseMainInterval(lp_dDefaultFrom, lp_dDefaultTo)
		
		IF l_lSuccess
			this.GetCurrentIntervals(lp_cSql)
			this.GetNewIntervals()
			this.GetComparedIntervals()
			l_lSuccess = this.ChooseIntervals()
			IF l_lSuccess
				l_lSuccess = this.UpdateSelectedIntervals()
			ENDIF
		ENDIF
		
		dclose(this.cCurrentIntervals)
		dclose(this.cNewIntervals)
		dclose(this.cComparedIntervals)
		
		SELECT (l_nSelect)
		
		RETURN l_lSuccess
	ENDPROC

	PROCEDURE updateselectedintervals
		* Here are intervals written into table.
		LOCAL l_CopyData, l_nSelect
		
		IF USED(this.cComparedIntervals)
			l_nSelect = SELECT()
			SELECT (this.cComparedIntervals)
			SCAN FOR lSelected
				SCATTER NAME l_CopyData
				this.AssignAddtitionalValuesToTable(l_CopyData)
				SELECT (this.cTableAlias)
				APPEND BLANK
				GATHER NAME l_CopyData
				SELECT (this.cComparedIntervals)
			ENDSCAN
			SELECT (l_nSelect)
		ENDIF
	ENDPROC

ENDDEFINE
