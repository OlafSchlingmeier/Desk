*--------------------------------------------------------------------------------------------------------------------------------------------------------
* (ES) AUTOGENERADO - ¡¡ATENCIÓN!! - ¡¡NO PENSADO PARA EJECUTAR!! USAR SOLAMENTE PARA INTEGRAR CAMBIOS Y ALMACENAR CON HERRAMIENTAS SCM!!
* (EN) AUTOGENERATED - ATTENTION!! - NOT INTENDED FOR EXECUTION!! USE ONLY FOR MERGING CHANGES AND STORING WITH SCM TOOLS!!
*--------------------------------------------------------------------------------------------------------------------------------------------------------
*< FOXBIN2PRG: Version="1.19" SourceFile="main.vcx" /> (Solo para binarios VFP 9 / Only for VFP 9 binaries)
*
*
DEFINE CLASS _comdlg AS _custom OF "..\common\ffc\_base.vcx" 
 	*< CLASSDATA: Baseclass="custom" Timestamp="" Scale="Pixels" Uniqueid="" />

	*<DefinedPropArrayMethod>
		*m: addfilter		&& Sets file extension filters for use when displaying dialog.
		*m: cleardlls
		*m: clearfilters		&& Clears all file extension filters.
		*m: dialoghandler
		*m: integertostring
		*m: loaddlls
		*m: showdialog		&& Displays dialog with various options such as filters.
		*m: stringtointeger
		*m: testdialog		&& Test script for displaying a dialog.
		*p: ccustomfilter		&& Custom filter the user created while using dialog.
		*p: cdefaultextension		&& Default file extension to display.
		*p: cfilename		&& Name of file selected or initially set as default.
		*p: cfilepath		&& Path that files were selected from.
		*p: cfiletitle		&& File title property of the selected file(s).
		*p: cinitialdirectory		&& Initial directory to show files from.
		*p: ctitlebartext		&& Caption for dialog title bar.
		*p: lallowmultiselect		&& Whether to allow selection of multiple files.
		*p: lfilemustexist		&& Allows only valid existing files to be entered.
		*p: lhidereadonly		&& Hides read-only files from list.
		*p: lnewexplorer		&& Use new explorer user interface and features such as Places bar.
		*p: lnochangedir		&& Don't allow initially displayed directory to be changed.
		*p: lnonetworkbutton		&& Do not include a network button in dialog.
		*p: lnoplacesbar		&& Do not include Places bar in dialog.
		*p: lnovalidate
		*p: lsavedialog		&& Use Save dialog instead of Open one.
		*p: nfilecount		&& Number of files selected from dialog.
		*p: nfilterindex		&& Specifies which of the filters the user selected from the dialog.
		*p: nhwndowner		&& For internal use only.
		*p: ninstance		&& For internal use only.
		*a: afilenames[1,0]		&& Array of filenames returned from dialog.
		*a: afilterlist[1,2]		&& Array of file extension filters passed to dialog.
	*</DefinedPropArrayMethod>

	ccustomfilter = 		&& Custom filter the user created while using dialog.
	cdefaultextension = 		&& Default file extension to display.
	cfilename = 		&& Name of file selected or initially set as default.
	cfilepath = 		&& Path that files were selected from.
	cfiletitle = 		&& File title property of the selected file(s).
	cinitialdirectory = 		&& Initial directory to show files from.
	ctitlebartext = 		&& Caption for dialog title bar.
	lhidereadonly = .T.		&& Hides read-only files from list.
	lnewexplorer = .T.		&& Use new explorer user interface and features such as Places bar.
	Name = "_comdlg"
	nfilecount = 0		&& Number of files selected from dialog.
	nfilterindex = 0		&& Specifies which of the filters the user selected from the dialog.
	nhwndowner = 0		&& For internal use only.
	ninstance = 0		&& For internal use only.
	
	PROCEDURE addfilter		&& Sets file extension filters for use when displaying dialog.
		LPARAMETERS cDescription, cSkeleton
		LOCAL nNewRow
		nNewRow = ALEN(THIS.aFilterList,1) + 1
		DIMENSION THIS.aFilterList[nNewRow,2]
		THIS.aFilterList[nNewRow,1] = cDescription
		IF VARTYPE(cSkeleton)#"C" OR EMPTY(cSkeleton)
			THIS.aFilterList[nNewRow,2] = "*.*"
		ELSE
			THIS.aFilterList[nNewRow,2] = cSkeleton
		ENDIF
		THIS.nFilterIndex = nNewRow
		
	ENDPROC

	PROTECTED PROCEDURE cleardlls
		CLEAR DLLS _FFC_SAVEFILENAME
		CLEAR DLLS _FFC_GETFILENAME
		CLEAR DLLS _FFC_MEMCPY
		CLEAR DLLS _FFC_MEMCPY2
		CLEAR DLLS _FFC_MALLOC
		CLEAR DLLS _FFC_FREEMEM
		
	ENDPROC

	PROCEDURE clearfilters		&& Clears all file extension filters.
		LPARAMETERS lComplete
		DIMENSION THIS.aFilterList[1,2]
		IF lComplete
			THIS.aFilterList= ""
		ELSE
			THIS.aFilterList[1,1] = "All files (*.*)"
			THIS.aFilterList[1,2] = "*.*"
		ENDIF
		
	ENDPROC

	PROTECTED PROCEDURE dialoghandler
		
		#DEFINE OFN_READONLY                 0x00000001
		#DEFINE OFN_OVERWRITEPROMPT          0x00000002
		#DEFINE OFN_HIDEREADONLY             0x00000004
		#DEFINE OFN_NOCHANGEDIR              0x00000008
		#DEFINE OFN_SHOWHELP                 0x00000010
		#DEFINE OFN_ENABLEHOOK               0x00000020
		#DEFINE OFN_ENABLETEMPLATE           0x00000040
		#DEFINE OFN_ENABLETEMPLATEHANDLE     0x00000080
		#DEFINE OFN_NOVALIDATE               0x00000100
		#DEFINE OFN_ALLOWMULTISELECT         0x00000200
		#DEFINE OFN_EXTENSIONDIFFERENT       0x00000400
		#DEFINE OFN_PATHMUSTEXIST            0x00000800
		#DEFINE OFN_FILEMUSTEXIST            0x00001000
		#DEFINE OFN_CREATEPROMPT             0x00002000
		#DEFINE OFN_SHAREAWARE               0x00004000
		#DEFINE OFN_NOREADONLYRETURN         0x00008000
		#DEFINE OFN_NOTESTFILECREATE         0x00010000
		#DEFINE OFN_NONETWORKBUTTON          0x00020000		&& for old style dialog
		#DEFINE OFN_NOLONGNAMES              0x00040000     && force no long names for 4.x modules
		#DEFINE OFN_EXPLORER                 0x00080000     && new look commdlg
		#DEFINE OFN_NODEREFERENCELINKS       0x00100000
		#DEFINE OFN_LONGNAMES                0x00200000     && force long names for 3.x modules
		#DEFINE OFN_ENABLEINCLUDENOTIFY      0x00400000     && send include message to callback
		#DEFINE OFN_ENABLESIZING             0x00800000
		#DEFINE OFN_EX_NOPLACESBAR         	 0x00000001		&& used for newer OS only (uses FlagsEx)
		
		
		LOCAL lStructSize, hwndOwner, hInstance,;
		cMyFilter, i, lpMyFilter,;
		nMaxCustomFilter, cUserCustomFilter, lpUserCustomFilter,;
		nMaxFileName, cFileName, lpFileName,;
		nMaxFileTitle, cFileTitle, lpFileTitle
		LOCAL lpInitialDirectory, lpTitlebarText, nFlags, nFlagsEx, ;
		nFileOffset, nFileExtension, cDefExt,;
		lpDefExt, lCustomData, lpHook, lpTemplateName,;
		cMyStruct, nReturnVal, nFileNameOffset 
		LOCAL lcFileName, lcUserCustomFilter, lcFileTitle,;
		nCurrentFilePos, nArraySize, nNextFilePos 
		
		hwndOwner = THIS.nHwndOwner
		hInstance = THIS.nInstance
		nFlags = 0
		nFlags = OFN_ENABLEHOOK        
		nFlagsEx = 0
		
		*  Build the filter string.
		cMyFilter = ""
		FOR i = 1 TO ALEN(THIS.aFilterList, 1)
			cMyFilter = cMyFilter + THIS.aFilterList[m.i,1] + CHR(0) + THIS.aFilterList[m.i,2] + CHR(0)
		ENDFOR
		cMyFilter = cMyFilter + + REPL(CHR(0),2)
		lpMyFilter = _FFC_MALLOC(LEN(cMyFilter))
		IF lpMyFilter = 0
			* Couldn't allocate memory
			RETURN ""
		ENDIF
		
		*  Setup Flags
		IF THIS.lNewExplorer
			nFlags = nFlags + OFN_EXPLORER
		ENDIF
		IF THIS.lHideReadOnly
			nFlags = nFlags + OFN_HIDEREADONLY 
		ENDIF
		IF THIS.lFileMustExist
			nFlags = nFlags + OFN_FILEMUSTEXIST 
		ENDIF
		IF THIS.lNoNetworkButton
			* Old style dialogs only
			nFlags = nFlags + OFN_NONETWORKBUTTON 
		ENDIF
		IF THIS.lNoChangeDir
			nFlags = nFlags + OFN_NOCHANGEDIR 
		ENDIF
		IF THIS.lNoValidate
			nFlags = nFlags + OFN_NOVALIDATE
		ENDIF
		IF THIS.lAllowMultiSelect AND !THIS.lSaveDialog
			nFlags = nFlags + OFN_ALLOWMULTISELECT 
		ENDIF
		
		*  Setup FlagsEx
		IF THIS.lnoplacesbar
			nFlagsEx = nFlagsEx + OFN_EX_NOPLACESBAR
		ENDIF
		
		DECLARE INTEGER memcpy IN msvcrt.dll AS _FFC_MEMCPY  INTEGER , STRING @, INTEGER
		
		_FFC_MEMCPY(lpMyFilter, @cMyFilter, len(cMyFilter))
		
		*  Prepare the custom filter string
		nMaxCustomFilter = 1024
		cUserCustomFilter = REPL(CHR(0), nMaxCustomFilter)
		lpUserCustomFilter = _FFC_MALLOC(nMaxCustomFilter)
		IF lpUserCustomFilter = 0
			* Couldn't allocate memory
			_FFC_FREEMEM(lpMyFilter)
			RETURN ""
		ENDIF
		_FFC_MEMCPY(lpUserCustomFilter, @cUserCustomFilter, nMaxCustomFilter)
		
		* Prepare the string for the selected filename(s)
		nMaxFileName = 1024
		cFileName = LEFT(THIS.cFileName, 1023) + REPL(CHR(0), nMaxFileName - MIN(LEN(THIS.cFileName),1023))
		lpFileName = _FFC_MALLOC(nMaxFileName)
		IF lpFileName = 0
			_FFC_FREEMEM(lpMyFilter)
			_FFC_FREEMEM(lpUserCustomFilter)
		ENDIF
		_FFC_MEMCPY(lpFileName, @cFileName, nMaxFileName)
		
		*  File Title
		nMaxFileTitle = 300
		cFileTitle  = REPL(CHR(0), nMaxFileTitle)
		lpFileTitle = _FFC_MALLOC(nMaxFileTitle)
		IF lpFileTitle = 0
			_FFC_FREEMEM(lpMyFilter)
			_FFC_FREEMEM(lpUserCustomFilter)
			_FFC_FREEMEM(lpFileName)
		ENDIF
		_FFC_MEMCPY(lpFileTitle, @cFileTitle, nMaxFileTitle)
		
		*  Initial Directory
		lpInitialDirectory = _FFC_MALLOC(266)
		IF lpInitialDirectory = 0
			_FFC_FREEMEM(lpMyFilter)
			_FFC_FREEMEM(lpUserCustomFilter)
			_FFC_FREEMEM(lpFileName)
			_FFC_FREEMEM(lpFileTitle)
		ENDIF		
		_FFC_MEMCPY(lpInitialDirectory, THIS.cInitialDirectory + CHR(0), MIN(LEN(THIS.cInitialDirectory) + 1, 260))
		
		* Title bar text
		lpTitlebarText = _FFC_MALLOC(Len(THIS.cTitlebartext) + 2)
		_FFC_MEMCPY(lpTitlebarText, THIS.cTitlebartext + CHR(0) + CHR(0), LEN(THIS.cTitlebarText) + 2)
		
		nFileOffset = 0
		nFileExtension = 0
		
		* Default Extension
		cDefExt = "TXT" + CHR(0) + CHR(0)
		lpDefExt = _FFC_MALLOC(LEN(THIS.cDefaultExtension) + 1)
		_FFC_MEMCPY(lpDefExt, THIS.cDefaultExtension + CHR(0), LEN(THIS.cDefaultExtension) + 1)
		
		lCustomData = 0	&& not used without a hook
		lpHook = 0
		lpTemplateName = 0
		
		lStructSize = IIF(VAL(OS(3)) > 4, 22, 19) * 4
		
		cMyStruct = THIS.IntegerToString(lStructSize,4) + ;
			THIS.IntegerToString(hwndOwner,4) + ;
			THIS.IntegerToString(hInstance,4) + ;
			THIS.IntegerToString(lpMyFilter,4) + ;
			THIS.IntegerToString(lpUserCustomFilter,4) + ;
			THIS.IntegerToString(nMaxCustomFilter,4) + ;
			THIS.IntegerToString(THIS.nFilterIndex,4) + ;
			THIS.IntegerToString(lpFileName,4) + ;
			THIS.IntegerToString(nMaxFileName,4) + ;
			THIS.IntegerToString(lpFileTitle,4) + ;
			THIS.IntegerToString(nMaxFileTitle,4) + ;
			THIS.IntegerToString(lpInitialDirectory,4) + ;
			THIS.IntegerToString(lpTitleBarText,4) + ;
			THIS.IntegerToString(nFlags,4) + ;
			THIS.IntegerToString(nFileOffset,2) + ;
			THIS.IntegerToString(nFileExtension,2) + ;
			THIS.IntegerToString(lpDefExt,4) + ;
			THIS.IntegerToString(lCustomData,4) + ;
			THIS.IntegerToString(lpHook,4) + ;
			THIS.IntegerToString(lpTemplateName,4)
		
		IF VAL(OS(3)) > 4
			cMyStruct = cMyStruct + ;
			THIS.IntegerToString(0,4) + ;
			THIS.IntegerToString(0,4) + ;
			THIS.IntegerToString(nFlagsEx,4)
		ENDIF
		
		* Call the dialog now
		IF THIS.lsavedialog
			nReturnVal = _FFC_SAVEFILENAME(@cMyStruct)
		ELSE
			nReturnVal = _FFC_GETFILENAME(@cMyStruct)
		ENDIF
		
		IF nReturnVal = 1
			*  Now retrieve info from allocated strings		
			*  Retrieve Filename string
			DECLARE INTEGER memcpy in msvcrt.dll AS	_FFC_MEMCPY2 STRING @, INTEGER , INTEGER
			lcFileName = REPL(CHR(0),nMaxFileName)
			_FFC_MEMCPY2(@lcFileName, lpFileName, nMaxFileName)
			nFileNameOffset = THIS.StringToInteger(SUBSTR(cMyStruct, 14*4+1, 2), 2)
		
			*  Check if user selected multiple files.
			IF THIS.lAllowMultiSelect AND nFileNameOffset > 1 AND SUBSTR(lcFileName, nFileNameOffset, 1) = CHR(0)
				*Now parse out to get multiple file names
				nCurrentFilePos = AT(CHR(0), lcFileName) + 1
				THIS.cFilePath = LEFT(lcFileName, nCurrentFilePos - 2)
				nArraySize = 1
				DO WHILE .T.
					IF SUBSTR(lcFileName, nCurrentFilePos, 1) = CHR(0)
						* end of list.
						EXIT
					ENDIF
					DIMENSION THIS.aFileNames[nArraySize]
					nNextFilePos = AT(CHR(0), lcFileName, nArraySize + 1) + 1
					THIS.aFileNames[nArraySize] = SUBSTR(lcFileName, nCurrentFilePos, nNextFilePos - nCurrentFilePos - 1)
					nArraySize = nArraySize + 1
					nCurrentFilePos = nNextFilePos
				ENDDO
				THIS.nFileCount = nArraySize - 1
			ELSE
				*  Didn't multiselect, so there's just one filename.
				lcFileName = LEFT(lcFileName, AT(CHR(0), lcFileName) - 1)
				THIS.cFilePath = JUSTPATH(lcFileName)
				DIMENSION THIS.aFileNames[1]
				THIS.aFileNames[1] = JUSTFNAME(lcFileName)
				THIS.nFileCount = 1
			ENDIF
					
			THIS.cFileName = LEFT(lcFileName, AT(CHR(0), lcFileName) - 1)
		
			lcUserCustomFilter= repl(chr(0), nMaxCustomFilter)
			_FFC_MEMCPY2(@lcUserCustomFilter, lpUserCustomFilter, nMaxCustomFilter)
			THIS.cCustomFilter= LEFT(lcUserCustomFilter, AT(CHR(0), lcUserCustomFilter) - 1)
		
			lcFileTitle = repl(chr(0), nMaxFileTitle)
			_FFC_MEMCPY2(@lcFileTitle, lpFileTitle, nMaxFileTitle)
			THIS.cFileTitle = LEFT(lcFileTitle , AT(CHR(0), lcFileTitle ) - 1)
					
			THIS.nFilterIndex = THIS.StringToInteger(SUBSTR(cMyStruct, 6*4+1, 4), 4)
		ENDIF
		
		_FFC_FREEMEM(lpMyFilter)
		_FFC_FREEMEM(lpUserCustomFilter)
		_FFC_FREEMEM(lpFileName)
		_FFC_FREEMEM(lpFileTitle)
		_FFC_FREEMEM(lpInitialDirectory)
		_FFC_FREEMEM(lpTitleBarText)
		_FFC_FREEMEM(lpDefExt)
				
		RETURN nReturnVal
	ENDPROC

	PROCEDURE Init
		THIS.aFilterList[1,1] = "All Files (*.*)"
		THIS.aFilterList[1,2] = "*.*"
		
	ENDPROC

	PROTECTED PROCEDURE integertostring
		LPARAMETERS nInteger, nBytes
		LOCAL cRetVal
		IF pCount() < 2
			nBytes = 4
		ENDIF
		cRetVal = ""
		FOR nCurByte = 1 to nBytes
			cRetVal = cRetVal + CHR(BITAND(BITRSHIFT(nInteger, 8 * (nCurByte -1) ), 255))
		ENDFOR
		RETURN cRetVal
		
	ENDPROC

	PROTECTED PROCEDURE loaddlls
		DECLARE INTEGER GetSaveFileNameA IN comdlg32.dll AS _FFC_SAVEFILENAME STRING @
		DECLARE INTEGER GetOpenFileNameA IN comdlg32.dll AS _FFC_GETFILENAME STRING @
		DECLARE INTEGER malloc IN msvcrt.dll AS _FFC_MALLOC INTEGER
		DECLARE free in msvcrt.dll AS _FFC_FREEMEM INTEGER 
		
	ENDPROC

	PROCEDURE showdialog		&& Displays dialog with various options such as filters.
		THIS.LoadDLLs()
		THIS.DialogHandler()
		THIS.ClearDLLs()
		
	ENDPROC

	PROTECTED PROCEDURE stringtointeger
		LPARAMETERS cPDWORD, nBytes
		LOCAL nCurByte, nRetVal
		IF PCOUNT() < 2
			nBytes = LEN(cPDWord)
		ENDIF
		nRetVal = 0
		FOR nCurByte = 1 to nBytes
			nRetVal = nRetVal + ASC(SUBSTR(cPDWord, nCurByte, 1))*(256^(nCurByte-1))
		ENDFOR
		RETURN nRetVal
		
	ENDPROC

	PROCEDURE testdialog		&& Test script for displaying a dialog.
		
		LOCAL i
		* This is a sample program to test dialog
		
		THIS.AddFilter("My VFP files (*.prg, etc.)", "*.PRG;*.SCX;*.VCX;*.PJX")
		THIS.AddFilter("My text files (*.txt, etc.)", "*.TXT; *.H")
		
		*  Dialog properties.
		THIS.cTitlebarText = "This is a test dialog"
		THIS.lAllowMultiselect = .T.
		
		*  Initial defaults.
		THIS.cFileName = "test.prg"
		THIS.cInitialDirectory = "c:\temp"
		THIS.cDefaultExtension = "TXT"
		
		*  Display the dialog and get results.
		THIS.showdialog()
		
		*  Display the name(s) of the file(s) selected.
		FOR i = 1 to x.nFileCount
			? "File name: " + TRANS(m.i) + ":", THIS.aFileNames[m.i]
		ENDFOR
		
		? "Files were chosen from:", THIS.cFilePath
		? "FileName property:", THIS.cFileName
		? "FileTitle property:", THIS.cFileTitle
		? "Custom filter that the user created:" , THIS.cCustomFilter
		? "Filter index (which of our filters the user selected):", THIS.nFilterIndex
		
		THIS.clearfilters()
	ENDPROC

ENDDEFINE

DEFINE CLASS _error AS custom 		&& Error handler
 	*< CLASSDATA: Baseclass="custom" Timestamp="" Scale="Pixels" Uniqueid="" />

	#INCLUDE "..\common\ffc\_app.h"
	*<DefinedPropArrayMethod>
		*m: displayerrorlog		&& Displays error log.
		*m: doerrorlogui		&& Called by DisplayErrorLog for actual UI display after setup.  The simple default behavior here (BROWSE NOWAIT) is meant to be overridden by application-specific behavior.
		*m: fillarrays		&& Fills error classification array (aErrorClass) first time, and current error array (aErrors) for each error that occurs.  Bails if conditions are so severe (memory errors) that further processing is undesirable.
		*m: filllogrecord		&& Writes error information to the log.
		*m: geterrorattribute		&& Returns appropriate information from aErrorClass array for a given error number.
		*m: getmessageboxtitle		&& This is really meant for your subclass or instance to fill out with app-specific information, so that all user feedback (WAIT WINDOW NOWAITs and MESSAGEBOX()) by the error object matches your app properly.
		*m: handle		&& Main routine to handle error.
		*m: isdisallowedserveraction		&& Tells whether the error is caused by an attempt to execute UI or other disallowed action from a server
		*m: isfatal		&& Whether error is a fatal type error.
		*m: isgooderrorlog		&& Validates error log
		*m: istrivial		&& Whether error is a trivial type error.
		*m: logerrorreport		&& If lServer is .T. or user indicates logging is desired, opens error log and logs the error.
		*m: oktocontinue		&& Abstract  method to evaluate error whether to continue program execution.
		*m: oktoreport		&& Abstract method to evaluate error whether to report error.
		*m: recordservererror		&& Establishes a consistent method for logging feedback which would ordinarily go to UI, for use in servers
		*m: setlog		&& Evaluates log table name and alias, attempts to open and validate the table, creates new alias and log table name on the fly if anything goes wrong.
		*m: usercancelled		&& Returns whether user opted to cancel after the current error.
		*m: userhandleserror		&& Gives user choices about whether to go on with the app after an error.
		*p: ccurrentclass		&& The error classification that the error object gives this particular error number.
		*p: ccurrenterrorparam		&& SYS(2018) of current error
		*p: ccurrentmessage		&& MESSAGE() of current error
		*p: ccurrentmethod		&& Method  or procedure where error occurred, as passed to Handle().
		*p: cdatadir
		*p: clogalias		&& Alias under which the error log is opened.  See SetLog().
		*p: clogdbf		&& Fully qualified name of current error table on disk.  See SetLog().
		*p: icurrenterror		&& Error number for current error.
		*p: icurrentline		&& Line where current error occurred.
		*p: lserver		&& Checks _VFP.StartMode to see whether any sort of modal feedback should be avoided.
		*p: lusercancelled		&& Allows the outside program to cleanup and do whatever is necessary before release.
		*a: aerrorclass[1,3]		&& Error numbers by classification for evaluation of type and severity.
		*a: aerrors[1,6]
	*</DefinedPropArrayMethod>

	ccurrentclass = ("")		&& The error classification that the error object gives this particular error number.
	ccurrenterrorparam = ("")		&& SYS(2018) of current error
	ccurrentmessage = ("")		&& MESSAGE() of current error
	ccurrentmethod = ("")		&& Method  or procedure where error occurred, as passed to Handle().
	cdatadir = 
	clogalias = ("")		&& Alias under which the error log is opened.  See SetLog().
	clogdbf = ("")		&& Fully qualified name of current error table on disk.  See SetLog().
	icurrenterror = 0		&& Error number for current error.
	icurrentline = 0		&& Line where current error occurred.
	lserver = (INLIST(_VFP.StartMode,1,2,3,5))		&& Checks _VFP.StartMode to see whether any sort of modal feedback should be avoided.
	Name = "_error"
	
	PROCEDURE Destroy
		LOCAL liSession
		liSession = SET("DATASESSION")
		SET DATASESSION TO 1
		IF USED(THIS.cLogAlias)
		   USE IN (THIS.cLogAlias)
		   * this is actually only going to happen
		   * in the "default" datasession
		   * because any other USEs should have
		   * been closed when their forms and formsets
		   * died by this point.
		   * note that the errorlog may be opened
		   * many times in different sessions, and
		   * this session information will be reflected in the log
		ENDIF   
		SET DATASESSION TO liSession
		DODEFAULT()
		
	ENDPROC

	PROCEDURE displayerrorlog		&& Displays error log.
		LOCAL liSelect
		liSelect = SELECT()
		THIS.SetLog()
		
		DO CASE
		
		CASE (EMPTY(THIS.cLogAlias) OR NOT USED(THIS.cLogAlias))
		
		   IF NOT THIS.lServer
		   
		     MESSAGEBOX(ERROR_LOG_UNAVAILABLE_LOC,;
		                MB_ICONEXCLAMATION,;
		                THIS.GetMessageBoxTitle())
		   ENDIF                
		
		CASE RECCOUNT(THIS.cLogAlias) = 0 
		   
		   IF NOT THIS.lServer
		
		      MESSAGEBOX(ERROR_LOG_EMPTY_LOC,;
		                 MB_ICONEXCLAMATION,;
		                 THIS.GetMessageBoxTitle())
		   ENDIF
		
		OTHERWISE
		
		   SELECT (THIS.cLogAlias)
		   THIS.DoErrorLogUI(THIS.cLogAlias)
		   SELECT (liSelect)
		
		ENDCASE   
		     
		
	ENDPROC

	PROCEDURE doerrorlogui		&& Called by DisplayErrorLog for actual UI display after setup.  The simple default behavior here (BROWSE NOWAIT) is meant to be overridden by application-specific behavior.
		LPARAMETERS tcAlias
		
		* this code is really expecting to be overridden
		IF NOT THIS.lServer
		   BROWSE NORMAL NOWAIT
		ENDIF   
	ENDPROC

	PROCEDURE Error
		LPARAMETERS nError, cMethod, nLine
		* special case, must override
		* any use of ON ERROR which
		* might call this object recursively
		IF "setlog" $ LOWER(cMethod)
		   THIS.cLogDBF = ""
		ELSE   
		   ERROR ERROR_IN_ERROR_METHOD_LOC+":"+CHR(13)+ ;
		      "#"+TRANSFORM(nError)+CHR(13)+ ;
		      THIS.Name+" "+cMethod+", "+TRANSFORM(nLine)+CHR(13)+ ;
		      THIS.cCurrentMessage
		ENDIF      
		
	ENDPROC

	PROCEDURE fillarrays		&& Fills error classification array (aErrorClass) first time, and current error array (aErrors) for each error that occurs.  Bails if conditions are so severe (memory errors) that further processing is undesirable.
		IF VARTYPE(THIS.aErrorClass[1]) ="L"
		   * first time through
		   THIS.aErrorClass[1,2] = "memory"
		   THIS.aErrorClass[1,1] = "/21/22/43/1012/1149/1150/1151/1201/1202/1507/1600/1809/1986/2000/"
		ENDIF
		
		LOCAL lcErrString, llBail 
		
		lcErrString = "/"+TRANSFORM(THIS.iCurrentError)+"/"
		
		IF lcErrString $ THIS.aErrorClass[1,1]
		   llBail = .T.
		ELSE
		   =AERROR(THIS.aErrors)   
		ENDIF
		
		IF (NOT llBail) AND (TYPE("THIS.aErrorClass[2,1]") # "C")
		
		   DIME THIS.aErrorClass[16,2]
		   * note: you can add more columns for more error attributes,
		   * for example a severity gauge for different classes
		   * or other error class groupings
		  
		   THIS.aErrorClass[2,2] = "index"
		   THIS.aErrorClass[2,1] = "/5/19/20/114/1103/1141/1707/"
		   THIS.aErrorClass[3,2] = "disk"
		   THIS.aErrorClass[3,1] = "/56/1410/1157/"
		   THIS.aErrorClass[4,2] = "file"
		   THIS.aErrorClass[4,1] = "/1/6/7/15/41/50/54/55/102/110/111/115/116/117/119/120"+;
		                           "/121/127/202/255/266/297/356/392/1102/1104/1105/1108"+;
		                           "/1111/1112/1113/1115/1126/1166/1131/1167/1168/1169"+;
		                           "/1243/1245/1246/1294/1298/1509/1510/1637/1643"+;
		                           "/1644/1705/1708/"
		   THIS.aErrorClass[5,2] = "command"                 
		   THIS.aErrorClass[5,1] = "/1405/1411/1412/"
		   THIS.aErrorClass[6,2] = "lock"
		   THIS.aErrorClass[6,1] = "/3/108/109/130/1502/1503/1106/1585/"
		   THIS.aErrorClass[7,2] = "output"
		   THIS.aErrorClass[7,1] = "/216/221/222/223/227/228/332/1002/1153/"              
		   THIS.aErrorClass[8,2] = "program or resource file"
		   THIS.aErrorClass[8,1] = "/67/91/1161/1178/1193/1194/1195/1196/1296/1309/1338/"
		   THIS.aErrorClass[9,2] = "print"
		   THIS.aErrorClass[9,1] = "/124/125/1910/1524/1643/1644/1717/"
		   THIS.aErrorClass[10,2] = "activex"
		   THIS.aErrorClass[10,1] = "/1420/1421/1422/1423/1424/1426/1427/1428/1429/1431/1434/1436/1508"+;
		                            "/1440/2003/1782/2021/"
		   THIS.aErrorClass[11,2] = "sql"
		   THIS.aErrorClass[11,1] = "/1465/1466/1471/1472/1474/1475/1476/1477/1864/1865/1802/1890/1845/"
		   THIS.aErrorClass[12,2] = "cursor"
		   THIS.aErrorClass[12,1] = "/1467/1468/1473/1478/1479/1489/1491/1492/1493/1494/1495/1498/1499/1542/1546/1547/1548/1568/"
		   THIS.aErrorClass[13,2] = "odbc"
		   THIS.aErrorClass[13,1] = "/1480/1481/1482/1483/1484/1485/1486/1487/1496/1497/1522/1523/1525/1526/1527/1528/1530/"
		   THIS.aErrorClass[14,2] = "relational integrity"
		   THIS.aErrorClass[14,1] = "/1539/1555/1567/1879/1881/1882/1883/1884/1886/1887/"
		   THIS.aErrorClass[15,2] = "datasession"
		   THIS.aErrorClass[15,1] = "/1540/1545/1549/"
		   THIS.aErrorClass[16,2] = "offline views"
		   THIS.aErrorClass[16,1] = "/2007/2008/2010/2011/2015/2018/"
		*   THIS.aErrorClass[17,2] = "database"
		*   THIS.aErrorClass[17,1] = "/1529/1531/1534/1535/1536/1537/1538/1541/1542/1550/1551/1552/1553/1557/1558/1561/1562/1563/1564/1565/1566/1569/1570/"
		   
		ENDIF
		
		RETURN (NOT llBail)
	ENDPROC

	PROCEDURE filllogrecord		&& Writes error information to the log.
		INSERT INTO (THIS.cLogAlias) ("Errstamp") VALUES (DATETIME())
		
		LOCAL lcErrData, liErrLevel, liSelect, liSession, liFormSession
		
		liSelect = SELECT()
		liSession = SET("DATASESSION")
		
		SELECT (THIS.cLogAlias)
		
		* create listing memo field from chunks of data --
		* do a couple of REPLACEs so that less memory is
		* used for each step of this process
		
		lcErrData = "Error # "+TRANSFORM(THIS.iCurrentError)
		IF NOT EMPTY(THIS.cCurrentClass)
		   lcErrData = lcErrData+ " class: "+THIS.cCurrentClass
		ENDIF   
		lcErrData = lcErrData+CHR(13)+"Program "+ THIS.cCurrentMethod
		lcErrData = lcErrData+CHR(13)+"Message "+ THIS.cCurrentMessage
		IF NOT EMPTY(THIS.cCurrentErrorParam)
		   lcErrData = lcErrData+ " (" +THIS.cCurrentErrorParam+")"
		ENDIF   
		lcErrData = lcErrData+CHR(13)+"Line #  "+TRANSFORM(THIS.iCurrentLine)
		
		liFormSession = liSession
		
		IF TYPE("_SCREEN.ActiveForm") = "O"
		   lcErrData = lcErrData+CHR(13)+"Active: "+_SCREEN.ActiveForm.Name
		   IF TYPE("_SCREEN.ActiveForm.ActiveControl") = "O"
		      lcErrData = lcErrData+ " ("+_SCREEN.ActiveForm.ActiveControl.Name+")"
		   ENDIF
		   DO CASE
		   CASE TYPE("_SCREEN.ActiveForm.DataSessionID") = "N"
		      liFormSession = _SCREEN.ActiveForm.DataSessionID
		   CASE TYPE("_SCREEN.ActiveForm.Parent.DataSessionID") = "N"
		      * formset
		      liFormSession = _SCREEN.ActiveForm.Parent.DataSessionID
		   OTHERWISE
		      * can be a defined window or modi memo or whatever
		   ENDCASE
		ENDIF   
		
		lcErrData = lcErrData+CHR(13)+"Session "+TRANSFORM(liFormSession)
		REPLACE listing WITH lcErrData ADDITIVE                           
		
		lcErrData =           CHR(13)+"DiskSpc "+TRANSFORM(DISKSPACE())
		lcErrData = lcErrData+CHR(13)+"Screen  "+TRANSFORM(SYSMETRIC(2))+" by "+TRANSFORM(SYSMETRIC(1))
		lcErrData = lcErrData+CHR(13)+"OS      "+OS()
		lcErrData = lcErrData+CHR(13)+"Vers(1) "+VERSION(1)
		lcErrData = lcErrData+CHR(13)+"Vers(2) "+TRANSFORM(VERSION(2))
		lcErrData = lcErrData+CHR(13)+"Vers(3) "+VERSION(3)
		lcErrData = lcErrData+CHR(13)+"SMode   "+TRANSFORM(_VFP.StartMode)
		lcErrData = lcErrData+CHR(13)+"(1016)  "+TRANSFORM(VAL(SYS(1016))/1024)+" user object memory used"
		lcErrData = lcErrData+CHR(13)+"(1001)  "+TRANSFORM(VAL(SYS(1001))/1024)+" pool available memory"
		lcErrData = lcErrData+CHR(13)+"CPU     "+ SYS(17)
		lcErrData = lcErrData+CHR(13)+"Video   "+SYS(2006)
		lcErrData = lcErrData+CHR(13)+CHR(13)+REPLICATE("=",50)
		lcErrData = lcErrData+CHR(13)+"            Calling Chain:"
		
		REPLACE listing WITH lcErrData ADDITIVE                              
		
		liErrLevel = 1
		lcErrData = CHR(13)
		DO WHILE NOT EMPTY(SYS(16,liErrLevel)) AND NOT SYS(16,liErrLevel) == PROGRAM()
		   lcErrData = lcErrData + CHR(13)+SYS(16,liErrLevel)
		   liErrLevel= liErrLevel+1
		ENDDO
		
		lcErrData = lcErrData+CHR(13)+REPLICATE("=",50)
		lcErrData = lcErrData+CHR(13)+CHR(13)+REPLICATE("=",50)
		lcErrData = lcErrData+CHR(13)+"            CONFIG file: "+SYS(2019)
		IF FILE(SYS(2019))
		   lcErrData = lcErrData + CHR(13)+REPLICATE("=",50)+CHR(13)
		   REPLACE listing WITH lcErrData ADDITIVE
		   APPEND MEMO listing FROM (SYS(2019)) && ADDITIVE by default
		ELSE
		   lcErrData = lcErrData + " NOT AVAILABLE"+CHR(13)+REPLICATE("=",50)+CHR(13)
		   REPLACE listing WITH lcErrData ADDITIVE
		ENDIF   
		
		lcErrData = CHR(13)+CHR(13)+REPLICATE("=",50)
		lcErrData = lcErrData+CHR(13)+"          Status listing of Current Data Session "
		lcErrData = lcErrData+CHR(13)+REPLICATE("=",50)+CHR(13)
		REPLACE listing WITH lcErrData ADDITIVE                           
		
		lcErrData = SYS(2023)+"\"+SYS(3)+".tmp"
		
		DO WHILE FILE(lcErrData)
		   lcErrData = SYS(2023)+"\"+SYS(3)+".tmp"
		ENDDO   
		
		IF liSession = liFormSession
		   SELECT (liSelect)
		ELSE
		   SET DATASESSION TO (liFormSession)
		ENDIF      
		LIST STATUS TO (lcErrData) NOCONSOLE
		
		IF liSession = liFormSession
		   SELECT (THIS.cLogAlias)
		ELSE
		   SET DATASESSION TO (liSession)
		ENDIF
		      
		APPEND MEMO listing FROM (lcErrData) 
		
		ERASE (lcErrData)
		REPLACE listing WITH CHR(13)+REPLICATE("=",50)+CHR(13)+;
		                "            Memory listing"+CHR(13)+;
		                REPLICATE("=",50)+CHR(13) ;
		                ADDITIVE
		
		LIST MEMORY TO (lcErrData) NOCONSOLE
		APPEND MEMO listing FROM (lcErrData)  
		REPLACE listing WITH STRTRAN(listing, "_REFOX_", "G_SCREENDEFAULT") && Mask Refox Data in Log File!!
		REPLACE listing WITH STRTRAN(listing, "9876543210", "800600")
		
		ERASE (lcErrData)
		SELECT (liSelect)
		
		
		
	ENDPROC

	PROCEDURE geterrorattribute		&& Returns appropriate information from aErrorClass array for a given error number.
		LPARAMETER tiColumn, tvErrNo
		
		ASSERT EMPTY(tiColumn) OR ;
		       (VARTYPE(tiColumn) = "N" AND ;
		        BETWEEN(tiColumn,1,ALEN(THIS.aErrorClass,2)))
		
		ASSERT EMPTY(tvErrNo) OR INLIST(VARTYPE(tvErrNo),"N","C")
		
		LOCAL lcErrString, liColumn, liIndex, lvReturn, lcType
		
		DO CASE
		CASE EMPTY(tvErrNo)
		   lcErrString = "/"+TRANSFORM(THIS.iCurrentError)+"/"
		CASE VARTYPE(tvErrNo) = "N"
		   lcErrString = "/"+TRANSFORM(tvErrNo)+"/"
		OTHERWISE
		   lcErrString = "/"+ALLTR(tvErrNo)+"/"
		ENDCASE
		
		IF EMPTY(tiColumn)
		   * return the first column, error number string
		   liColumn = 1
		ELSE
		   liColumn = tiColumn
		ENDIF   
		
		lcType = VARTYPE(THIS.aErrorClass[1,liColumn])
		DO CASE
		CASE lcType = "C"
		   lvReturn = ""
		CASE INLIST(lcType,"N","I","Y")
		   lvReturn = NTOM(0)
		CASE INLIST(lcType,"D","T")
		   lvReturn = {}   
		CASE lcType = "O"
		   lvReturn = .NULL.   
		OTHERWISE
		   * lvReturn = .F.
		ENDCASE   
		
		FOR liIndex = 1 TO ALEN(THIS.aErrorClass,1)
		   IF lcErrString $ THIS.aErrorClass[liIndex,1]
		      lvReturn = THIS.aErrorClass[liIndex,liColumn]
		      EXIT
		   ENDIF  
		ENDFOR    
		
		RETURN lvReturn
		
		
		
	ENDPROC

	PROCEDURE getmessageboxtitle		&& This is really meant for your subclass or instance to fill out with app-specific information, so that all user feedback (WAIT WINDOW NOWAITs and MESSAGEBOX()) by the error object matches your app properly.
		RETURN ERROR_MESSAGEBOX_TITLE_LOC
	ENDPROC

	PROCEDURE handle		&& Main routine to handle error.
		LPARAMETERS tiError, tcMethod, tiLine, tiMessage
		
		******
		* PARAMETER p_Error, p_Message, p_Procedure, p_Line, p_Code
		p_Error = tiError
		p_Procedure = tcMethod
		p_Line = tiLine
		p_Message = tiMessage
		 PUBLIC glPrgerror
		 PRIVATE lgEnerror
		 PRIVATE ccAllstack, nsTackcount
		 PRIVATE ALL LIKE l_*
		 PRIVATE cmAcro
		 glPrgerror = .F.
		 lgEnerror = .F.
		 lsYserror = .F.
		 l_Handle = -1
		* WAIT WINDOW " TEST TEST TEST " + STR(p_Error)
		 DO CASE
		      CASE p_Error==17
		           lsYserror = .F.
		      CASE p_Error==1 .OR. p_Error==1162
		           = alErt(p_Message,"ERROR")
		           glPrgerror = .T.
		      CASE p_Error==5
		      CASE p_Error==38
		      CASE p_Error==4
		      CASE p_Error==1108
		      CASE p_Error==2034
		      	DO whatread      
		      CASE p_Error==30
		      CASE p_Error==56
		           = alErt(p_Message,"ERROR")
		      CASE p_Error==1644 .OR. p_Error==125
		           = alErt(p_Message,"ERROR")
		           lsYserror = .T.
		      CASE p_Error==3 .OR. p_Error==1705
		           		lnEterror = .T.
		      CASE p_Error==1405
		           = alErt(GetLangText("ERRORSYS","TXT_RUN_FAILED"),GetLangText("ERRORSYS", ;
		             "TXT_ERROR_MESSAGE"))
		           lsYserror = .T.
		      CASE p_Error==1249
		           CLEAR READ
		           WAIT WINDOW TIMEOUT 0.1 GetLangText("ERRORSYS","TA_CLOSEWINS")+"!"
		           lsYserror = .T.
		      CASE p_Procedure=="PRTREPORT"
		           l_Errormessage = "Error "+LTRIM(STR(p_Error))+" in "+ ;
		                            p_Procedure+"("+LTRIM(STR(p_Line))+")"
		           nsElected = seLectmessage("SQL definition Error",GetLangText("COMMON", ;
		                       "TXT_OK")+";"+GetLangText("ERRORSYS","TXT_INFO"), ;
		                       GetLangText("ERRORSYS","TXT_WRITE_DOWN_THIS_MESSAGE")+";"+ ;
		                       l_Errormessage,"bitmap\Stop.Ico")
		           l_Errormessage = "Error:"+LTRIM(STR(p_Error))+";"+"Message:"+ ;
		                            p_Message+";"+"Procedure:"+p_Procedure+";"+ ;
		                            "Line:"+LTRIM(STR(p_Line))+";"+"Code:"+p_Code
		           IF (nsElected==2)
		                IF (seLectmessage("SQL definition Error Detail", ;
		                   GetLangText("COMMON","TXT_OK")+";"+GetLangText("ERRORSYS", ;
		                   "TXT_INFO"),l_Errormessage,"bitmap\Info.Ico")==2)
		                     = alErt(csQlstatement,"Executing SQL statement")
		                ENDIF
		           ENDIF
		           lsYserror = .T.
		      CASE p_Error==1707
		           RETRY
		      CASE p_Error==12
		           IF ("Variable 'TXT_"=SUBSTR(p_Message, 1, 14))
		                cmAcro = SUBSTR(p_Message, 11, AT("'", p_Message, 2)-12)
		                WAIT WINDOW NOWAIT "Missing Text:"+cmAcro
		                &cMacro   = cMacro
		                lsYserror = .T.
		           ELSE
		                lgEnerror = .T.
		           ENDIF
		      case p_error==1104 OR p_error==1103
		    		messagebox("Network resource is not available")
		      case p_error==108
		    		MESSAGEBOX(GetLangText("COMMON","T_FILE_IS LOCKED"),48,GetLangText("RECURRES","TXT_INFORMATION"))
		    	case p_error==109 OR p_error==109
		    		MESSAGEBOX(GetLangText("COMMON","T_RECORD_IS LOCKED"),48,GetLangText("RECURRES","TXT_INFORMATION"))
		      OTHERWISE
		           lgEnerror = .T.
		 ENDCASE
		 IF !lgEnerror
		 	RETURN
		 ENDIF
		*      IF (TYPE('glInReport')='L' .AND. glInreport)
		 *          glErrorinreport = .T.
		  *    ELSE
		*           CLEAR READ
		 *          nsTackcount = 1
		  *         ccAllstack = ""
		*           DO WHILE PROGRAM(nsTackcount)<>p_Procedure
		 *               ccAllstack = ccAllstack+PROGRAM(nsTackcount)+" "
		  *              nsTackcount = nsTackcount+1
		   *        ENDDO
		    *       l_Errormessage = "Error: "+LTRIM(STR(p_Error))+CHR(10)+ ;
		     *                       "Message: "+p_Message+CHR(10)+"Procedure: "+ ;
		      *                      p_Procedure+CHR(10)+"Called from: "+ ;
		       *                     ccAllstack+CHR(10)+"Line: "+ ;
		        *                    LTRIM(STR(p_Line))+CHR(10)+"Code: "+p_Code
		         *  = msGbox(l_Errormessage,"Brilliant",016)
		          * = erRormsg(l_Errormessage,.T.)
		           
		          * = checkwin("login",".t.")
		*      ENDIF
		* ENDIF
		* RETURN
		*ENDPROC
		*
		
		******
		
		
		
		THIS.cCurrentMessage = MESSAGE()
		THIS.cCurrentErrorParam = SYS(2018)
		THIS.iCurrentError = IIF(VARTYPE(tiError) # "N",0,tiError)
		THIS.cCurrentMethod = TRANSFORM(tcMethod)
		THIS.iCurrentLine = IIF(VARTYPE(tiLine) # "N",0,tiLine)
		THIS.cCurrentClass = ""
		THIS.lUserCancelled = .F. && it's possible
		                          && for an outside program to ignore a previous CANCEL instruction
		
		THIS.FillArrays()
		
		* note: FillArrays() does an early bail for memory 
		* errors,which will be messaged by THIS.IsFatal() below
		
		* see FillArrays() for structure
		* of aErrorClass array --
		* GetErrorAttribute
		* gets a particular element by looking
		* up error numbers in the first array column and specifying 
		* what column of the array is needed. This column
		* is passed as GetErrorAttribute's first parameter
		* (you can also pass a second parameter containing
		* a particular error number to look up -- this defaults
		* to the iCurrentError contents)
		THIS.cCurrentClass = THIS.GetErrorAttribute(2)
		* for example,
		* THIS.cCurrentLevel = THIS.GetErrorAttribute(3)
		* for a property that used a third column of
		* the array to store some error severity classification system
		
		IF NOT (THIS.IsDisallowedServerAction(.T.) OR ;
		        THIS.IsFatal(.T.) OR ;
		        THIS.IsTrivial(.T.))
		    
		   IF THIS.OKToReport() 
		
		      THIS.LogErrorReport()
		                
		   ENDIF    
		
		   IF THIS.OKToContinue() 
		
		      THIS.UserHandlesError()
		   ENDIF      
		
		      
		ENDIF
		IF this.lusercancelled
		*	SET STEP ON
			ON ERROR
		*	ON SHUTDOWn
		*	CANCEL
		*	WAIT WINDOW "QUIT" TIMEOUT 5
		*	ON SHUTDOWn checkwin("cleanup",.t.)
		*	QUIt
		*	RELEASE oerror
		*	QUIT
		ENDIF
		
	ENDPROC

	PROCEDURE isdisallowedserveraction		&& Tells whether the error is caused by an attempt to execute UI or other disallowed action from a server
		LPARAMETERS tlWantRecord
		LOCAL llDisallowedServerAction
		IF THIS.lServer AND ;
		   (THIS.iCurrentError = 2031 OR ;
		    (THIS.iCurrentError = 1001 AND ;
		     _VFP.Startmode = 5) )
		   llDisallowedServerAction = .T.
		   IF tlWantRecord
		      THIS.RecordServerError(;
		         THIS.cCurrentMessage+CHR(13)+;
		         THIS.cCurrentErrorParam+CHR(13)+;
		         TRANS(THIS.iCurrentError)+CHR(13)+;
		         THIS.cCurrentMethod+CHR(13)+;
		         TRANS(THIS.iCurrentLine))
		   ENDIF
		ENDIF   
		RETURN llDisallowedServerAction
	ENDPROC

	PROCEDURE isfatal		&& Whether error is a fatal type error.
		LPARAMETERS tlWantDialog
		
		LOCAL llIsFatal, lcMessage
		lcMessage = ""
		
		llIsFatal = INLIST("/"+THIS.cCurrentClass+"/", ;
		                   "/memory/", ;
		                   "/disk/", ;
		                   "/program or resource file/" )
		
		
		IF llIsFatal AND tlWantDialog
		   lcMessage =    ERROR_SERIOUS_CLASS_LOC + ":  " + UPPER(THIS.cCurrentClass) + CHR(13) +;
		                  ERROR_CANNOT_BE_LOGGED_LOC + CHR(13)+ ;
		                  CHR(13)+CHR(13)+;
		                  SYS(16,0)+ ;
		                  CHR(13)+ CHR(13)+ ;
		                  "#"+TRANSFORM(THIS.iCurrentError)+" "+ ; 
		                  THIS.cCurrentMethod+", "+TRANSFORM(THIS.iCurrentLine) + ;
		                  CHR(13)+CHR(13)+ ;
		                  ["]+THIS.cCurrentMessage+["]
		
		   IF THIS.lServer
		   
		      THIS.RecordServerError(lcMessage)
		      
		   ELSE
		      =MESSAGEBOX(lcMessage+CHR(13)+CHR(13)+ ;
		                   ERROR_USER_NOTE_LOC, ;
		                   MB_ICONSTOP, ;
		                   THIS.GetMessageBoxTitle())
		   ENDIF
		                  
		   
		ENDIF
		
		RETURN llIsFatal
	ENDPROC

	PROCEDURE isgooderrorlog		&& Validates error log
		LPARAMETERS tcAlias
		ASSERT USED(tcAlias)
		
		LOCAL ARRAY aTemp[1]
		
		=AFIELDS(aTemp,tcAlias)
		
		RETURN UPPER(aTemp(1,1))== "ERRSTAMP"  AND ;
		       UPPER(aTemp(2,1))== "LISTING"   AND ;
		       UPPER(aTemp(3,1))== "USERNOTES" AND ;
		       aTemp(1,2)+aTemp(2,2)+aTemp(3,2)=="TMM"
		   
	ENDPROC

	PROCEDURE istrivial		&& Whether error is a trivial type error.
		LPARAMETERS tlWantDialog
		
		LOCAL llIsTrivial, lcMessage
		lcMessage = ""
		llIsTrivial = INLIST("/"+THIS.cCurrentClass+"/", ;
		                     "/print/", ;
		                     "/lock/")
		
		IF llIsTrivial AND tlWantDialog 
		   * messageboxes
		
		   DO CASE
		   CASE THIS.cCurrentClass == "print" 
		
		      lcMessage = ERROR_PRINT_LOC + ":"+ ;
		                  CHR(13)+CHR(13)+;
		                  ["]+THIS.cCurrentMessage+["]
		                  
		        
		   CASE THIS.cCurrentClass == "lock"
		     * should not happen unless SET REPROCESS
		     * is not properly set
		      lcMessage = ERROR_LOCK_LOC + ":"+ ;
		                  CHR(13)+CHR(13)+;
		                  THIS.cCurrentMessage
		
		   ENDCASE
		
		   IF NOT THIS.lServer
		
		      =MESSAGEBOX(lcMessage+CHR(13)+CHR(13)+ ;
		                   ERROR_USER_FIX_LOC,;
		                   MB_ICONEXCLAMATION, ;
		                   THIS.GetMessageBoxTitle())
		   ENDIF
		
		ENDIF
		
		RETURN llIsTrivial   
	ENDPROC

	PROCEDURE logerrorreport		&& If lServer is .T. or user indicates logging is desired, opens error log and logs the error.
		LOCAL lcMessage
		
		lcMessage = ["]+THIS.cCurrentMessage +["] + CHR(13)+CHR(13)+ ;
		            "("+TRANSFORM(THIS.iCurrentError)+")"+ ;
		            IIF(EMPTY(THIS.cCurrentErrorParam),"",;
		                " ("+THIS.cCurrentErrorParam+")" )+CHR(13)+ ;
		            THIS.cCurrentMethod+", "+TRANSFORM(THIS.iCurrentLine)+ CHR(13)+;
		            SYS(16,0)
		
		*!*	IF THIS.lServer OR ;
		*!*	   MESSAGEBOX(ERROR_OCCURRED_LOC+":"+CHR(13)+CHR(13)+;
		*!*	              lcMessage+ CHR(13)+CHR(13)+ ;
		*!*	              ERROR_LOG_LOC, ;
		*!*	              MB_ICONSTOP+MB_YESNO, ;
		*!*	              THIS.GetMessageBoxTitle()) ;
		*!*	              = IDYES
		
		*!*	  IF NOT THIS.lServer
		*!*	     WAIT WINDOW NOWAIT LEFTC(lcMessage,254)
		*!*	  ENDIF
		*!*	  THIS.SetLog()
		*!*	  THIS.FillLogRecord()
		*!*	  WAIT CLEAR
		*!*	  
		*!*	ENDIF
		
		THIS.SetLog()
		THIS.FillLogRecord()
		
	ENDPROC

	PROCEDURE oktocontinue		&& Abstract  method to evaluate error whether to continue program execution.
		* abstract in the base
	ENDPROC

	PROCEDURE oktoreport		&& Abstract method to evaluate error whether to report error.
		* abstract in the base
	ENDPROC

	PROCEDURE recordservererror		&& Establishes a consistent method for logging feedback which would ordinarily go to UI, for use in servers
		LPARAMETERS tcMessage
		LOCAL lcMessage
		lcMessage = TRANSFORM(tcMessage)
		THIS.SetLog()
		INSERT INTO (THIS.cLogAlias) ("Errstamp") VALUES (DATETIME())
		REPLACE Listing WITH lcMessage IN (THIS.cLogAlias)
		
	ENDPROC

	PROCEDURE setlog		&& Evaluates log table name and alias, attempts to open and validate the table, creates new alias and log table name on the fly if anything goes wrong.
		LPARAMETERS tcTableName, tcAlias
		
		IF (NOT EMPTY(THIS.cLogAlias)) AND ;
		   USED(THIS.cLogAlias) AND ;
		   THIS.IsGoodErrorLog(THIS.cLogAlias)
		   RETURN .T.
		ENDIF   
		
		LOCAL lcAlias, lcTableName, liSelect
		
		
		IF VARTYPE(tcAlias) = "C" AND NOT EMPTY(tcAlias)
		   lcAlias = ALLTR(tcAlias)
		   IF USED(lcAlias) AND THIS.IsGoodErrorLog(lcAlias)
		      THIS.cLogAlias = lcAlias
		   ENDIF
		ENDIF
		
		IF EMPTY(THIS.cLogAlias)
		   lcAlias = "E"+SYS(2015)
		   DO WHILE USED(lcAlias)
		      lcAlias = "E"+SYS(2015)
		   ENDDO
		   THIS.cLogAlias = lcAlias
		ENDIF
		
		* now for the table name:
		IF USED(THIS.cLogAlias)
		
		   lcTableName = DBF(lcAlias)
		
		ELSE
		
		   DO CASE
		   CASE VARTYPE(tcTableName) = "C" AND NOT EMPTY(tcTableName)
		      lcTableName  = ALLTR(tcTableName)
		   CASE NOT EMPTY(THIS.cLogDBF)
		      lcTableName =  ALLTR(THIS.cLogDBF)
		   OTHERWISE
		      lcTableName = "errorlog.dbf"
		   ENDCASE
		   IF AT(".",lcTableName) = 0
		      lcTableName = lcTableName+".dbf"
		   ENDIF
		   
		ENDIF
		
		THIS.cLogDBF = LOWER(FULLPATH(IIF(EMPTY(this.cdatadir),"",ADDBS(this.cdatadir))+lcTableName))
		
		IF NOT USED(THIS.cLogAlias)
		
		   IF NOT EMPTY(SYS(2000,THIS.cLogDBF))
		       USE (THIS.cLogDBF) AGAIN SHARED ALIAS (THIS.cLogAlias) IN 0
		       IF EMPTY(THIS.cLogDBF) ; 
		          OR NOT THIS.IsGoodErrorLog(THIS.cLogAlias)
		          IF USED(THIS.cLogAlias)
		             USE IN (THIS.cLogAlias)
		          ENDIF
		          * recursive call with new, temporary filename:
		          THIS.SetLog(FULLPATH(THIS.cLogAlias), THIS.cLogAlias)
		       ENDIF
		   ELSE
		      liSelect = SELECT()
		      SELE 0
		* v-darylm
		      CREATE TABLE (THIS.cLogDBF) FREE ;
		                   (errstamp    t, ;
		                    listing    m,;
		                    usernotes m, ;
		                    issend l)                       
		*!*	      CREATE TABLE (THIS.cLogDBF) ;
		*!*	                   (errstamp    t, ;
		*!*	                    listing    m,;
		*!*	                    usernotes m)                       
		      USE (THIS.cLogDBF) AGAIN SHARED ALIAS (THIS.cLogAlias)
		      SELECT (liSelect)
		   ENDIF
		ENDIF
		   
		RETURN   
	ENDPROC

	PROCEDURE usercancelled		&& Returns whether user opted to cancel after the current error.
		RETURN THIS.lUserCancelled
	ENDPROC

	PROCEDURE userhandleserror		&& Gives user choices about whether to go on with the app after an error.
		RETURN
		
		LOCAL liContinue
		
		   liContinue = MESSAGEBOX( ERROR_USEREND_LOC, 48 , THIS.GetMessageBoxTitle())
		RETURN
		
		DO CASE
		
		CASE THIS.lServer
		   liContinue = IDYES  
		CASE VERSION(2) = 0
		   liContinue = MESSAGEBOX( ERROR_USEREND_LOC,;
		                            MB_ICONEXCLAMATION+MB_OKCANCEL, ;
		                            THIS.GetMessageBoxTitle())
		
		OTHERWISE
		   liContinue = MESSAGEBOX(ERROR_DEVEND_LOC, ;
		                          MB_ICONEXCLAMATION+MB_YESNOCANCEL, ;
		                          THIS.GetMessageBoxTitle())
		ENDCASE
		
		
		DO CASE
		
		CASE INLIST(liContinue,IDYES, IDOK)
		   RETURN
		
		CASE liContinue = IDNO
		*   DEBUG
		   SUSPEND
		*	CANCEL
		*	WAIT WINDOW "QUIT" TIMEOUT 5
		*	ON SHUTDOWn checkwin("cleanup",.t.)
		*	QUIT
		*	checkwin("cleanup",.t.)
		*	=cleanup()
		OTHERWISE 
		
		  THIS.lUserCancelled = .T.
		*  checkwin("cleanup",.t.)
		  * at this point in an object method, a CANCEL may be
		  * the same as a RETURN. The owning object
		  * has to decide what to do. If you do a CANCEL
		  * here it will have the effect of making it
		  * difficult for the container to RELEASE properly.
		  * This is especially a problem if the error
		  * has been invoked by the ON ERROR handler, because
		  * the ON... interrupt can take you back to anywhere.
		   
		ENDCASE
		
		
		
	ENDPROC

ENDDEFINE

DEFINE CLASS cbobrwmulselect AS combobox 
 	*< CLASSDATA: Baseclass="combobox" Timestamp="" Scale="Pixels" Uniqueid="" />

	BorderStyle = 0
	Height = 21
	Name = "cbobrwmulselect"
	Style = 2
	Width = 100

ENDDEFINE

DEFINE CLASS cntbase AS container 
 	*< CLASSDATA: Baseclass="container" Timestamp="" Scale="Pixels" Uniqueid="" />

	*<DefinedPropArrayMethod>
		*m: resizeobjects
		*m: resizetdatectrl
		*m: resizetselectctrl
		*p: f
		*p: h
		*p: l
		*p: sh
		*p: sw
		*p: t
		*p: w
	*</DefinedPropArrayMethod>

	h = 0
	Height = 200
	l = 0
	Name = "cntbase"
	sh = 0
	sw = 0
	t = 0
	w = 0
	Width = 200
	
	PROCEDURE Init
		this.w = this.Width
		this.h = this.Height
		this.l = this.Left
		this.t = this.Top
		this.f = 9
		
		RETURN .T.
	ENDPROC

	PROCEDURE Resize
		LOCAL loControl
		
		IF this.Height < 10
			RETURN .T.
		ENDIF
		this.sw = this.Width/This.w
		this.sh = this.Height/This.h
		
		FOR EACH loControl IN this.Controls FOXOBJECT
			this.resizeobjects(loControl)
		NEXT
		
		RETURN .T.
	ENDPROC

	PROCEDURE resizeobjects
		Parameters toControl
		* Warning!
		* Code is copied from tform class!!!!
		LOCAL j, loControl, llDontResize, lnOldScaleWidth, lnOldScaleHeight, lnOldWidth
		
		Do Case
			Case Upper(toControl.Class) = "TDATECTRL"
				this.resizetdatectrl(toControl)
			Case Upper(toControl.Class) = "TSELECTCTRL"
				this.resizetselectctrl(toControl)
			Case Upper(toControl.Class) = "TCOMMANDDROPDOWN"
				* Don't resize this control. TDateCtrl will do that job.
			Case Upper(toControl.Class) = "REVENUEPAGE"
				* Don't resize this control. It has own resize.
			Case Inlist(Upper(toControl.Name), "FOXCHARTS", "FOXCHARTSTOOLTIP")
				* Don't resize this control. Generated by FoxCharts.
			Case Inlist(Upper(toControl.BaseClass),"LABEL","TEXTBOX","CHECKBOX","EDITBOX","SPINNER")
				With toControl
					llDontResize = .F.
					TRY
						llDontResize = .ldontresize
					CATCH
					ENDTRY
					IF NOT llDontResize
						.Left=Round(.l*This.sw,0)
						.Width=Round(.w*This.sw,0)
						.Height=Round(.h*This.sh,0)
						.Top=Round(.T*This.sh,0)
					ENDIF
					IF .resizefontsize
						.FontSize=MIN(MAX(Round(.F*This.sh,0),thisform.nminfont),thisform.nmaxfont)
					ELSE
						*.FontSize=IIF(Max(Round(.F*This.sh,0),4)<.FontSize,Max(Round(.F*This.sh,0),4),MAX(.FontSize,9))
					ENDIF
				Endwith
			Case Upper(toControl.BaseClass) = "COMMANDBUTTON"
				With toControl
					IF NOT .lDontResize
						.Left=Round(.l*This.sw,0)
						.Width=Round(.w*This.sw,0)
						.Height=Round(.h*This.sh,0)
						.Top=Round(.T*This.sh,0)
					ENDIF
					IF .resizefontsize
						.FontSize=MIN(MAX(Round(.F*This.sh,0),thisform.nminfont),thisform.nmaxfont)
					ELSE
						.FontSize=IIF(Max(Round(.F*This.sh,0),4)<.FontSize,Max(Round(.F*This.sh,0),4),MAX(.FontSize,9))
					ENDIF
				Endwith
			Case Inlist(Upper(toControl.BaseClass),"COMBOBOX","LISTBOX")
				With toControl
					.Left=Round(.l*This.sw,0)
					.Width=Round(.w*This.sw,0)
					.Height=Round(.h*This.sh,0)
					.Top=Round(.T*This.sh,0)
					IF .resizefontsize
						.FontSize=MIN(MAX(Round(.F*This.sh,0),thisform.nminfont),thisform.nmaxfont)
					ELSE
						.FontSize=IIF(Max(Round(.F*This.sh,0),4)<.FontSize,Max(Round(.F*This.sh,0),4),MAX(.FontSize,9))
					ENDIF
					If .ColumnCount>0
						lccw=''
						For k=1 To Alen(.cw)
							lccw=lccw+Iif(k=Alen(.cw),Alltrim(Str(Round(.cw(k)*This.sw,0))),Alltrim(Str(Round(.cw(k)*This.sw,0)))+',')
						Next
						.ColumnWidths=lccw
					Endif
				Endwith
			Case Inlist(Upper(toControl.BaseClass),"OPTIONGROUP")
				With toControl
					.Width=Round(.w*This.sw,0)
					.Height=Round(.h*This.sh,0)
					.Left=Round(.l*This.sw,0)
					.Top=Round(.T*This.sh,0)
					For k=1 To MIN(.ButtonCount, Alen(.bw))
						.Buttons(k).Left=Round(.bl(k)*This.sw,0)
						.Buttons(k).Top=Round(.bT(k)*This.sh,0)
						.Buttons(k).Width=Round(.bw(k)*This.sw,0)
						.Buttons(k).Height=Round(.bh(k)*This.sh,0)
						.Buttons(k).FontSize=Max(Round(.bF(k)*This.sh,0),4)
					Next
				Endwith
			Case .f.&&Inlist(Upper(toControl.BaseClass),"CONTAINER")
				With toControl
					.Left=Round(.l*This.sw,0)
					.Width=Round(.w*This.sw,0)
					.Height=Round(.h*This.sh,0)
					.Top=Round(.T*This.sh,0)
					For j=1 To .ControlCount
						With .Controls(j)
							.Left=Round(.l*This.sw,0)
							.Width=Round(.w*This.sw,0)
							.Height=Round(.h*This.sh,0)
							.Top=Round(.T*This.sh,0)
							If Type('.fontsize')='N'
								.FontSize=MIN(MAX(Round(.F*This.sh,0),thisform.nminfont),thisform.nmaxfont)
							Endif
						Endwith
					Next
				Endwith
		
			Case Inlist(Upper(toControl.BaseClass),"LINE","SHAPE","IMAGE")
				With toControl
					.Left=Round(.l*This.sw,0)
					.Width=Round(.w*This.sw,0)
					.Height=Round(.h*This.sh,0)
					.Top=Round(.T*This.sh,0)
				Endw
			Case Inlist(Upper(toControl.BaseClass),"FORM")
				With toControl
					.FontSize=MIN(MAX(Round(.F*This.sh,0),thisform.nminfont),thisform.nmaxfont)
				Endwith
			Case Inlist(Upper(toControl.BaseClass),"GRID")
				With toControl
					.Left=Round(.l*This.sw,0)
					lnOldWidth = .Width
					.Width=MAX(19,Round(.w*This.sw,0))
					.Height=MAX(20,Round(.h*This.sh,0))
					.Top=Round(.T*This.sh,0)
					For k=1 To .ColumnCount
						IF .resizefontsize
							.Columns(k).FontSize=MIN(MAX(Round(.F*This.sh,0),thisform.nminfont),thisform.nmaxfont)
						ENDIF
						IF thisform.resizeheaderfont OR .resizeheaderfont
							FOR l=1 TO .columns(k).controlcount
								IF INLIST(UPPER(ALLTRIM(.columns(k).controls(l).baseclass)),'HEADER','TEXTBOX','COMBOBOX')
									IF .resizefontsize
										.columns(k).controls(l).FontSize=MIN(MAX(Round(.F*This.sh,0),thisform.nminfont),thisform.nmaxfont)
									ELSE
										.columns(k).controls(l).FontSize=;
										IIF(Max(Round(.F*This.sh,0),4)<.columns(k).controls(l).FontSize,Max(Round(.F*This.sh,0),4),MAX(.columns(k).controls(l).FontSize,9))
									ENDIF
								endif
							NEXT
						ELSE
							FOR l=1 TO .columns(k).controlcount
								IF INLIST(UPPER(ALLTRIM(.columns(k).controls(l).baseclass)),'TEXTBOX','COMBOBOX')
									IF .resizefontsize
										.columns(k).controls(l).FontSize=MIN(MAX(Round(.F*This.sh,0),thisform.nminfont),thisform.nmaxfont)
									ENDIF
								endif
							NEXT
						ENDIF
					Next
					IF .resizefontsize
						.RowHeight=Round(.rh*This.sh,0)
						.HeaderHeight=Round(.hh*This.sh,0)
					ENDIF
					If .lresizecolumns
						For k=1 To .ColumnCount
							.Columns(k).cw = IIF(ABS(.Columns(k).Width - .Columns(k).cw) > 1, .Columns(k).Width, .Columns(k).cw) * (.Width-17) / (lnOldWidth-17)
							.Columns(k).Width = ROUND(.Columns(k).cw,0)
						Next
					Endif
				Endwith
			Case Inlist(Upper(toControl.BaseClass),"PAGEFRAME")
				With toControl
					.Left=Round(.l*This.sw,0)
					.Width=Round(.w*This.sw,0)
					.Height=Round((.h-SYSMETRIC(9))*This.sh,0)+SYSMETRIC(9)
					.Top=Round(.T*This.sh,0)
					lnOldScaleWidth = this.sw
					lnOldScaleHeight = this.sh
					this.sw = .PageWidth / .pw
					this.sh = .PageHeight / .ph
					For j=1 To Alen(.pf)
						.Pages(j).FontSize=Max(Round(.pf(j)*This.sh,0),4)
						FOR EACH loControl IN .Pages(j).Controls FOXOBJECT
							this.resizeobjects(loControl)
						NEXT
					Next
					this.sw = lnOldScaleWidth
					this.sh = lnOldScaleHeight
				Endw
			Case Upper(toControl.BaseClass) = "OLEBOUNDCONTROL"
				With toControl
					.Left=Round(.l*This.sw,0)
					.Width=Round(.w*This.sw,0)
					.Height=Round(.h*This.sh,0)
					.Top=Round(.T*This.sh,0)
				ENDWITH
			Case Upper(toControl.BaseClass) = "OLECONTROL"	AND Upper(toControl.Class) = "TOLETREE"
				With toControl
					.Left=Round(.l*This.sw,0)
					.Width=Round(.w*This.sw,0)
					.Height=Round(.h*This.sh,0)
					.Top=Round(.T*This.sh,0)
				ENDWITH
		Endcase
		
	ENDPROC

	PROCEDURE resizetdatectrl
		LPARAMETERS lp_oObj
		With lp_oObj
			.Left=Round(.l*This.sw,0)
			.Width=Round(.w*This.sw,0)
			.Height=Round(.h*This.sh,0)
			.Top=Round(.T*This.sh,0)
			IF .resizefontsize
				.FontSize=Max(Round(.F*This.sh,0),4)
			ELSE
				.FontSize=IIF(Max(Round(.F*This.sh,0),4)<.FontSize,Max(Round(.F*This.sh,0),4),MAX(.FontSize,9))
			ENDIF
			.PositionButton()
		ENDWITH
	ENDPROC

	PROCEDURE resizetselectctrl
		LPARAMETERS lp_oObj
		With lp_oObj
			.Left=Round(.l*This.sw,0)
			.Width=Round(.w*This.sw,0)
			.Height=Round(.h*This.sh,0)
			.Top=Round(.T*This.sh,0)
			IF .resizefontsize
				.FontSize=Max(Round(.F*This.sh,0),4)
			ELSE
				.FontSize=IIF(Max(Round(.F*This.sh,0),4)<.FontSize,Max(Round(.F*This.sh,0),4),MAX(.FontSize,9))
			ENDIF
			.PositionButton()
		ENDWITH
	ENDPROC

ENDDEFINE

DEFINE CLASS datebox AS textbox 
 	*< CLASSDATA: Baseclass="textbox" Timestamp="" Scale="Pixels" Uniqueid="" />

	*<DefinedPropArrayMethod>
		*p: f
		*p: h
		*p: l
		*p: myalias		&& In wich alias name should Date be entered
		*p: resizefontsize
		*p: t
		*p: tablesource
		*p: variablesource
		*p: w
	*</DefinedPropArrayMethod>

	Height = 23
	Name = "datebox"
	resizefontsize = .T.
	tablesource = .T.
	Width = 100
	
	PROCEDURE Init
		this.w=this.width
		this.h=this.height
		this.f=this.fontsize
		this.t=this.top
		this.l=this.left
		this.ToolTipText=getlangtext("COMMON","TT_PRESS_CTRL_L")
	ENDPROC

	PROCEDURE KeyPress
		Lparameters nKeyCode, nShiftAltCtrl
		If ((nKeyCode = 12) And (nShiftAltCtrl = 2)) AND ocalendar
		*IF NKEYCODE=76
			oCalForm = CREATEOBJECT('formcalendarnew')
			oCalForm.Newobject("oleCalendar","_olecalendar","libs\_datetime")
			oCalForm.myalias = this.myalias
			With oCalForm.oleCalendar
				.date_column = this.controlsource
				.showtoday=.t.
				.tablesource=this.tablesource
				.variablesource=this.variablesource
				.RefreshDisplay()
				.BackColor = Thisform.BackColor
				.Visible = .T.
			ENDWITH
			xx_=this.ControlSource
			With oCalForm
				IF EMPTY(&xx_)
					.dat=DATE()
				else
					.dat=&xx_
				ENDIF
				.AutoCenter = .T.
				.BorderStyle = 2
				.MaxButton = .F.
				.MinButton = .F.
				.Height = oCalForm.oleCalendar.Height+30
				.Width = oCalForm.oleCalendar.Width
				.Caption = 'Pick up date'
			Endwith
			Thisform.Refresh
			oCalForm.oleCalendar.RefreshDisplay()
			oCalForm.Show(1)
		*	Thisform.Refresh
		Endif
		
	ENDPROC

ENDDEFINE

DEFINE CLASS formsetkontrole AS commandbutton 
 	*< CLASSDATA: Baseclass="commandbutton" Timestamp="" Scale="Pixels" Uniqueid="" />

	Caption = "FS kontrole"
	Height = 27
	Name = "formsetkontrole"
	Width = 84
	
	PROCEDURE Click
		If Used('controls')
			Select Controls
			Use
		Endif
		Use data\Controls In 0 Exclusive
		Select Controls
		Zap
		la_prg_="PAYMETHODS"
		For a=1 To Thisformset.FormCount
			fname=thisformset.Forms(a).name
			Insert Into Controls (Control,la_label,la_prg) Values ('thisformset.'+fname+'.caption=getlangtext("'+la_prg_+'","CAPTION",g_lang)',"CAPTION",la_prg_)
			X_="FCONTROLCOUNT=THISFORMSET."+FNAME+".CONTROLCOUNT"
			&X_
			For i=1 To FCONTROLCOUNT
				X_="BASECLASS_=THISFORMSET."+FNAME+".Controls(i).BaseClass"
				&X_
				x_="controlname_=THISFORMSET."+FNAME+".Controls(i).name"
				&x_
				Do Case
				Case Inlist(Upper(BASECLASS_),"LABEL","CHECKBOX","COMMANDBUTTON")
					Insert Into Controls (Control,la_label,la_prg) Values ('thisformset.'+fname+'.'+controlname_+'.caption=getlangtext("'+la_prg_+'","'+controlname_+'",g_lang)',controlname_,la_prg_)
				Case Inlist(Upper(baseclass_),"PAGEFRAME")
					x_='pfcount=thisformset.'+fname+'.'+controlname_+'.pagecount'
					&x_
					x_='pfname=thisformset.'+fname+'.'+controlname_+'.name'
					&x_
					For k=1 To pfcount
						x_='pfpname=thisformset.'+fname+'.'+pfname+'.pages(k).name'
						&x_
						x_='pfpcc=thisformset.'+fname+'.'+pfname+'.'+pfpname+'.controlcount'
						&x_
						Insert Into Controls (Control,la_label,la_prg) Values ('thisformset.'+fname+'.'+pfname+'.'+pfpname+'.caption=getlangtext("'+la_prg_+'","'+PFPNAME+'",g_lang)',Upper(pfpname),la_prg_)
						For j=1 To pfpcc
							x_='pfpcbc=thisformset.'+fname+'.'+pfname+'.'+pfpname+'.Controls(j).baseclass'
							&x_
							x_='pfpcN=thisformset.'+fname+'.'+pfname+'.'+pfpname+'.Controls(j).NAME'
							&x_
							Do Case
							Case Inlist(Upper(pfpcbc),"LABEL","CHECKBOX","COMMANDBUTTON")
								Insert Into Controls (Control,la_label,la_prg) Values ('thisformset.'+fname+'.'+pfname+'.'+pfpname+'.'+pfpcn+'.caption=getlangtext("'+la_prg_+'","'+pfpcN+'",g_lang)',pfpcN,la_prg_)
							Endcase
						Next
					NEXT
				Case Inlist(Upper(baseclass_),"GRID")
					x_='columncount_=thisformset.'+fname+'.'+controlname_+'.columncount'
					&x_
					x_='gridname=thisformset.'+fname+'.'+controlname_+'.name'
					&x_
					For b=1 To columncount_
						x_='columnname_=thisformset.'+fname+'.'+gridname+'.columns(b).name'
						&x_
						x_='columncontrolcount_=thisformset.'+fname+'.'+gridname+'.'+columnname_+'.controlcount'
						&x_
						For c=1 To columncontrolcount_
							x_='columncontrolbaseclass=thisformset.'+fname+'.'+gridname+'.'+columnname_+'.Controls(c).baseclass'
							&x_
							x_='columncontrolname=thisformset.'+fname+'.'+gridname+'.'+columnname_+'.Controls(c).name'
							&x_
							Do Case
							Case Inlist(Upper(columncontrolbaseclass),"HEADER")
								Insert Into Controls (Control,la_label,la_prg) Values ('thisformset.'+fname+'.'+GRIDname+'.'+COLUMNname_+'.'+COLUMNCONTROLNAME+'.caption=getlangtext("'+la_prg_+'","'+COLUMNCONTROLNAME+'",g_lang)',COLUMNCONTROLNAME,la_prg_)
							Endcase
						Next
					Next
				Endcase
			Next
		Next
		Select Controls
		replace la_text WITH la_label all
		REPLACE LA_LANG WITH "EN" ALL
		Copy To kontrole.txt FIELDS CONTROL Type Sdf
		Messagebox("Gotovo")
		
	ENDPROC

ENDDEFINE

DEFINE CLASS fs AS formset 
 	*< CLASSDATA: Baseclass="formset" Timestamp="" Scale="" Uniqueid="" />

	*-- OBJECTDATA items order determines ZOrder / El orden de los items OBJECTDATA determina el ZOrder 
	*< OBJECTDATA: ObjPath="Tform12" UniqueID="" Timestamp="" />

	*<DefinedPropArrayMethod>
		*m: setcaption
		*m: setcontrolsource
	*</DefinedPropArrayMethod>

	Name = "fs"

	ADD OBJECT 'Tform12' AS tform WITH ;
		DoCreate = .T., ;
		Name = "Tform12", ;
		Visible = .F.
		*< END OBJECT: ClassLib="main.vcx" BaseClass="form" />
	
	PROCEDURE Init
		
		*FOR i=1 TO this.FormCount
		*	this.Forms(i).setformsize
		*NEXT
		
	ENDPROC

	PROCEDURE setcaption
	ENDPROC

	PROCEDURE setcontrolsource
	ENDPROC

ENDDEFINE

DEFINE CLASS grdbase AS tgrid OF "main.vcx" 
 	*< CLASSDATA: Baseclass="grid" Timestamp="" Scale="Pixels" Uniqueid="" />

	*<DefinedPropArrayMethod>
		*m: setordering
		*p: lcolumncountnocolumnsremove		&& When .T., dont let code to manualy add columns, in columncount_assign
		*p: lcolumnsort
		*p: p_basecolumncontrol		&& Specifies which control should be automaticly added to grid columns, when columncount property is changed
		*p: p_basecolumncontrolname
		*p: p_showselectedrowinblue		&& .T. when selected row in grid shuld be shows in blue color
	*</DefinedPropArrayMethod>

	Name = "grdbase"
	p_basecolumncontrol = ttext		&& Specifies which control should be automaticly added to grid columns, when columncount property is changed
	p_basecolumncontrolname = txtGrid
	
	PROCEDURE columncount_assign
		LPARAMETERS tnNewVal
		LOCAL i, lnOldColumnCount, lcColumnName
		
		lcColumnName = this.p_BaseColumnControlName
		lnOldColumnCount = this.ColumnCount
		this.ColumnCount = tnNewVal
		
		IF tnNewVal > MAX(0,lnOldColumnCount) AND NOT this.lColumnCountNoColumnsRemove
			FOR i = MAX(lnOldColumnCount+1, 1) TO this.ColumnCount
				this.Columns(i).AddObject(lcColumnName, this.p_BaseColumnControl)
				this.Columns(i).CurrentControl = lcColumnName
				this.Columns(i).RemoveObject("Text1")
				this.Columns(i).&lcColumnName..Visible = .T.
				this.Columns(i).AddProperty("cw", this.Columns(i).Width)
				this.Columns(i).AddProperty("cn", Alltrim(Upper(this.Columns(i).Name)))
				this.Columns(i).Movable = .F.
			ENDFOR
		ENDIF
		
		IF this.lColumnSort
			FOR i = 1 TO this.ColumnCount
				IF NOT LOWER(this.Columns(i).Header1.Class) == "theader"
					this.Columns(i).RemoveObject("Header1")
					this.Columns(i).AddObject("Header1", "THeader")
					this.Columns(i).AddProperty("cSortOrder", "")
				ENDIF
			ENDFOR
		ENDIF
		
		RETURN .T.
	ENDPROC

	PROCEDURE setordering
		LPARAMETERS lp_cSortOrder, lp_lAskOrder
		LOCAL l_cRecordSource, l_nSelect, l_nRecNo, l_cDirection
		
		l_nSelect = SELECT()
		SELECT (this.RecordSource)
		l_nRecNo = RECNO()
		
		DO CASE
			CASE lp_lAskOrder
				l_cDirection = SortPopup(ICASE(NOT UPPER(ORDER()) == UPPER(lp_cSortOrder), 0, DESCENDING(), 2, 1))
			CASE UPPER(ORDER()) == UPPER(lp_cSortOrder) AND !DESCENDING()
				l_cDirection = "DESCENDING"
			OTHERWISE
				l_cDirection = "ASCENDING"
		ENDCASE
		SET ORDER TO lp_cSortOrder &l_cDirection
		LOCATE
		
		this.Refresh()
		GO l_nRecNo
		this.RefreshSortCursor()
		SELECT (l_nSelect)
		this.Refresh()
		
		RETURN .T.
	ENDPROC

ENDDEFINE

DEFINE CLASS grdbasecommon AS grdbasesort OF "main.vcx" 
 	*< CLASSDATA: Baseclass="grid" Timestamp="" Scale="Pixels" Uniqueid="" />

	*<DefinedPropArrayMethod>
		*m: afterrowcolchangeafter
	*</DefinedPropArrayMethod>

	DeleteMark = .F.
	lforcesortallowed = .T.
	lsetcursorsource = .T.
	Name = "grdbasecommon"
	resizefontsize = .F.
	ScrollBars = 2
	setcolumns = .T.
	
	PROCEDURE AfterRowColChange
		LPARAMETERS nColIndex
		this.AfterRowColChangeAfter()
	ENDPROC

	PROCEDURE afterrowcolchangeafter
	ENDPROC

ENDDEFINE

DEFINE CLASS grdbasesort AS grdbase OF "main.vcx" 
 	*< CLASSDATA: Baseclass="grid" Timestamp="" Scale="Pixels" Uniqueid="" />

	*<DefinedPropArrayMethod>
		*m: changeprop
		*m: cursoraddpage
		*m: cursorcreate
		*m: cursorcreatebefore		&& Here add code, which creates cursor, before recordsource is set
		*m: cursorrecordsource
		*m: cursorrequery		&& here add code, to refresh cursor
		*m: cursorrequerybefore		&& Here write code to get data into cursor
		*m: getrfctrl		&& Creates dummy textbox to remove focus from grid, when requery
		*m: getsortkey
		*m: resetgrid
		*m: setheadercaptions
		*m: setheadercaptionsbefore		&& Here define captions for column headers. This is done over collection.
		*p: ccurname		&& Name of cursor which is recordsource
		*p: ccursource		&& Name of cursor, from wich data are copied into recordsource cursor
		*p: cremovefocuscontrolname
		*p: jindexfile		&& Temp file for index when sorting on column
		*p: lforcesortallowed		&& When .T., allow always menu for sorting to pop up over column header
		*p: lsetcursorsource
		*p: npage
		*p: nrecordcount
		*p: ocaptions		&& Collection with captions for column headers
	*</DefinedPropArrayMethod>

	ccurname = 		&& Name of cursor which is recordsource
	ccursource = 		&& Name of cursor, from wich data are copied into recordsource cursor
	cremovefocuscontrolname = 
	jindexfile = 		&& Temp file for index when sorting on column
	lforcesortallowed = .F.		&& When .T., allow always menu for sorting to pop up over column header
	lsetcursorsource = .F.
	MemberClass = "grdbasesortcolumn"
	MemberClassLibrary = ..\commonclasses.prg
	Name = "grdbasesort"
	npage = 0
	nrecordcount = 0
	ocaptions = .NULL.		&& Collection with captions for column headers
	
	PROCEDURE changeprop
		LPARAMETERS tcProperty, toColumn
	ENDPROC

	PROCEDURE cursoraddpage
		this.Cursorrequery(.T.)
		
		RETURN
		
		LOCAL lnSelect, lnRecNo
		
		lnSelect = SELECT()
		
		SELECT (this.cCurName)
		lnRecNo = RECNO()
		ZAP
		APPEND FROM DBF(this.cCurSource)
		this.nRecordCount = RECCOUNT(this.cCurName)
		
		IF RECCOUNT(this.cCurName) < lnRecNo
			GO TOP IN (this.cCurName)
		ELSE
			GO lnRecNo IN (this.cCurName)
		ENDIF
		
		SELECT (lnSelect)
		
		RETURN .T.
	ENDPROC

	PROCEDURE cursorcreate
		this.ccurname = SYS(2015)
		this.ccursource = SYS(2015)
		
		this.CursorCreateBefore()
	ENDPROC

	PROCEDURE cursorcreatebefore		&& Here add code, which creates cursor, before recordsource is set
	ENDPROC

	PROCEDURE cursorrecordsource
		IF NOT this.lSetCursorSource
			RETURN .T.
		ENDIF
		
		LOCAL i, l_oCol, l_cField
		this.RecordSource = this.cCurName
		AFIELDS(l_aFields,this.cCurName)
		FOR i = 1 TO ALEN(l_aFields,1)
			l_oCol = .NULL.
			TRY
				l_oCol = EVALUATE("this.GrdBaseSortColumn"+TRANSFORM(i))
			CATCH
			ENDTRY
			IF VARTYPE(l_oCol)="O"
				l_cField = this.cCurName + "." + LOWER(l_aFields(i,1))
				l_oCol.ControlSource = l_cField
		
				IF this.lForceSortAllowed
					IF TYPE("l_oCol.lForceSortAllowed") = "L"
						l_oCol.lForceSortAllowed = .T.
					ENDIF
				ENDIF
			
			ENDIF
		ENDFOR
		
		RETURN .T.
	ENDPROC

	PROCEDURE cursorrequery		&& here add code, to refresh cursor
		LPARAMETERS lp_lNoRequery
		LOCAL lnSelect, lnRecNo, loColumns, lnDS
		lnDS = SET("Datasession")
		_screen.LockScreen = .T.
		IF SET("Datasession")<>lnDS
			* When MyDesk is active, that is, when internet explorer object is on desktop, 
			* and when LockScreen = .T. is issued, it can happen, that Datasession is changed.
			* I don't know why.
			SET DATASESSION TO lnDS
		ENDIF
		IF NOT lp_lNoRequery
			this.CursorRequeryBefore()
		ENDIF
		
		lnSelect = SELECT()
		
		SELECT (this.cCurName)
		lnRecNo = RECNO()
		ZAP
		IF CURSORGETPROP("Buffering",this.cCurSource) > 1
			INSERT INTO (this.cCurName) SELECT * FROM (this.cCurSource) WITH (Buffering = .T.)
		ELSE
			APPEND FROM DBF(this.cCurSource)
		ENDIF
		this.nRecordCount = RECCOUNT(this.cCurName)
		
		this.RecordSource = this.cCurName
		FOR EACH loColumns IN this.Columns
			loColumns.ControlSource = loColumns.cControlSourceCopy
		NEXT
		
		GO TOP IN (this.cCurName)
		this.Refresh()
		IF RECCOUNT(this.cCurName) >= lnRecNo
			GO lnRecNo IN (this.cCurName)
		ENDIF
		
		SELECT (lnSelect)
		_screen.LockScreen = .F.
		RETURN .T.
	ENDPROC

	PROCEDURE cursorrequerybefore		&& Here write code to get data into cursor
	ENDPROC

	PROCEDURE Destroy
		this.oCaptions = .NULL.
		dclose(this.cCurName)
		dclose(this.cCurSource)
		* Delete temp sort index file
		IF NOT EMPTY(this.RecordSource) AND USED(this.RecordSource)
			SELECT (this.RecordSource)
			SET INDEX TO
			= filedelete(this.jindexfile)
		ENDIF
		
		DODEFAULT()
		
		
	ENDPROC

	PROCEDURE getrfctrl		&& Creates dummy textbox to remove focus from grid, when requery
		LOCAL l_oTxtRF
		l_oTxtRF = .NULL.
		
		IF EMPTY(this.cRemoveFocusControlName)
			this.cRemoveFocusControlName = "otxt_"+SYS(2015)
		ENDIF
		IF TYPE("thisform." + this.cRemoveFocusControlName) <> "O"
			thisform.AddObject(this.cRemoveFocusControlName,"ttext")
			l_oTxtRF = EVALUATE("thisform."+this.cRemoveFocusControlName)
			l_oTxtRF.Top = thisform.Top - 100
			l_oTxtRF.Left = thisform.Left - 100
		ENDIF
		IF ISNULL(l_oTxtRF)
			l_oTxtRF = EVALUATE("thisform."+this.cRemoveFocusControlName)
		ENDIF
		
		RETURN l_oTxtRF
		
	ENDPROC

	PROCEDURE getsortkey
		LPARAMETERS toColumn, tcKey, tcDirection
		* Manage sorting key expression before generating index file.
		RETURN IIF(TYPE(tcKey) = "C", "PADR(" + tcKey + ",100)", tcKey)
	ENDPROC

	PROCEDURE Init
		this.CursorCreate()
		this.CursorRecordSource()
		this.SetHeaderCaptions()
		this.jindexfile = filetemp()
		DODEFAULT()
	ENDPROC

	PROCEDURE resetgrid
		this.nRecordCount = 0
	ENDPROC

	PROCEDURE SetFocus
		IF NOT EMPTY(this.RecordSource) AND USED(this.RecordSource)
			SELECT (this.RecordSource)
			IF TAGNO("GridSort") > 0
				SET ORDER TO GridSort
			ENDIF
		ENDIF
		
		DODEFAULT()
	ENDPROC

	PROCEDURE setheadercaptions
		LOCAL i, l_cCaption, l_oCol, l_cColumnName
		this.oCaptions = CREATEOBJECT("Collection")
		this.SetHeaderCaptionsBefore()
		
		FOR i = 1 TO this.oCaptions.Count
			l_cCaption = ""
			TRY
				l_cCaption = this.oCaptions.Item(i)
			CATCH
			ENDTRY
			
			l_oCol = .NULL.
			IF NOT EMPTY(this.MemberClass)
				l_cColumnName = this.MemberClass
			ELSE
				l_cColumnName = "GrdBaseSortColumn"
			ENDIF
			TRY
				l_oCol = EVALUATE("this." + l_cColumnName + TRANSFORM(i))
			CATCH
			ENDTRY
			IF TYPE("l_oCol.Header1.Caption")="C"
				l_oCol.Header1.Caption = l_cCaption
			ENDIF
		ENDFOR
	ENDPROC

	PROCEDURE setheadercaptionsbefore		&& Here define captions for column headers. This is done over collection.
	ENDPROC

ENDDEFINE

DEFINE CLASS kontrole AS commandbutton 
 	*< CLASSDATA: Baseclass="commandbutton" Timestamp="" Scale="Pixels" Uniqueid="" />

	Caption = "Ubaci kontrole"
	Height = 27
	Name = "kontrole"
	Width = 84
	
	PROCEDURE Click
		If Used('controls')
			Select Controls
			Use
		Endif
		Use Controls In 0 Exclusive
		Select Controls
		Zap
		la_prg_="PARAMETERS"
		Insert Into Controls (Control,la_label,la_prg) Values ('thisform.caption=getlangtext("xx","yy",g_lang)',"CAPTION",la_prg_)
		For i=1 To Thisform.ControlCount
			Do Case
			Case Inlist(Upper(Thisform.Controls(i).BaseClass),"LABEL","CHECKBOX","COMMANDBUTTON")
				Do Case
				Case Upper(Thisform.Controls(i).BaseClass)="LABEL"
					LA_LABEL_=Upper(Right(Alltrim(Thisform.Controls(i).Name),Len(Alltrim(Thisform.Controls(i).Name))-1))
				Case Upper(Thisform.Controls(i).BaseClass)="CHECKBOX"
					LA_LABEL_=Upper(Right(Alltrim(Thisform.Controls(i).Name),Len(Alltrim(Thisform.Controls(i).Name))-2))
				Case Upper(Thisform.Controls(i).BaseClass)="COMMANDBUTTON"
					LA_LABEL_=Upper(Right(Alltrim(Thisform.Controls(i).Name),Len(Alltrim(Thisform.Controls(i).Name))-3))
				Endcase
				Insert Into Controls (Control,la_label,la_prg) Values ('thisform.'+Thisform.Controls(i).Name+'.caption=getlangtext("xx","yy",g_lang)',LA_LABEL_,la_prg_)
			Case Inlist(Upper(Thisform.Controls(i).BaseClass),"PAGEFRAME")
				x_='pfcount=thisform.'+Thisform.Controls(i).Name+'.pagecount'
				&x_
				x_='pfname=thisform.Controls(i).name'
				&x_
				For k=1 To pfcount
					x_='pfpname=thisform.'+pfname+'.pages(k).name'
					&x_
					x_='pfpcc=thisform.'+pfname+'.'+pfpname+'.controlcount'
					&x_
					Insert Into Controls (Control,la_label,la_prg) Values ('thisform.'+pfname+'.'+pfpname+'.caption=getlangtext("xx","yy",g_lang)',Upper(pfpname),la_prg_)
					For J=1 To pfpcc
						x_='pfpcbc=thisform.'+pfname+'.'+pfpname+'.Controls(j).baseclass'
						&x_
						x_='pfpcN=thisform.'+pfname+'.'+pfpname+'.Controls(j).NAME'
						&x_
						Do Case
						Case Inlist(Upper(pfpcbc),"LABEL","CHECKBOX","COMMANDBUTTON")
							Do Case
							Case Upper(Upper(pfpcbc))="LABEL"
								LA_LABEL_=Upper(Right(Alltrim(PFPCN),Len(Alltrim(PFPCN))-1))
							Case Upper(pfpcbc)="CHECKBOX"
								LA_LABEL_=Upper(Right(Alltrim(PFPCN),Len(Alltrim(PFPCN))-2))
							Case Upper(pfpcbc)="COMMANDBUTTON"
								LA_LABEL_=Upper(Right(Alltrim(PFPCN),Len(Alltrim(PFPCN))-3))
							Endcase
		
							Insert Into Controls (Control,la_label,la_prg) Values ('thisform.'+pfname+'.'+pfpname+'.'+PFPCN+'.caption=getlangtext("xx","yy",g_lang)',LA_LABEL_,la_prg_)
						Endcase
					Next
				Next
			Endcase
		Next
		Select Controls
		Copy To kontrole.txt Type Sdf
		Messagebox("Gotovo")
		
	ENDPROC

ENDDEFINE

DEFINE CLASS ln AS line 
 	*< CLASSDATA: Baseclass="line" Timestamp="" Scale="Pixels" Uniqueid="" />

	*<DefinedPropArrayMethod>
		*p: f
		*p: h
		*p: l
		*p: t
		*p: w
	*</DefinedPropArrayMethod>

	Height = 17
	Name = "ln"
	Width = 100
	
	PROCEDURE Init
		this.w=this.width
		this.h=this.height
		this.t=this.top
		this.l=this.left
	ENDPROC

ENDDEFINE

DEFINE CLASS resizable AS custom 
 	*< CLASSDATA: Baseclass="custom" Timestamp="" Scale="Pixels" Uniqueid="" />

	*<DefinedPropArrayMethod>
		*m: addtoarray
		*m: adjustcontrols		&& call from resize event of a form to adjust the placement and size of contained objects.
		*m: loopthroughcontrols
		*m: reset		&& Resets the Timer control so that it starts counting from 0.
		*m: setposition
		*m: setsize
		*p: initialformheight
		*p: initialformwidth
		*p: initialresize		&& Is this the first time the controls are being adjusted?
		*p: repositionlist
		*p: resizelist
		*a: acontrolstats[1,5]
	*</DefinedPropArrayMethod>

	PROTECTED acontrolstats,initialformheight,initialformwidth,initialresize
	Height = 19
	initialformheight = 0
	initialformwidth = 0
	initialresize = .T.		&& Is this the first time the controls are being adjusted?
	Name = "resizable"
	repositionlist = Commandbutton Combobox Checkbox Listbox Form Grid Textbox Label Shape Editbox Olecontrol Pageframe Image Spinner
	resizelist = Commandbutton Combobox Checkbox Listbox Form Grid Textbox Label Shape Editbox Olecontrol Pageframe Image Spinner
	Width = 27
	
	PROTECTED PROCEDURE addtoarray
		LPARAMETERS oControl
		nLen = ALEN(THIS.aControlStats,1)
		THIS.aControlStats[nLen,1] = oControl.Top / THIS.InitialFormHeight
		THIS.aControlStats[nLen,2] = oControl.Left / THIS.InitialFormWidth
		THIS.aControlStats[nLen,3] = oControl.Height / THIS.InitialFormHeight
		THIS.aControlStats[nLen,4] = oControl.Width / THIS.InitialFormWidth
		THIS.aControlStats[nLen,5] = IIF(TYPE("oControl.FontSize") = 'U', 0, oControl.FontSize)
		DIMENSION THIS.aControlStats[nLen+1, 5]
		
	ENDPROC

	PROCEDURE adjustcontrols		&& call from resize event of a form to adjust the placement and size of contained objects.
		IF THIS.InitialResize
			THIS.LoopThroughControls("INITIALIZE_AND_ADJUST")
			THIS.InitialResize = .F.
		ELSE
			THIS.LoopThroughControls("ADJUST")
		ENDIF
	ENDPROC

	PROCEDURE Init
		THIS.InitialFormHeight = THISFORM.Height
		THIS.InitialFormWidth = THISFORM.Width
	ENDPROC

	PROTECTED PROCEDURE loopthroughcontrols
		LPARAMETERS cTask
		* Valid parameters for cTask are 'Initialize_And_Adjust' and 'Adjust'
		cTask = UPPER(cTask)
		
		nOldDecimal = SET("DECIMAL")
		SET DECIMAL TO 18
		
		nPos = 0
		THISFORM.LockScreen = .T.
		FOR m.i = 1 TO THISFORM.ControlCount
			oControl = THISFORM.Controls[m.i]
				nPos = nPos + 1
				If cTask = 'INITIALIZE_AND_ADJUST'
					THIS.AddToArray(oControl)
				ENDIF
				IF oControl.Class$THIS.ResizeList
					THIS.SetSize(oControl, nPos)
				ENDIF
				IF oControl.Class$THIS.RepositionList
					THIS.SetPosition(oControl, nPos)
				ENDIF
				
			*A pageframe can contain only pages
			IF THISFORM.Controls[m.i].Baseclass$"Pageframe"
				*Loop through each page of the pageframe
				FOR m.j = 1 TO THISFORM.Controls[m.i].PageCount
					WITH THISFORM.Controls[m.i].pages[m.j]
						*loop through all the controls on the page
						FOR m.k = 1 TO .ControlCount
							nPos = nPos + 1
							IF cTask = 'INITIALIZE_AND_ADJUST'
								THIS.AddToArray(.Controls[m.k])
							ENDIF
							IF oControl.Class$THIS.ResizeList
								THIS.SetSize(oControl, nPos)
							ENDIF
							IF oControl.Class$THIS.RepositionList
								THIS.SetPosition(oControl, nPos)
							ENDIF
						ENDFOR
					ENDWITH
				ENDFOR
			ENDIF			
		ENDFOR
		
		THISFORM.LockScreen = .F.
		SET DECIMAL TO nOldDecimal
	ENDPROC

	PROCEDURE reset		&& Resets the Timer control so that it starts counting from 0.
		* Call the reset method when you add a control to the form at runtime.
		THIS.InitialResize = .T.
		DIMENSION THIS.aControlStats[1,5]
		THIS.InitialFormHeight = THISFORM.Height
		THIS.InitialFormWidth = THISFORM.Width
		
	ENDPROC

	PROTECTED PROCEDURE setposition
		LPARAMETERS oControl, nPos
		oControl.Top = THISFORM.Height * THIS.aControlStats[nPos,1]
		oControl.Left = THISFORM.Width * THIS.aControlStats[nPos,2]
		
	ENDPROC

	PROTECTED PROCEDURE setsize
		LPARAMETERS oControl, nPos
		oControl.Width = THISFORM.Width * THIS.aControlStats[nPos,4]
		IF !oControl.Baseclass $ "Textbox Spinner"
			oControl.Height = THISFORM.Height * THIS.aControlStats[nPos,3]
		ENDIF
		
		
	ENDPROC

ENDDEFINE

DEFINE CLASS setdatasesiontimer AS timer 
 	*< CLASSDATA: Baseclass="timer" Timestamp="" Scale="Pixels" Uniqueid="" />

	*<DefinedPropArrayMethod>
		*p: setto1		&& .T. when SET DATASESSION TO 1 command is issued
	*</DefinedPropArrayMethod>

	Enabled = .F.
	Height = 23
	Interval = 50
	Name = "setdatasesiontimer"
	setto1 = .T.		&& .T. when SET DATASESSION TO 1 command is issued
	Width = 23
	
	PROCEDURE Timer
		this.Enabled = .F.
		IF this.setto1
			SET DATASESSION TO 1
		ENDIF
		DO &g_progname
		RELEASE timerds, g_progname
		
	ENDPROC

ENDDEFINE

DEFINE CLASS sh AS shape 
 	*< CLASSDATA: Baseclass="shape" Timestamp="" Scale="Pixels" Uniqueid="" />

	*<DefinedPropArrayMethod>
		*p: h
		*p: l
		*p: t
		*p: w
	*</DefinedPropArrayMethod>

	BackStyle = 0
	Height = 17
	Name = "sh"
	SpecialEffect = 0
	Width = 100
	
	PROCEDURE Init
		this.w=this.Width
		this.h=this.Height
		this.l=this.left
		this.t=this.top
		
	ENDPROC

ENDDEFINE

DEFINE CLASS sheet AS container 
 	*< CLASSDATA: Baseclass="container" Timestamp="" Scale="Pixels" Uniqueid="" />

	*-- OBJECTDATA items order determines ZOrder / El orden de los items OBJECTDATA determina el ZOrder 
	*< OBJECTDATA: ObjPath="cmdSave" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="cmdDelete" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="cmdCancel" UniqueID="" Timestamp="" />

	*<DefinedPropArrayMethod>
		*m: myinit
	*</DefinedPropArrayMethod>

	BorderWidth = 0
	Height = 30
	Name = "sheet"
	Width = 253

	ADD OBJECT 'cmdCancel' AS tcommandbutton WITH ;
		Caption = "cmdCancel", ;
		Left = 84, ;
		Name = "cmdCancel", ;
		Top = 0
		*< END OBJECT: ClassLib="main.vcx" BaseClass="commandbutton" />

	ADD OBJECT 'cmdDelete' AS tcommandbutton WITH ;
		Caption = "cmdDelete", ;
		Left = 168, ;
		Name = "cmdDelete", ;
		Top = 0
		*< END OBJECT: ClassLib="main.vcx" BaseClass="commandbutton" />

	ADD OBJECT 'cmdSave' AS tcommandbutton WITH ;
		Caption = "cmdSave", ;
		Left = 0, ;
		Name = "cmdSave", ;
		Top = 0
		*< END OBJECT: ClassLib="main.vcx" BaseClass="commandbutton" />
	
	PROCEDURE Init
		thisformset.WindowType= 0
		WITH this.Parent
			.setall("specialeffect",0)
			.setall("forecolor",RGB(0,0,0))
			.backcolor=RGB(192,192,192)
			.alwaysontop=.t.
		endwith
	ENDPROC

	PROCEDURE myinit
	ENDPROC

	PROCEDURE cmdCancel.Click
		If 6=Messagebox(GetLangText("SCREENS","TA_UNDOCHANGE")+"?",36)
			thisformset.release
		Endif
		
	ENDPROC

	PROCEDURE cmdDelete.Click
		If 6=Messagebox(GetLangText("SCREENS","TA_DELETE")+"?",36)
			If Seek(Thisformset.reserid,'sheet','tag1')
				Delete In Sheet
			Endif
		Endif
		Thisformset.Release
		
	ENDPROC

	PROCEDURE cmdSave.Click
		IF SEEK(thisformset.reserid,'sheet','tag1')
			GATHER MEMVAR memo
		ELSE
			INSERT INTO sheet FROM memvar
		endif
		thisformset.release
	ENDPROC

ENDDEFINE

DEFINE CLASS tbgrid AS textbox 
 	*< CLASSDATA: Baseclass="textbox" Timestamp="" Scale="Pixels" Uniqueid="" />

	*<DefinedPropArrayMethod>
		*p: ctooltiptext
	*</DefinedPropArrayMethod>

	BackColor = 10,36,106
	BorderStyle = 0
	ctooltiptext = 
	ForeColor = 255,255,255
	Height = 23
	InputMask = ""
	Name = "tbgrid"
	ReadOnly = .T.
	SpecialEffect = 0
	Width = 100
	
	PROCEDURE DblClick
		this.Parent.Parent.dblclick
	ENDPROC

	PROCEDURE KeyPress
		LPARAMETERS nKeyCode, nShiftAltCtrl
		
		IF this.Parent.ReadOnly AND NOT INLIST(nKeyCode, 1, 3, 4, 5, 6, 9, 13, 14, 15, 18, 19, 24, 27, 148)
			NODEFAULT
		ENDIF
	ENDPROC

	PROCEDURE MouseEnter
		LPARAMETERS nButton, nShift, nXCoord, nYCoord
		this.Parent.Parent.MouseEnter(nButton, nShift, nXCoord, nYCoord)
		IF NOT EMPTY(this.ctooltiptext)
			FoxGUI_ShowToolTip(THIS, THISFORM, 0, 0, 0)
		ENDIF
		DODEFAULT()
	ENDPROC

	PROCEDURE MouseUp
		LPARAMETERS nButton, nShift, nXCoord, nYCoord
		IF TYPE("this.Parent.Parent") = "O"
			this.Parent.Parent.MouseUp(nButton, nShift, nXCoord, nYCoord)
		ENDIF
		
	ENDPROC

ENDDEFINE

DEFINE CLASS tbrowse AS grdbase OF "main.vcx" 
 	*< CLASSDATA: Baseclass="grid" Timestamp="" Scale="Pixels" Uniqueid="" />

	*<DefinedPropArrayMethod>
		*m: acolumns_assign
		*m: adduserdefinedcolumn
		*m: browsego
		*m: browsekeypress
		*m: browsepropget
		*m: browsescroll
		*m: browsesource
		*m: enablebrowsescroll
		*m: requerycursor
		*p: cdefaultcolumninputmask		&& Default input mask for column
		*p: cforclause
		*p: clocateforclause
		*p: cmaintainedalias
		*p: cnotlocatemessage
		*p: corder
		*p: csourcealias
		*p: csourcecolors
		*p: csourcecolumns
		*p: ctbrwdataname
		*p: cwhileclause
		*p: eseekexpression
		*p: lbrowsefromselected
		*p: ldescending
		*p: lnotfoundmessage
		*p: lnotlocatemessage
		*p: lupdatecursordata
		*p: nbottomrecno
		*p: nlinetoscroll		&& specified number of lines to scroll with one scroll of the mouse whell (min. value: 1)
		*p: nselectedrecno
		*p: ntoprecno
		*p: obrwdata
		*a: acolumns[1,13]
	*</DefinedPropArrayMethod>

	AllowCellSelection = .F.
	cdefaultcolumninputmask = 		&& Default input mask for column
	cforclause = 
	clocateforclause = 
	cmaintainedalias = 
	cnotlocatemessage = 
	corder = 
	csourcealias = 
	csourcecolors = 
	csourcecolumns = 
	ctbrwdataname = 
	cwhileclause = 
	lgetmouseposition = .T.
	lnotfoundmessage = .T.
	lnotlocatemessage = .T.
	lresizecolumns = .F.
	Name = "tbrowse"
	nbottomrecno = 0
	nlinetoscroll = 1		&& specified number of lines to scroll with one scroll of the mouse whell (min. value: 1)
	ntoprecno = 0
	obrwdata = .NULL.
	p_basecolumncontrol = tbgrid
	p_basecolumncontrolname = Tbgrid1
	resizefontsize = .F.
	setcolumns = .T.
	
	PROCEDURE acolumns_assign
		LPARAMETERS vNewVal, m.nIndex1, m.nIndex2
		IF ISNULL(m.nIndex1)  && user didn't pass in a subscript
			THIS.acolumns = m.vNewVal
		ELSE
			THIS.acolumns[m.nIndex1, m.nIndex2] = m.vNewVal
		ENDIF
	ENDPROC

	PROCEDURE adduserdefinedcolumn
		LOCAL lnArrayRowsNumber, lnArrayColumnsNumber
		
		lnArrayRowsNumber = ALEN(this.aColumns,1)
		lnArrayColumnsNumber = ALEN(this.aColumns,2)
		
		FOR EACH loColumn IN this.Columns
			IF loColumn.lUDCol
				lnArrayRowsNumber = lnArrayRowsNumber + 1
				DIMENSION this.aColumns(lnArrayRowsNumber,lnArrayColumnsNumber)
				IF '(' $ loColumn.ControlSource AND ')' $ loColumn.ControlSource
					this.aColumns(lnArrayRowsNumber,4) = loColumn.ControlSource
				ELSE
					this.aColumns(lnArrayRowsNumber,1) = loColumn.ControlSource
				ENDIF
				this.aColumns(lnArrayRowsNumber,2) = loColumn.Width
				this.aColumns(lnArrayRowsNumber,3) = loColumn.Header1.Caption
		
				* Dont set dynamic fore and back color. This coused error:
				* Error: 13 Message: Alias '_2I10VVU6U' is not found. 
				
				* this.aColumns(lnArrayRowsNumber,5) = loColumn.DynamicForeColor
				* this.aColumns(lnArrayRowsNumber,6) = loColumn.DynamicBackColor
		
				this.aColumns(lnArrayRowsNumber,7) = loColumn.Name
				this.aColumns(lnArrayRowsNumber,8) = loColumn.ColumnOrder
			ENDIF
		NEXT
	ENDPROC

	PROCEDURE AfterRowColChange
		LPARAMETERS nColIndex
		IF NOT EMPTY(this.cMaintainedAlias)
			LOCAL l_cAlias, l_nRecNo
			l_cAlias = this.RecordSource
			l_nRecNo = &l_cAlias..tbl_recno
			GO l_nRecNo IN (this.cMaintainedAlias)
		ENDIF
		DODEFAULT(nColIndex)
	ENDPROC

	PROCEDURE browsego
		LPARAMETERS lp_lRequery
		LOCAL l_lFound, l_cMacro, l_cRecordSource, i
		
		IF lp_lRequery
			LOCAL ARRAY l_aColProp(this.ColumnCount,1)
			FOR i = 1 TO this.ColumnCount
				l_aColProp(i,1)=this.Columns(i).Alignment
			ENDFOR
			l_cRecordSource = this.RecordSource
			this.RecordSource = ""
			ZAP IN (l_cRecordSource)
			this.RecordSource = l_cRecordSource
			SELECT (l_cRecordSource)
			FOR i = 1 TO this.ColumnCount
				DO CASE
					CASE NOT EMPTY(this.aColumns(i, 4))
						this.Columns(i).ControlSource = this.cSourceColumns + ".TBL_COLUMN" + LTRIM(STR(i))
					CASE NOT EMPTY(this.aColumns(i, 1))
						this.Columns(i).ControlSource = this.aColumns(i, 1)
				ENDCASE
				this.Columns(i).Alignment = l_aColProp(i,1)
			NEXT
		ENDIF
		IF this.lbrowsefromselected
			SELECT (this.RecordSource)
			IF EMPTY(this.cOrder)
				SET ORDER TO tbl_recno
			ELSE
				l_cMacro = [SET ORDER TO ] + IIF(EMPTY(this.cOrder), [], this.cOrder + IIF(this.lDescending,[ DESCENDING],[]))
				&l_cMacro
			ENDIF
			SELECT (this.cSourceAlias)
			GO this.nselectedrecno
			IF EMPTY(this.cOrder) OR TAGNO(this.cOrder) # 0
				l_cMacro = [SET ORDER TO ] + IIF(EMPTY(this.cOrder), [], this.cOrder + IIF(this.lDescending,[ DESCENDING],[]))
				&l_cMacro
			ENDIF
			l_lFound = .T.
		ELSE
			l_lFound = this.oBrwData.BrowseLocate()
			IF NOT l_lFound
				RETURN l_lFound
			ENDIF
		ENDIF
		
		this.BrowseScroll(-3)
		this.BrowseScroll(2)
		
		RETURN l_lFound
	ENDPROC

	PROCEDURE browsekeypress
		LPARAMETERS nKeyCode, nShiftAltCtrl
		* This method should be called from: this.Parent.KeyPress event.
		* Property this.Parent.KeyPreview should be set to True.
		LOCAL l_lRefresh
		l_lRefresh =.F.
		DO CASE
			CASE nKeyCode =  5 AND nShiftAltCtrl = 0 && UP ARROW
				this.BrowseScroll(0)
				l_lRefresh = .T.
			CASE nKeyCode = 24 AND nShiftAltCtrl = 0 && DOWN ARROW
				this.BrowseScroll(1)
				l_lRefresh = .T.
			CASE nKeyCode = 18 AND nShiftAltCtrl = 0 && PAGE UP
				IF this.enablebrowsescroll(2)
					this.BrowseScroll(2)
					l_lRefresh = .T.
				ENDIF
			CASE nKeyCode =  3 AND nShiftAltCtrl = 0 && PAGE DOWN
				IF this.enablebrowsescroll(3)
					this.BrowseScroll(3)
					l_lRefresh = .T.
				ENDIF
		ENDCASE
		IF l_lRefresh
			this.Refresh()
		ENDIF
	ENDPROC

	PROCEDURE browsepropget
		LPARAMETERS lp_cColumnName, lp_cPropName
		LOCAL i, l_ePropVal
		FOR i = 1 TO ALEN(this.aColumns, 1)
			IF this.aColumns(i, 7) == lp_cColumnName
				DO CASE
					CASE lp_cPropName = "ControlSource"
						DO CASE
							CASE NOT EMPTY(this.aColumns(i, 4))
								l_ePropVal = this.cSourceColumns + ".TBL_COLUMN" + LTRIM(STR(i))
							CASE NOT EMPTY(this.aColumns(i, 1))
								l_ePropVal = this.aColumns(i, 1)
							OTHERWISE
								l_ePropVal = ""
						ENDCASE
					CASE lp_cPropName = "DynamicBackColor"
						IF NOT EMPTY(this.aColumns(i, 6))
							l_ePropVal = this.cSourceColors + ".TBL_BCOLOR" + LTRIM(STR(i))
						ELSE
							l_ePropVal = ""
						ENDIF
					CASE lp_cPropName = "DynamicForeColor"
						IF NOT EMPTY(this.aColumns(i, 5))
							l_ePropVal = this.cSourceColors + ".TBL_FCOLOR" + LTRIM(STR(i))
						ELSE
							l_ePropVal = ""
						ENDIF
				ENDCASE
			ENDIF
		ENDFOR
		RETURN l_ePropVal
	ENDPROC

	PROCEDURE browsescroll
		LPARAMETERS lp_nDirection, lp_nCount
		LOCAL l_nRows, l_nGridHeight, l_nRecNo, l_nRowsRefrshed
		l_nRecNo = RECNO(this.RecordSource)
		l_nGridHeight = CEILING((this.Height - this.HeaderHeight - 2) / this.RowHeight) - 2
		DO CASE
			CASE INLIST(lp_nDirection, 0, 2)
				IF lp_nDirection == 0	&& UP arrow
					l_nRows = - 2
				ELSE
					l_nRows = - 2 * l_nGridHeight	&& PAGE UP
				ENDIF
			CASE INLIST(lp_nDirection, 1, 3)
				IF lp_nDirection == 1	&& DOWN arrow
					l_nRows = 3
				ELSE
					l_nRows = 2 * l_nGridHeight	&& PAGE DOWN
				ENDIF
			CASE lp_nDirection == -1
				l_nRows = l_nGridHeight
				IF EMPTY(this.nBottomRecNo)
					GO BOTTOM IN (this.RecordSource)
					this.nBottomRecNo = RECNO(this.RecordSource)
				ELSE
					GO (this.nBottomRecNo) IN (this.RecordSource)
				ENDIF
				l_nRecNo = RECNO(this.RecordSource)
			CASE lp_nDirection == -2
				l_nRows = - l_nGridHeight
				IF EMPTY(this.nTopRecNo)
					GO TOP IN (this.RecordSource)
					this.nTopRecNo = RECNO(this.RecordSource)
				ELSE
					GO (this.nTopRecNo) IN (this.RecordSource)
				ENDIF
				l_nRecNo = RECNO(this.RecordSource)
			CASE lp_nDirection == -3
				l_nRows = 2 * l_nGridHeight
				this.nTopRecNo = 0
			*CASE lp_nDirection == -4
				*l_nRows = - 2 * l_nGridHeight
				*this.nBottomRecNo = 0
			CASE lp_nDirection == -5
				l_nRows = lp_nCount
			OTHERWISE
				* Log this case in file.
				RETURN .F.
		ENDCASE
		IF NOT INLIST(lp_nDirection, -3, -4)
			this.oBrwData.BrowseRelation()
		ENDIF
		
		l_nRowsRefrshed = this.oBrwData.BrowseNext(l_nRows)
		IF this.lUpdateCursorData
			this.oBrwData.BrowseUpdateExistingRows(l_nRows, l_nRecNo)
		ENDIF
		RETURN l_nRowsRefrshed
	ENDPROC

	PROCEDURE browsesource
		LOCAL l_cName, i
		LOCAL ARRAY l_aFields(1)
		
		this.oBrwData.BrowseSource()
		
		this.ColumnCount = ALEN(this.aColumns, 1)
		
		SELECT(this.RecordSource)
		FOR i = 1 TO MIN(this.ColumnCount, ALEN(this.aColumns, 1))
			this.aColumns(i, 7) = this.Columns(i).Name
			DO CASE
				CASE NOT EMPTY(this.aColumns(i, 4))
					this.Columns(i).ControlSource = this.cSourceColumns + ".TBL_COLUMN" + LTRIM(STR(i))
				CASE NOT EMPTY(this.aColumns(i, 1))
					this.Columns(i).ControlSource = this.aColumns(i, 1)
			ENDCASE
			IF NOT EMPTY(this.aColumns(i, 2))
				this.Columns(i).Width = this.aColumns(i, 2)
			ENDIF
			IF NOT EMPTY(this.aColumns(i, 3))
				this.Columns(i).Header1.Caption = this.aColumns(i, 3)
			ENDIF
			IF NOT EMPTY(this.aColumns(i, 5))
				l_cName = ".TBL_FCOLOR" + LTRIM(STR(i))
				this.Columns(i).DynamicForeColor = this.cSourceColors + l_cName
			ENDIF
			IF NOT EMPTY(this.aColumns(i, 6))
				l_cName = this.cSourceColors + ".TBL_BCOLOR" + LTRIM(STR(i))
				this.Columns(i).AddProperty("cCustomDynamicBackColor","!ISNULL("+l_cName+"),"+l_cName)
			ENDIF
			IF NOT EMPTY(this.aColumns(i, 8))
				this.Columns(i).cSortOrder = this.aColumns(i, 8)
			ENDIF
			IF TYPE("this.aColumns(i, 10)")="C" AND NOT EMPTY(this.aColumns(i, 10))
				this.Columns(i).InputMask = this.aColumns(i, 10)
			ELSE
				IF NOT EMPTY(this.cDefaultColumnInputMask)
					this.Columns(i).InputMask = this.cDefaultColumnInputMask
				ENDIF
			ENDIF
			IF TYPE("this.aColumns(i, 11)")="L" AND this.aColumns(i, 11)
				this.Columns(i).FontBold = .T.
			ENDIF
			IF TYPE("this.aColumns(i, 12)")="C" AND NOT EMPTY(this.aColumns(i, 12))
				this.Columns(i).AddProperty("cDblClickScript", this.aColumns(i, 12))
			ENDIF
			IF TYPE("this.aColumns(i, 13)")="C" AND NOT EMPTY(this.aColumns(i, 13))
				this.Columns(i).DynamicFontBold = this.aColumns(i, 13)
			ENDIF
		ENDFOR
		RETURN .T.
	ENDPROC

	PROCEDURE DblClick
		LOCAL loColumn, lcScript
		
		* Find column object
		FOR EACH loColumn IN this.Columns
			IF loColumn.ColumnOrder = this.nGridCol
				IF TYPE("loColumn.cDblClickScript") = "C" AND NOT EMPTY(loColumn.cDblClickScript)
					lcScript = loColumn.cDblClickScript
				ENDIF
				EXIT
			ENDIF
		NEXT
		
		IF EMPTY(lcScript)
			DODEFAULT()
		ELSE
			IF &lcScript
				NODEFAULT
			ELSE
				DODEFAULT()
			ENDIF
		ENDIF
	ENDPROC

	PROCEDURE Destroy
		LOCAL l_cSource
		
		DODEFAULT()
		
		l_cSource = this.RecordSource
		this.RecordSource = ""
		USE IN (this.cSourceColors)
		USE IN (this.cSourceColumns)
		USE IN (l_cSource)
		this.oBrwData = .NULL.
		
		RETURN .T.
	ENDPROC

	PROCEDURE enablebrowsescroll
		LPARAMETERS lp_nDirection, lp_nLineToScroll
		LOCAL l_nGridHeight, l_cCondition, l_cEofBofCondition
		LOCAL l_nSkip, l_lEnable, l_nCount, l_nRecNo
		l_nCount = 0
		l_lEnable = .F.
		l_nRecNo = RECNO(this.RecordSource)
		l_nGridHeight = CEILING((this.Height - this.HeaderHeight - 2) / this.RowHeight) - 2
		
		DO CASE
			CASE lp_nDirection = 0	&& UP ARROW
				l_cCondition = "NOT l_nCount > 3"
				l_cEofBofCondition = "BOF(this.RecordSource)"
				l_nSkip = -1
			CASE lp_nDirection = 1	&& DOWN ARROW
				l_cCondition = "NOT l_nCount > 3"
				l_cEofBofCondition = "EOF(this.RecordSource)"
				l_nSkip = 1
			CASE lp_nDirection = 2	&& PAGE UP
				l_cCondition = "NOT l_nCount > 2*l_nGridHeight"
				l_cEofBofCondition = "BOF(this.RecordSource)"
				l_nSkip = -1
			CASE lp_nDirection = 3	&& PAGE DOWN
				l_cCondition = "NOT l_nCount > 2*l_nGridHeight"
				l_cEofBofCondition = "EOF(this.RecordSource)"
				l_nSkip = 1
		ENDCASE
		
		DO WHILE &l_cCondition
			IF &l_cEofBofCondition
				l_lEnable = .T.
				EXIT
			ENDIF
			l_nCount = l_nCount + 1
			SKIP l_nSkip
		ENDDO
		GO l_nRecNo IN this.RecordSource
		RETURN l_lEnable
	ENDPROC

	PROCEDURE Init
		LPARAMETERS lp_lGoLater
		IF EMPTY(this.cForClause)
			this.cForClause = ".T."
		ENDIF
		IF EMPTY(this.cWhileClause)
			this.cWhileClause = ".T."
		ENDIF
		this.lcolumnsort = .T.
		
		DODEFAULT()
		
		IF this.lAddUserDefinedColumns
			this.AddUserDefinedColumn()
		ENDIF
		
		IF NOT EMPTY(this.cSourceAlias)
			this.cTbrwDataName = "oBrwData"+SYS(2015)
			this.Parent.AddObject(this.cTbrwDataName,"tbrwdata")
			this.oBrwData = EVALUATE("this.Parent."+this.cTbrwDataName)
			DIMENSION this.oBrwData.aColumns(ALEN(this.aColumns,1), ALEN(this.aColumns,2))
			ACOPY(this.aColumns, this.oBrwData.aColumns)
			this.oBrwData.ogridreference = this
			this.BrowseSource()
			IF NOT lp_lGoLater
				this.BrowseGo()
			ENDIF
		ENDIF
		
		RETURN .T.
	ENDPROC

	PROCEDURE MouseUp
		LPARAMETERS nButton, nShift, nXCoord, nYCoord
		IF nButton = 1
			this.BrowseScroll(-5,2)
			this.BrowseScroll(-5,-2)
		ENDIF
		DODEFAULT(nButton, nShift, nXCoord, nYCoord)
		this.Refresh()
	ENDPROC

	PROCEDURE m_setgriddynamiccolor
		NODEFAULT
	ENDPROC

	PROCEDURE requerycursor
		LPARAMETERS lp_lZapCursor, lp_lBrowseFromSelected
		LOCAL l_lFound, l_nOldArea
		l_nOldArea = SELECT()
		
		WaitWindowShow(GetLangText("COMMON", "T_PLEASEWAIT"))
		
		this.lbrowsefromselected = lp_lBrowseFromSelected
		IF EMPTY(this.nselectedrecno)
			this.nselectedrecno = EVALUATE(this.RecordSource+ ".tbl_recno")
		ENDIF
		l_lFound = this.BrowseGo(lp_lZapCursor)
		IF NOT l_lFound
			WaitWindowClear()
			RETURN l_lFound
		ENDIF
		this.RefreshSortCursor()
		this.Refresh()
		this.nselectedrecno = 0
		WaitWindowClear()
		SELECT (l_nOldArea) 
		RETURN .T.
	ENDPROC

	PROCEDURE Resize
		LOCAL l_nRowsBefore, l_nRowsAfter
		l_nRowsBefore = CEILING((this.Height - this.HeaderHeight - 2) / this.RowHeight) - 2
		DODEFAULT()
		l_nRowsAfter = CEILING((this.Height - this.HeaderHeight - 2) / this.RowHeight) - 2
		IF l_nRowsAfter > l_nRowsBefore
			this.BrowseScroll(-5, l_nRowsAfter - l_nRowsBefore)
		ENDIF
		this.Refresh()
		RETURN .T.
	ENDPROC

	PROCEDURE setordering
		LPARAMETERS lp_cSortOrder, lp_lAskOrder
		LOCAL l_cRecordSource, l_nSelect, l_cDirection
		
		l_nSelect = SELECT()
		
		SELECT (this.RecordSource)
		DO CASE
			CASE lp_lAskOrder
				l_cDirection = SortPopup(ICASE(NOT UPPER(ORDER()) == UPPER(lp_cSortOrder), 0, DESCENDING(), 2, 1))
			CASE UPPER(ORDER()) == UPPER(lp_cSortOrder) AND !DESCENDING()
				l_cDirection = "DESCENDING"
			OTHERWISE
				l_cDirection = "ASCENDING"
		ENDCASE
		IF NOT EMPTY(l_cDirection)
			SET ORDER TO lp_cSortOrder &l_cDirection
			SET ORDER TO lp_cSortOrder &l_cDirection IN this.cSourceAlias
			this.cOrder = lp_cSortOrder
			this.lDescending = (l_cDirection = "DESCENDING")
			LOCAL l_lZapCursor, l_lBrowseFromSelected
			l_lZapCursor = .T.
			l_lBrowseFromSelected = .T.
			this.RequeryCursor(l_lZapCursor, l_lBrowseFromSelected)
			this.RefreshSortCursor()
		ENDIF
		
		SELECT (l_nSelect)
		
		RETURN .T.
	ENDPROC

ENDDEFINE

DEFINE CLASS tcbogrid AS tcombobox OF "main.vcx" 
 	*< CLASSDATA: Baseclass="combobox" Timestamp="" Scale="Pixels" Uniqueid="" />

	BorderStyle = 0
	DisabledBackColor = 10,36,106
	DisabledForeColor = 255,255,255
	Name = "tcbogrid"
	
	PROCEDURE When
		this.BackColor=this.SelectedBackColor
		this.ForeColor=this.SelectedForeColor
		WITH This.Parent.Parent
			.nRecNo = RECNO(.RecordSource)
		ENDWITH
		RETURN DODEFAULT()
	ENDPROC

ENDDEFINE

DEFINE CLASS tcheckbox AS checkbox 
 	*< CLASSDATA: Baseclass="checkbox" Timestamp="" Scale="Pixels" Uniqueid="" />

	*<DefinedPropArrayMethod>
		*p: f
		*p: h
		*p: l
		*p: ldontresize
		*p: nlineheight
		*p: resizefontsize
		*p: t
		*p: w
	*</DefinedPropArrayMethod>

	Alignment = 0
	AutoSize = .F.
	BackStyle = 0
	Caption = ""
	Height = 17
	ldontresize = .F.
	Name = "tcheckbox"
	nlineheight = 1
	resizefontsize = .T.
	Width = 60
	
	PROCEDURE Click
		IF PEMSTATUS(thisform, "HndClick", 5)
			thisform.HndClick(this)
		ENDIF
	ENDPROC

	PROCEDURE GotFocus
		IF PEMSTATUS(thisform, "HndGotFocus", 5)
			thisform.HndGotFocus(this)
		ENDIF
	ENDPROC

	PROCEDURE Init
		this.w=this.width
		this.h=this.height
		this.f=this.fontsize
		this.t=this.top
		this.l=this.left
	ENDPROC

	PROCEDURE InteractiveChange
		IF PEMSTATUS(thisform, "HndInteractiveChange", 5)
			thisform.HndInteractiveChange(this)
		ENDIF
	ENDPROC

	PROCEDURE LostFocus
		IF PEMSTATUS(thisform, "HndLostFocus", 5)
			thisform.HndLostFocus(this)
		ENDIF
	ENDPROC

	PROCEDURE Valid
		IF PEMSTATUS(thisform, "HndValid", 5)
			RETURN thisform.HndValid(this)
		ENDIF
	ENDPROC

	PROCEDURE When
		IF PEMSTATUS(thisform, "HndWhen", 5)
			RETURN thisform.HndWhen(this)
		ENDIF
	ENDPROC

ENDDEFINE

DEFINE CLASS tchkgrid AS tcheckbox OF "main.vcx" 
 	*< CLASSDATA: Baseclass="checkbox" Timestamp="" Scale="Pixels" Uniqueid="" />

	Name = "tchkgrid"
	
	PROCEDURE InteractiveChange
		this.Value = thisform.CheckIfOverbooked(this.Value)
		DODEFAULT()
	ENDPROC

	PROCEDURE When
		WITH This.Parent.Parent
			.nRecNo = RECNO(.RecordSource)
		ENDWITH
		RETURN DODEFAULT()
	ENDPROC

ENDDEFINE

DEFINE CLASS tcntgrid AS container 
 	*< CLASSDATA: Baseclass="container" Timestamp="" Scale="Pixels" Uniqueid="" />

	*-- OBJECTDATA items order determines ZOrder / El orden de los items OBJECTDATA determina el ZOrder 
	*< OBJECTDATA: ObjPath="Ttext1" UniqueID="" Timestamp="" />

	*<DefinedPropArrayMethod>
		*m: backcolor_assign
		*m: controlsource_assign
		*m: forecolor_assign
		*p: controlsource		&& Specifies the source of data to which an object is bound.
	*</DefinedPropArrayMethod>

	BackStyle = 0
	BorderWidth = 0
	controlsource = 		&& Specifies the source of data to which an object is bound.
	Height = 23
	Name = "tcntgrid"
	Visible = .F.
	Width = 100

	ADD OBJECT 'Ttext1' AS ttext WITH ;
		Anchor = 15, ;
		BorderStyle = 0, ;
		DisabledForeColor = 0,0,0, ;
		Enabled = .F., ;
		Name = "Ttext1", ;
		SpecialEffect = 1
		*< END OBJECT: ClassLib="main.vcx" BaseClass="textbox" />
	
	PROCEDURE backcolor_assign
		LPARAMETERS vNewVal
		
		vNewVal = BITAND(vNewVal,0xFFFFFF)
		this.tText1.DisabledBackColor = vNewVal
		this.BackColor = vNewVal
	ENDPROC

	PROCEDURE controlsource_assign
		LPARAMETERS vNewVal
		
		this.tText1.ControlSource = vNewVal
		this.ControlSource = vNewVal
	ENDPROC

	PROCEDURE forecolor_assign
		LPARAMETERS vNewVal
		
		vNewVal = BITAND(vNewVal,0xFFFFFF)
		this.tText1.DisabledForeColor = vNewVal
		this.ForeColor = vNewVal
	ENDPROC

	PROCEDURE Ttext1.DblClick
		this.Parent.Parent.Parent.DblClick()
	ENDPROC

	PROCEDURE Ttext1.KeyPress
		LPARAMETERS nKeyCode, nShiftAltCtrl
		
		IF this.Parent.Parent.ReadOnly AND NOT INLIST(nKeyCode, 1, 3, 4, 5, 6, 9, 13, 14, 15, 18, 19, 24, 27, 148)
			NODEFAULT
		ENDIF
	ENDPROC

	PROCEDURE Ttext1.MouseEnter
		LPARAMETERS nButton, nShift, nXCoord, nYCoord
		
		this.Parent.Parent.Parent.MouseEnter(nButton, nShift, nXCoord, nYCoord)
		
		DODEFAULT()
	ENDPROC

	PROCEDURE Ttext1.MouseUp
		LPARAMETERS nButton, nShift, nXCoord, nYCoord
		
		this.Parent.Parent.Parent.MouseUp(nButton, nShift, nXCoord, nYCoord)
	ENDPROC

ENDDEFINE

DEFINE CLASS tcombobox AS combobox 
 	*< CLASSDATA: Baseclass="combobox" Timestamp="" Scale="Pixels" Uniqueid="" />

	*<DefinedPropArrayMethod>
		*m: autoselectfirstnonempty
		*m: checklistvalues
		*p: f
		*p: h
		*p: l
		*p: linitdone
		*p: nlineheight
		*p: resizefontsize
		*p: t
		*p: w
		*a: cw[1,0]
	*</DefinedPropArrayMethod>

	Height = 23
	linitdone = .F.
	Name = "tcombobox"
	nlineheight = 1
	resizefontsize = .T.
	Width = 100
	
	PROCEDURE autoselectfirstnonempty
		LPARAMETERS lp_cField, lp_cAlias, lp_lSelectEmpty, lp_lDontOpenComboList
		IF EMPTY(lp_cField)
			RETURN .F.
		ENDIF
		IF EMPTY(lp_cAlias)
			RETURN .F.
		ENDIF
		IF NOT USED(lp_cAlias)
			RETURN .F.
		ENDIF
		
		IF EMPTY(this.Value)
			LOCAL l_nSelect
			l_nSelect = SELECT()
			SELECT (lp_cAlias)
			TRY
				IF lp_lSelectEmpty
					LOCATE FOR EMPTY(&lp_cField)
				ELSE
					LOCATE FOR NOT EMPTY(&lp_cField)
				ENDIF
				this.DisplayValue = &lp_cField
			CATCH
			ENDTRY
			SELECT (l_nSelect)
			IF NOT lp_lDontOpenComboList
				KEYBOARD '{ALT+DNARROW}'
			ENDIF
		ENDIF
		
		RETURN .T.
	ENDPROC

	PROCEDURE checklistvalues
		LPARAMETERS lp_cValueMacro
		LOCAL i
		IF NOT EMPTY(lp_cValueMacro)
			this.DisplayValue = EVALUATE(lp_cValueMacro)
		ENDIF
		IF EMPTY(this.DisplayValue)
			RETURN .T.
		ELSE
			FOR i = 1 TO this.ListCount
				IF ALLTRIM(UPPER(this.DisplayValue)) == ALLTRIM(UPPER(this.List(i,1)))
					IF NOT EMPTY(lp_cValueMacro)
						this.ListIndex = i
					ENDIF
					RETURN .T.
				ENDIF
			NEXT
			FOR i = 1 TO this.ListCount
				IF ALLTRIM(UPPER(this.List(i,1))) = ALLTRIM(UPPER(this.DisplayValue))
					this.ListIndex = i
					EXIT
				ENDIF
			NEXT
		ENDIF
		RETURN .F.
	ENDPROC

	PROCEDURE Click
		IF PEMSTATUS(thisform, "HndClick", 5)
			thisform.HndClick(this)
		ENDIF
	ENDPROC

	PROCEDURE GotFocus
		IF PEMSTATUS(thisform, "HndGotFocus", 5)
			thisform.HndGotFocus(this)
		ENDIF
	ENDPROC

	PROCEDURE Init
		*SET STEP ON
		IF NOT this.lInitDone
			This.w=This.Width
			This.h=This.Height
			This.F=This.FontSize
			This.T=This.Top
			This.l=This.Left
		ENDIF
		If This.Columncount>0
			DIMENSION this.cw(this.ColumnCount)
			LOCAL i
			For i=1 To This.ColumnCount
				If i=1
					This.cw(i)=VAL(Substr(This.ColumnWidths,1,Atc(',',This.ColumnWidths)-1))
					Loop
				Endif
				If i=This.ColumnCount
					This.cw(i)=VAL(Substr(This.ColumnWidths,Atc(',',This.ColumnWidths,i-1)+1,Len(Alltrim(This.ColumnWidths))-Atc(',',This.ColumnWidths,i-1)))
					Loop
				Endif
				This.cw(i)=VAL(Substr(This.ColumnWidths,Atc(',',This.ColumnWidths,i-1)+1,Atc(',',This.ColumnWidths,i)-Atc(',',This.ColumnWidths,i-1)-1))
			Next
		ENDIF
		
	ENDPROC

	PROCEDURE InteractiveChange
		IF PEMSTATUS(thisform, "HndInteractiveChange", 5)
			thisform.HndInteractiveChange(this)
		ENDIF
	ENDPROC

	PROCEDURE KeyPress
		LPARAMETERS nKeyCode, nShiftAltCtrl
		
		DO CASE
			CASE nShiftAltCtrl = 0 AND nKeyCode = 7		&& Delete
				this.Value = Blank(this.Value)
				NODEFAULT
			CASE nShiftAltCtrl = 2 AND nKeyCode = 12	&& Ctrl+L
				KEYBOARD '{ALT+DNARROW}'
				NODEFAULT
			OTHERWISE
		ENDCASE
	ENDPROC

	PROCEDURE LostFocus
		IF PEMSTATUS(thisform, "HndLostFocus", 5)
			thisform.HndLostFocus(this)
		ENDIF
	ENDPROC

	PROCEDURE Valid
		IF NOT this.CheckListValues()
			KEYBOARD '{ALT+DNARROW}'
			RETURN 0
		ENDIF
		IF PEMSTATUS(thisform, "HndValid", 5)
			RETURN thisform.HndValid(this)
		ENDIF
	ENDPROC

	PROCEDURE When
		IF PEMSTATUS(thisform, "HndWhen", 5)
			RETURN thisform.HndWhen(this)
		ENDIF
	ENDPROC

ENDDEFINE

DEFINE CLASS tcommandbutton AS commandbutton 
 	*< CLASSDATA: Baseclass="commandbutton" Timestamp="" Scale="Pixels" Uniqueid="" />

	*<DefinedPropArrayMethod>
		*m: ctooltiptext_assign
		*m: picture_assign
		*p: ctooltiptext		&& Extended ToolTipText, over 127 Char.
		*p: f
		*p: h
		*p: l
		*p: ldontresize
		*p: resizefontsize
		*p: t
		*p: w
	*</DefinedPropArrayMethod>

	Caption = "Command1"
	Height = 27
	ldontresize = .F.
	Name = "tcommandbutton"
	resizefontsize = .T.
	Width = 84
	
	PROCEDURE Click
		IF PEMSTATUS(thisform, "HndClick", 5)
			thisform.HndClick(this)
		ENDIF
	ENDPROC

	PROCEDURE ctooltiptext_assign
		LPARAMETERS vNewVal
		*To do: Modify this routine for the Assign method
		this.ToolTipText = m.vNewVal
		THIS.ctooltiptext = m.vNewVal
		
	ENDPROC

	PROCEDURE Init
		this.Picture = this.Picture
		this.w=this.width
		this.h=this.height
		this.f=this.fontsize
		this.t=this.top
		this.l=this.left
	ENDPROC

	PROCEDURE picture_assign
		LPARAMETERS tcNewVal
		LOCAL lcDisabledPicture, lcPicture
		
		IF NOT EMPTY(tcNewVal)
			lcPicture = tcNewVal
			lcDisabledPicture = JUSTPATH(tcNewVal) + "\dis" + JUSTFNAME(tcNewVal)
			IF TYPE("_Screen.oGlobal.oColPictures") = "O"
				this.Picture = ""
				this.DisabledPicture = ""
				_Screen.oGlobal.oColPictures.GetPicture(lcPicture)
				_Screen.oGlobal.oColPictures.GetPicture(lcDisabledPicture)
			ENDIF
			this.Picture = lcPicture
			this.DisabledPicture = lcDisabledPicture
		ENDIF
	ENDPROC

ENDDEFINE

DEFINE CLASS tdatectrl AS ttext OF "main.vcx" 
 	*< CLASSDATA: Baseclass="textbox" Timestamp="" Scale="Pixels" Uniqueid="" />

	*<DefinedPropArrayMethod>
		*m: dropdown		&& Cit class DropDown method.
		*m: enabled_assign
		*m: positionbutton		&& Positions DropDown Button.
		*m: positionmonthview		&& Positions MonthView control.
		*m: readonly_assign
		*m: visible_assign
		*p: defvalue
		*p: ldatepickeractive
		*p: lusealwaysontopdatapicker		&& When .T., common\forms\_datepickerat.scx is called for calender. Use this, when calling calender from modal form.
		*p: oform
	*</DefinedPropArrayMethod>

	f = 10
	h = 1
	l = 0
	Name = "tdatectrl"
	oform = .NULL.
	t = 0
	w = 1
	
	PROCEDURE dropdown		&& Cit class DropDown method.
		IF NOT this.lDatePickerActive AND ocalendar AND (EMPTY(this.Value) OR (YEAR(this.Value) > 1752))&& ocalendar is global variable
			this.lDatePickerActive = .T.
			this.DefValue = SysDate()
			DO FORM "common\forms\_datepicker"+IIF(this.lUseAlwaysOnTopDataPicker, "at", "") WITH this
		ENDIF
	ENDPROC

	PROCEDURE enabled_assign
		LPARAMETERS lp_lNewVal
		LOCAL l_cButton
		
		this.Enabled = lp_lNewVal
		l_cButton = "this.Parent." + this.Name + "button"
		&l_cButton..Enabled = this.Enabled AND NOT this.ReadOnly
	ENDPROC

	PROCEDURE GotFocus
		LOCAL l_cButton
		
		l_cButton = this.Name + "button"
		this.Parent.&l_cButton..Refresh()
		DODEFAULT()
	ENDPROC

	PROCEDURE Init
		this.oForm = thisform
		this.w = this.Width
		this.h = this.Height
		this.f = this.FontSize
		this.t = this.Top
		this.l = this.Left
		TRY
			this.lUseAlwaysOnTopDataPicker = (thisform.WindowType = 1)
		CATCH
		ENDTRY
		this.ToolTipText = GetLangText("COMMON","TT_PRESS_CTRL_L")
		IF EMPTY(this.ControlSource) AND EMPTY(this.Value)
			this.Value = {}
		ENDIF
		IF ocalendar && ocalendar is global variable
			LOCAL l_cNewObj
			this.Parent.AddObject(this.Name + "button", "tCommandDropDown")
			this.positionbutton()
			l_cNewObj = "this.Parent." + this.Name + "button"
			WITH &l_cNewObj
				.TabStop = .F.
				.oParent = this
			ENDWITH
			this.ReadOnly = this.ReadOnly
			this.Enabled = this.Enabled
			this.Visible = this.Visible
		ENDIF
	ENDPROC

	PROCEDURE KeyPress
		LPARAMETERS nKeyCode, nShiftAltCtrl
		
		DO CASE
		 CASE (nKeyCode==12 AND nShiftAltCtrl==2) OR (nKeyCode==160 AND nShiftAltCtrl==4)
			this.DropDown()
		ENDCASE
	ENDPROC

	PROCEDURE positionbutton		&& Positions DropDown Button.
		LOCAL l_cButton, l_nButtonWith, l_nNumber
		l_cButton = "this.Parent." + this.Name + "button"
		l_nButtonWith = SYSMETRIC(5)
		WITH &l_cButton
			.Anchor = 0
			.Height = this.Height - 3
			.Left = this.Left + this.Width - l_nButtonWith - 2
			.Top = this.Top + 2
			.Width = l_nButtonWith
			.Anchor = this.Anchor
			IF NOT EMPTY(this.Tag) AND ISDIGIT(this.Tag)
				***********************************************************************
				*
				* Copy order of appereance of parent control into little button, but
				* make it to be last in order.
				*
				***********************************************************************
				l_nNumber = INT(VAL(this.Tag)) + 1000
				.Tag = TRANSFORM(l_nNumber)
			ENDIF
		ENDWITH
	ENDPROC

	PROCEDURE positionmonthview		&& Positions MonthView control.
	ENDPROC

	PROCEDURE readonly_assign
		LPARAMETERS lp_lNewVal
		LOCAL l_cButton
		
		this.ReadOnly = lp_lNewVal
		l_cButton = "this.Parent." + this.Name + "button"
		&l_cButton..Enabled = this.Enabled AND NOT this.ReadOnly
	ENDPROC

	PROCEDURE visible_assign
		LPARAMETERS lp_lNewVal
		LOCAL l_cButton
		
		this.Visible = lp_lNewVal
		l_cButton = "this.Parent." + this.Name + "button"
		IF TYPE(l_cButton) = "O"
			&l_cButton..Visible = lp_lNewVal
		ENDIF
	ENDPROC

ENDDEFINE

DEFINE CLASS teditbox AS editbox 
 	*< CLASSDATA: Baseclass="editbox" Timestamp="" Scale="Pixels" Uniqueid="" />

	*<DefinedPropArrayMethod>
		*p: ctooltiptext
		*p: f
		*p: h
		*p: l
		*p: ldontresize
		*p: nlineheight
		*p: resizefontsize
		*p: t
		*p: w
	*</DefinedPropArrayMethod>

	Height = 71
	ldontresize = .F.
	Name = "teditbox"
	nlineheight = 3
	resizefontsize = .T.
	Width = 100
	
	PROCEDURE Click
		IF PEMSTATUS(thisform, "HndClick", 5)
			thisform.HndClick(this)
		ENDIF
	ENDPROC

	PROCEDURE GotFocus
		IF PEMSTATUS(thisform, "HndGotFocus", 5)
			thisform.HndGotFocus(this)
		ENDIF
	ENDPROC

	PROCEDURE Init
		this.w=this.width
		this.h=this.height
		this.f=this.fontsize
		this.t=this.top
		this.l=this.left
	ENDPROC

	PROCEDURE InteractiveChange
		IF PEMSTATUS(thisform, "HndInteractiveChange", 5)
			thisform.HndInteractiveChange(this)
		ENDIF
	ENDPROC

	PROCEDURE LostFocus
		IF PEMSTATUS(thisform, "HndLostFocus", 5)
			thisform.HndLostFocus(this)
		ENDIF
	ENDPROC

	PROCEDURE MouseEnter
		LPARAMETERS nButton, nShift, nXCoord, nYCoord
		IF NOT EMPTY(this.ctooltiptext)
			FoxGUI_ShowToolTip(THIS, THISFORM, 0, 0, 0)
		ENDIF
		DODEFAULT()
	ENDPROC

	PROCEDURE Valid
		IF PEMSTATUS(thisform, "HndValid", 5)
			RETURN thisform.HndValid(this)
		ENDIF
	ENDPROC

	PROCEDURE When
		IF PEMSTATUS(thisform, "HndWhen", 5)
			RETURN thisform.HndWhen(this)
		ENDIF
	ENDPROC

ENDDEFINE

DEFINE CLASS tform AS form 
 	*< CLASSDATA: Baseclass="form" Timestamp="" Scale="Pixels" Uniqueid="" />

	#INCLUDE "..\include\constdefines.h"
	*<DefinedPropArrayMethod>
		*m: activatetoolbar
		*m: aligncontrols
		*m: assigncaption
		*m: controlrefresh
		*m: deactivatetoolbar
		*m: doeval		&& Use this method, to receive some value from form datasession. Example: omyform.DoEval("TRANSFORM(reservat.rs_rsid)")
		*m: findnext
		*m: findprev
		*m: formshandlerregister
		*m: hidetoolbar
		*m: hndclick
		*m: hndgotfocus
		*m: hndinteractivechange
		*m: hndlostfocus
		*m: hndvalid
		*m: hndwhen
		*m: msavegridwidths
		*m: msetgridwidths
		*m: onbottom
		*m: onclose
		*m: oncopy
		*m: ondelete
		*m: onedit
		*m: onfilter
		*m: onfirststart
		*m: onnew
		*m: onnext
		*m: onprevious
		*m: onprint
		*m: onrefresh
		*m: onsave
		*m: onsearch
		*m: onsearchmore
		*m: onselect
		*m: ontop
		*m: onundo
		*m: refreshgrids
		*m: resizeobjects
		*m: resizetdatectrl
		*m: resizetselectctrl
		*m: setfonfsize
		*m: setformsize
		*m: toolbardefinition
		*m: writeformsize
		*p: aligntopedges
		*p: aligntopedges_use_custom_order
		*p: cformlabel		&& Can be used as value for screens.sc_label
		*p: ctbrclass
		*p: doini		&& When Private Datassesion is used, use default enviroment settings
		*p: doiniopencommontables
		*p: doiniopenmainservertables
		*p: f
		*p: formname
		*p: h
		*p: l
		*p: lcaptionfit
		*p: ldontdisableformtoolbar		&& Used for modal forms. Set .T., when modal form has toolbar. This would prevent disabling toolbar, when form is shown.
		*p: ldontrefreshgrids
		*p: lmainserverform		&& When .T., don't add in form caption selected hotel name
		*p: lonfirstactivate		&& .T. when form started, and first time activate occured
		*p: lrefreshtoolbar
		*p: nmaxfont		&& Enter here maximal fontsize for all controls on form, when resizing
		*p: nminfont		&& Enter here minimal fontsize for all controls on form, when resizing
		*p: nmode
		*p: noldalwaysontop
		*p: ocallingobj
		*p: oscreens
		*p: resizeheaderfont
		*p: saveformsize		&& When .T., set form properties from screens table.
		*p: savegridwidths		&& When .T., try to set grid properties from grid table for all grids on the form.
		*p: sf
		*p: sh
		*p: sw
		*p: t
		*p: w
	*</DefinedPropArrayMethod>

	aligntopedges_use_custom_order = .F.
	AlwaysOnTop = .T.
	AutoCenter = .T.
	Caption = "Form1"
	cformlabel = 		&& Can be used as value for screens.sc_label
	ControlBox = .F.
	ctbrclass = 
	DoCreate = .T.
	Height = 405
	lrefreshtoolbar = .T.
	Name = "tform"
	nmaxfont = 48		&& Enter here maximal fontsize for all controls on form, when resizing
	nminfont = 4		&& Enter here minimal fontsize for all controls on form, when resizing
	noldalwaysontop = 0
	ocallingobj = .NULL.
	oscreens = .NULL.
	resizeheaderfont = .T.
	sf = 0
	Width = 380
	
	PROCEDURE Activate
		this.OnFirstStart()
		this.ActivateToolbar()
		ChildTitle(this.Caption + IIF(g_lDevelopment," {" + this.Name + "}",""))
		DODEFAULT()
	ENDPROC

	PROCEDURE activatetoolbar
		IF VARTYPE(goTbrQuick) = "O" AND this.lRefreshToolbar
			goTbrQuick.ChangeMode(TLB_VISIBLE, this)
		ENDIF
		IF VARTYPE(goTbrMain) = "O" AND this.lRefreshToolbar AND NOT EMPTY(this.cTbrClass) AND TYPE("_screen.ActiveForm") = "O" AND _screen.ActiveForm = this
			goTbrMain.ChangeMode(TLB_VISIBLE, this)
		ENDIF
	ENDPROC

	PROTECTED PROCEDURE aligncontrols
		LOCAL i, l_oControl, l_nLinesMoveUp, l_nMinHeight, l_oCol AS Collection
		LOCAL ARRAY l_aControls(1,1)
		
		l_nMinHeight = 0
		l_nLinesMoveUp = 0
		
		l_oCol = CREATEOBJECT("Collection")
		
		IF this.aligntopedges_use_custom_order
			***********************************************************************************
			*
			* In form is for every control entered order in Tag property. This order is used
			* to sort appereance of controls in form, instead of using ZOrderSet property.
			*
			***********************************************************************************
			i = 0
			FOR EACH l_oControl IN this.Controls FOXOBJECT
				IF TYPE("l_oControl.Tag") = "C" AND NOT EMPTY(l_oControl.Tag) AND ISDIGIT(l_oControl.Tag)
					i = i + 1
					DIMENSION l_aControls(i,2)
					l_aControls(i, 1) = INT(VAL(l_oControl.Tag))
					l_aControls(i, 2) = l_oControl
				ENDIF
			ENDFOR
			ASORT(l_aControls)
			FOR i = 1 TO ALEN(l_aControls,1)
				l_oCol.Add(l_aControls(i, 2))
			ENDFOR
		ELSE
			FOR EACH l_oControl IN this.Controls FOXOBJECT
				l_oCol.Add(l_oControl)
			ENDFOR
		ENDIF
		
		FOR EACH l_oControl IN l_oCol FOXOBJECT
			IF PEMSTATUS(l_oControl, "nLineHeight", 5) AND l_oControl.nLineHeight > 0 AND ;
					PEMSTATUS(l_oControl, "Visible", 5) AND NOT l_oControl.Visible
				l_nLinesMoveUp = l_nLinesMoveUp + l_oControl.nLineHeight
			ENDIF
		
			IF l_nLinesMoveUp > 0
				DO CASE
					CASE l_oControl.Class = "Tcommanddropdown" AND NOT ISNULL(l_oControl.oParent)
						l_oControl.oParent.PositionButton()
					CASE l_oControl.Class = "Cbobuilding" AND NOT ISNULL(l_oControl.oRoomTypeCombo)
						l_oControl.Top = l_oControl.oRoomTypeCombo.Top
					CASE l_oControl.Class = "Cmdselectbuilding" AND NOT ISNULL(l_oControl.oBuildingCombo)
						l_oControl.Top = l_oControl.oBuildingCombo.Top
					OTHERWISE
						IF PEMSTATUS(l_oControl, "Top", 5)
							l_oControl.Top = l_oControl.Top - 24 * l_nLinesMoveUp
						ENDIF
				ENDCASE
				IF PEMSTATUS(l_oControl, "t", 5)
					l_oControl.t  = l_oControl.Top
				ENDIF
			ENDIF
			IF PEMSTATUS(l_oControl, "Top", 5) AND PEMSTATUS(l_oControl, "Visible", 5) AND l_oControl.Visible
				l_nMinHeight = MAX(l_nMinHeight, l_oControl.Top + 40)
			ENDIF
		NEXT
		IF l_nLinesMoveUp > 0
			this.Height = MAX(l_nMinHeight, this.Height - 24 * l_nLinesMoveUp)
		ENDIF
	ENDPROC

	PROCEDURE assigncaption
	ENDPROC

	PROCEDURE controlrefresh
		LOCAL l_oActiveControl
		l_oActiveControl = .NULL.
		IF TYPE("this.ActiveControl") = "O"
			TRY
				l_oActiveControl = this.ActiveControl
			CATCH
			ENDTRY
			IF NOT ISNULL(l_oActiveControl)
				IF PEMSTATUS(l_oActiveControl, "LostFocus", 5)
					l_oActiveControl.LostFocus()
				ENDIF
				IF PEMSTATUS(l_oActiveControl, "SetFocus", 5)
					l_oActiveControl.SetFocus()
				ENDIF
			ENDIF
		ENDIF
	ENDPROC

	PROCEDURE Deactivate
		this.DeactivateToolbar()
		DODEFAULT()
	ENDPROC

	PROCEDURE deactivatetoolbar
		IF VARTYPE(goTbrQuick) = "O" AND this.lRefreshToolbar
			goTbrQuick.ChangeMode(TLB_VISIBLE)
		ENDIF
		IF VARTYPE(goTbrMain) = "O" AND this.lRefreshToolbar AND NOT EMPTY(this.cTbrClass)
			goTbrMain.ChangeMode(TLB_DISABLE, this)
		ENDIF
	ENDPROC

	PROCEDURE Destroy
		this.writeformsize()
		
		* When calling report preview, text from message bar in main screen is deleted.
		* Here we check when _vfp.StatusBar is empty, then set it to right text.
		IF EMPTY(_vfp.StatusBar) AND TYPE("g_Hotel")<>"U" AND NOT EMPTY(g_Hotel)
			SetStatusBarMessage()
		ENDIF
	ENDPROC

	PROCEDURE doeval		&& Use this method, to receive some value from form datasession. Example: omyform.DoEval("TRANSFORM(reservat.rs_rsid)")
		LPARAMETERS lp_cMacro, lp_lNoResult, lp_uParam1, lp_uParam2, lp_uParam3, lp_uParam4, lp_uParam5
		LOCAL l_cResult, l_oError
		
		l_cResult = ""
		l_oError = .NULL.
		IF lp_lNoResult
			TRY
				&lp_cMacro
			CATCH TO l_oError
			ENDTRY
		ELSE
			TRY
				l_cResult = &lp_cMacro
			CATCH TO l_oError
			ENDTRY
		ENDIF
		
		RETURN l_cResult
	ENDPROC

	PROCEDURE findnext
	ENDPROC

	PROCEDURE findprev
	ENDPROC

	PROCEDURE formshandlerregister
		IF TYPE("_screen.oGlobal.oFormsHandler")="O"
			_screen.oGlobal.oFormsHandler.FormAdd(this)
		ENDIF
	ENDPROC

	PROCEDURE GotFocus
		this.RefreshGrids()
		DODEFAULT()
	ENDPROC

	PROCEDURE hidetoolbar
		IF VARTYPE(goTbrQuick) = "O" AND this.lRefreshToolbar
			goTbrQuick.ChangeMode(TLB_VISIBLE)
		ENDIF
		IF VARTYPE(goTbrMain) = "O" AND this.lRefreshToolbar AND NOT EMPTY(this.cTbrClass)
			goTbrMain.ChangeMode(TLB_INVISIBLE, this)
		ENDIF
	ENDPROC

	PROCEDURE hndclick
		LPARAMETERS toControl
	ENDPROC

	PROCEDURE hndgotfocus
		LPARAMETERS toControl
	ENDPROC

	PROCEDURE hndinteractivechange
		LPARAMETERS toControl
	ENDPROC

	PROCEDURE hndlostfocus
		LPARAMETERS toControl
	ENDPROC

	PROCEDURE hndvalid
		LPARAMETERS toControl
		
		RETURN .T.
	ENDPROC

	PROCEDURE hndwhen
		LPARAMETERS toControl
		
		RETURN .T.
	ENDPROC

	PROCEDURE Init
		IF TYPE("glTraining")="L" AND glTraining
			this.BackColor = RGB(255,255,128)
		ENDIF
		IF this.AlignTopEdges
			this.AlignControls()
		ENDIF
		this.w=this.Width
		this.h=this.Height
		this.l=this.Left
		this.t=this.Top
		this.f=this.FontSize
		thisform.setformsize
		*THIS.assigncaption
		this.ToolbarDefinition()
	ENDPROC

	PROCEDURE KeyPress
		LPARAMETERS nKeyCode, nShiftAltCtrl
		LOCAL llDone
		IF EMPTY(this.cTbrClass)
			IF nKeyCode = 27
				this.Visible = .F.
			ENDIF
		ELSE
			llDone = this.TbrCtrl.KeyPress(nKeyCode, nShiftAltCtrl)
		ENDIF
		
		RETURN llDone
	ENDPROC

	PROCEDURE Load
		IF this.doini
			IF TYPE("this.DataEnvironment") = "O" AND NOT ISNULL(this.DataEnvironment)
				ini(this.DoIniOpenCommonTables, this.DoIniOpenMainServerTables, this.DataEnvironment, this.lMainServerForm)
			ELSE
				ini(this.DoIniOpenCommonTables, this.DoIniOpenMainServerTables,,this.lMainServerForm)
			ENDIF
		ENDIF
		this.FormsHandlerRegister()
		IF this.AutoCenter
			this.AutoCenter = _screen.oGlobal.lautocenterforms
		ENDIF
	ENDPROC

	PROCEDURE msavegridwidths
		LPARAMETERS toControl
		LOCAL loControl, lGridDontRefresh
		
		IF PCOUNT() = 0
			toControl = this
		ENDIF
		
		DO CASE
			CASE NOT this.SaveGridWidths
			CASE TYPE("toControl.BaseClass") <> "C"
			CASE toControl.BaseClass == "Grid"
				lGridDontRefresh = .F.
				FOR EACH loControl IN toControl.Columns FOXOBJECT
					toControl.SaveState(loControl, lGridDontRefresh)
					lGridDontRefresh = .T.
				NEXT
			CASE toControl.BaseClass == "Pageframe"
				FOR EACH loControl IN toControl.Pages FOXOBJECT
					this.mSaveGridWidths(loControl)
				NEXT
			CASE INLIST(toControl.BaseClass, "Form", "Page", "Container", "Control")
				FOR EACH loControl IN toControl.Controls FOXOBJECT
					this.mSaveGridWidths(loControl)
				NEXT
		ENDCASE
	ENDPROC

	PROCEDURE msetgridwidths
		LPARAMETERS toControl
		LOCAL loControl, lGridDontRefresh
		
		IF PCOUNT() = 0
			toControl = this
		ENDIF
		
		DO CASE
			CASE NOT this.SaveGridWidths
			CASE TYPE("toControl.BaseClass") <> "C"
			CASE toControl.BaseClass == "Grid"
				lGridDontRefresh = .F.
				FOR EACH loControl IN toControl.Columns FOXOBJECT
					toControl.RestoreState(loControl, lGridDontRefresh)
					lGridDontRefresh = .T.
				NEXT
			CASE toControl.BaseClass == "Pageframe"
				FOR EACH loControl IN toControl.Pages FOXOBJECT
					this.mSetGridWidths(loControl)
				NEXT
			CASE INLIST(toControl.BaseClass, "Form", "Page", "Container", "Control")
				FOR EACH loControl IN toControl.Controls FOXOBJECT
					this.mSetGridWidths(loControl)
				NEXT
		ENDCASE
	ENDPROC

	PROCEDURE onbottom
	ENDPROC

	PROCEDURE onclose
	ENDPROC

	PROCEDURE oncopy
	ENDPROC

	PROCEDURE ondelete
	ENDPROC

	PROCEDURE onedit
	ENDPROC

	PROCEDURE onfilter
	ENDPROC

	PROCEDURE onfirststart
		IF NOT this.lOnFirstActivate
			this.lOnFirstActivate = .T.
		*!*		IF TYPE("_screen.oGlobal.oFormsHandler")="O"
		*!*			_screen.oGlobal.oFormsHandler.FormRefreshCaption(this)
		*!*		ENDIF
		ENDIF
	ENDPROC

	PROCEDURE onnew
	ENDPROC

	PROCEDURE onnext
	ENDPROC

	PROCEDURE onprevious
	ENDPROC

	PROCEDURE onprint
	ENDPROC

	PROCEDURE onrefresh
		LPARAMETERS toControl
		LOCAL loControl
		
		IF PCOUNT() = 0
			toControl = this
		ENDIF
		IF LOWER(toControl.BaseClass) == "form" OR LOWER(toControl.BaseClass) == "page"
			*********** Pages must be refreshed explicitly too ************
			toControl.Refresh()
		ENDIF
		
		DO CASE
			CASE INLIST(LOWER(toControl.Class), "mltooltip")
				* Don't refresh objects of classes above.
			CASE INLIST(LOWER(toControl.BaseClass), "form", "container", "control", "toolbar") OR LOWER(toControl.BaseClass) == "page"
				FOR EACH loControl IN toControl.Controls
					tform::OnRefresh(loControl)
				NEXT
			CASE LOWER(toControl.BaseClass) == "pageframe"
				FOR EACH loControl IN toControl.Pages
					tform::OnRefresh(loControl)
				NEXT
			CASE INLIST(LOWER(toControl.BaseClass), "commandgroup", "optiongroup")
				FOR EACH loControl IN toControl.Buttons
					tform::OnRefresh(loControl)
				NEXT
		ENDCASE
	ENDPROC

	PROCEDURE onsave
	ENDPROC

	PROCEDURE onsearch
	ENDPROC

	PROCEDURE onsearchmore
	ENDPROC

	PROCEDURE onselect
	ENDPROC

	PROCEDURE ontop
	ENDPROC

	PROCEDURE onundo
	ENDPROC

	PROCEDURE refreshgrids
		IF this.ldontrefreshgrids
			RETURN .T.
		ENDIF
		
		LOCAL l_oCtrl, l_oPage, l_oPageCtrl
		FOR EACH l_oCtrl IN this.Controls
			DO CASE
				CASE LOWER(l_oCtrl.BaseClass) = "pageframe"
					FOR EACH l_oPage IN l_oCtrl.Pages
						FOR EACH l_oPageCtrl IN l_oPage.Controls
							IF LOWER(l_oPageCtrl.BaseClass) = "grid" AND PEMSTATUS(l_oPageCtrl, "refreshsortcursor", 5)
								l_oPageCtrl.RefreshSortCursor()
							ENDIF
						ENDFOR
					ENDFOR
				CASE LOWER(l_oCtrl.BaseClass) = "grid" AND PEMSTATUS(l_oCtrl, "refreshsortcursor", 5)
					l_oCtrl.RefreshSortCursor()
			ENDCASE
		ENDFOR
	ENDPROC

	PROCEDURE Resize
		LPARAMETERS nwidth,nheight
		Local loControl
		
		IF this.Height < 80 OR TYPE("This.w") <> "N" OR TYPE("This.h") <> "N"
			RETURN
		ENDIF
		
		THIS.LockScreen= .T.
		
		IF this.WindowState= 1
			IF this.Visible
				this.nOldAlwaysOnTop = IIF(this.AlwaysOnTop, 2, 1)
				this.AlwaysOnTop = .T.
				IF TYPE("_screen.oGlobal.oFormsHandler")="O"
					_screen.oGlobal.oFormsHandler.AddToTab(this.HWnd)
				ENDIF
			ENDIF
		ELSE
			DO CASE
				CASE this.nOldAlwaysOnTop = 0
				CASE this.nOldAlwaysOnTop = 1
					this.AlwaysOnTop = .F.
					this.nOldAlwaysOnTop = 0
				CASE this.nOldAlwaysOnTop = 2
					this.AlwaysOnTop = .T.
					this.nOldAlwaysOnTop = 0
			ENDCASE
		ENDIF
		
		IF PCOUNT()=2
			IF TYPE("nwidth") = "N" and TYPE("nheight") = "N"
				this.sw=nwidth/This.w
				this.sh=nheight/This.h
			ELSE
				this.sw=This.Width/This.w
				this.sh=This.Height/This.h
			ENDIF
		else
			this.sw=This.Width/This.w
			this.sh=This.Height/This.h
		endif
		
		FOR EACH loControl IN this.Controls FOXOBJECT
			this.resizeobjects(loControl)
		NEXT
		this.setfonfsize()
		
		THIS.LockScreen=.F.
		THIS.Refresh
	ENDPROC

	PROCEDURE resizeobjects
		Parameters toControl
		LOCAL j, loControl, llDontResize, lnOldScaleWidth, lnOldScaleHeight, lnOldWidth, lnFormFontSize
		
		Do Case
		Case Upper(toControl.Class) = "TDATECTRL"
			this.resizetdatectrl(toControl)
		Case Upper(toControl.Class) = "TSELECTCTRL"
			this.resizetselectctrl(toControl)
		Case Upper(toControl.Class) = "TCOMMANDDROPDOWN"
			* Don't resize this control. TDateCtrl will do that job.
		Case Upper(toControl.Class) = "REVENUEPAGE"
			* Don't resize this control. It has own resize.
		Case Inlist(Upper(toControl.Name), "FOXCHARTS", "FOXCHARTSTOOLTIP")
			* Don't resize this control. Generated by FoxCharts.
		Case Inlist(Upper(toControl.BaseClass),"LABEL","TEXTBOX","CHECKBOX","EDITBOX","SPINNER")
			With toControl
				llDontResize = .F.
				TRY
					llDontResize = .ldontresize
				CATCH
				ENDTRY
				IF NOT llDontResize
					.Left=Round(.l*This.sw,0)
					.Width=Round(.w*This.sw,0)
					.Height=Round(.h*This.sh,0)
					.Top=Round(.T*This.sh,0)
				ENDIF
				IF .resizefontsize
					IF this.lCaptionFit AND Inlist(Upper(.BaseClass),"LABEL","CHECKBOX") AND NOT .AutoSize
						this.sf = EVL(this.sf,this.nmaxfont/.F)
						lnFormFontSize = this.FontSize
						this.FontSize = MIN(MAX(INT(.Height*.8), Round(.F*this.sf,0), this.nminfont), this.nmaxfont)
						DO WHILE this.TextWidth(.Caption) > .Width AND this.FontSize > this.nminfont
							this.FontSize = this.FontSize - 1
						ENDDO
						this.sf = MIN(this.sf,this.FontSize/.F)
						this.FontSize = lnFormFontSize
					ELSE
						.FontSize=MIN(MAX(Round(.F*This.sh,0),this.nminfont),this.nmaxfont)
					ENDIF
				ELSE
					*.FontSize=IIF(Max(Round(.F*This.sh,0),4)<.FontSize,Max(Round(.F*This.sh,0),4),MAX(.FontSize,9))
				ENDIF
			Endwith
		Case Upper(toControl.BaseClass) = "COMMANDBUTTON"
			With toControl
				IF NOT .lDontResize
					.Left=Round(.l*This.sw,0)
					.Width=Round(.w*This.sw,0)
					.Height=Round(.h*This.sh,0)
					.Top=Round(.T*This.sh,0)
				ENDIF
				IF .resizefontsize
					.FontSize=MIN(MAX(Round(.F*This.sh,0),this.nminfont),this.nmaxfont)
				ELSE
					.FontSize=IIF(Max(Round(.F*This.sh,0),4)<.FontSize,Max(Round(.F*This.sh,0),4),MAX(.FontSize,9))
				ENDIF
			Endwith
		Case Inlist(Upper(toControl.BaseClass),"COMBOBOX","LISTBOX")
			With toControl
				.Left=Round(.l*This.sw,0)
				.Width=Round(.w*This.sw,0)
				.Height=Round(.h*This.sh,0)
				.Top=Round(.T*This.sh,0)
				IF .resizefontsize
					.FontSize=MIN(MAX(Round(.F*This.sh,0),this.nminfont),this.nmaxfont)
				ELSE
					.FontSize=IIF(Max(Round(.F*This.sh,0),4)<.FontSize,Max(Round(.F*This.sh,0),4),MAX(.FontSize,9))
				ENDIF
				If .ColumnCount>0
					lccw=''
					For k=1 To Alen(.cw)
						lccw=lccw+Iif(k=Alen(.cw),Alltrim(Str(Round(.cw(k)*This.sw,0))),Alltrim(Str(Round(.cw(k)*This.sw,0)))+',')
					Next
					.ColumnWidths=lccw
				Endif
			Endwith
		Case Inlist(Upper(toControl.BaseClass),"OPTIONGROUP")
			With toControl
				.Width=Round(.w*This.sw,0)
				.Height=Round(.h*This.sh,0)
				.Left=Round(.l*This.sw,0)
				.Top=Round(.T*This.sh,0)
				lnFormFontSize = this.FontSize
				For k=1 To MIN(.ButtonCount, Alen(.bw))
					.Buttons(k).Left=Round(.bl(k)*This.sw,0)
					.Buttons(k).Top=Round(.bT(k)*This.sh,0)
					.Buttons(k).Width=Round(.bw(k)*This.sw,0)
					.Buttons(k).Height=Round(.bh(k)*This.sh,0)
					IF this.lCaptionFit AND .resizefontsize AND NOT .Buttons(k).AutoSize
						this.sf = EVL(this.sf,this.nmaxfont/.bF(k))
						this.FontSize = MIN(MAX(INT(.Buttons(k).Height*.8), Round(.bF(k)*this.sf,0), this.nminfont), this.nmaxfont)
						DO WHILE this.TextWidth(.Buttons(k).Caption) > .Buttons(k).Width AND this.FontSize > this.nminfont
							this.FontSize = this.FontSize - 1
						ENDDO
						this.sf = MIN(this.sf,this.FontSize/.bF(k))
						*.Buttons(k).FontSize=Max(Round(.bF(k)*This.sh,0),4)
					ELSE
						*.Buttons(k).FontSize=IIF(Max(Round(.bF(k)*This.sh,0),4)<.Buttons(k).FontSize,Max(Round(.bF(k)*This.sh,0),4),MAX(.Buttons(k).FontSize,9))
						.Buttons(k).FontSize=MIN(MAX(Round(.bF(k)*This.sh,0),this.nminfont),this.nmaxfont)
					ENDIF
				Next
				this.FontSize = lnFormFontSize
			Endwith
		Case .f.&&Inlist(Upper(toControl.BaseClass),"CONTAINER")
			With toControl
				.Left=Round(.l*This.sw,0)
				.Width=Round(.w*This.sw,0)
				.Height=Round(.h*This.sh,0)
				.Top=Round(.T*This.sh,0)
				For j=1 To .ControlCount
					With .Controls(j)
						.Left=Round(.l*This.sw,0)
						.Width=Round(.w*This.sw,0)
						.Height=Round(.h*This.sh,0)
						.Top=Round(.T*This.sh,0)
						If Type('.fontsize')='N'
							.FontSize=MIN(MAX(Round(.F*This.sh,0),this.nminfont),this.nmaxfont)
						Endif
					Endwith
				Next
			Endwith
		
		Case Inlist(Upper(toControl.BaseClass),"LINE","SHAPE","IMAGE")
			With toControl
				.Left=Round(.l*This.sw,0)
				.Width=Round(.w*This.sw,0)
				.Height=Round(.h*This.sh,0)
				.Top=Round(.T*This.sh,0)
			Endw
		Case Inlist(Upper(toControl.BaseClass),"FORM")
			With toControl
				.FontSize=MIN(MAX(Round(.F*This.sh,0),this.nminfont),this.nmaxfont)
			Endwith
		Case Inlist(Upper(toControl.BaseClass),"GRID")
			With toControl
				.Left=Round(.l*This.sw,0)
				lnOldWidth = .Width
				.Width=MAX(19,Round(.w*This.sw,0))
				.Height=MAX(20,Round(.h*This.sh,0))
				.Top=Round(.T*This.sh,0)
				For k=1 To .ColumnCount
					IF .resizefontsize
						.Columns(k).FontSize=MIN(MAX(Round(.F*This.sh,0),this.nminfont),this.nmaxfont)
					ENDIF
					IF thisform.resizeheaderfont OR .resizeheaderfont
						FOR l=1 TO .columns(k).controlcount
							IF INLIST(UPPER(ALLTRIM(.columns(k).controls(l).baseclass)),'HEADER','TEXTBOX','COMBOBOX')
								IF .resizefontsize
									.columns(k).controls(l).FontSize=MIN(MAX(Round(.F*This.sh,0),this.nminfont),this.nmaxfont)
								ELSE
									.columns(k).controls(l).FontSize=;
									IIF(Max(Round(.F*This.sh,0),4)<.columns(k).controls(l).FontSize,Max(Round(.F*This.sh,0),4),MAX(.columns(k).controls(l).FontSize,9))
								ENDIF
							endif
						NEXT
					ELSE
						FOR l=1 TO .columns(k).controlcount
							IF INLIST(UPPER(ALLTRIM(.columns(k).controls(l).baseclass)),'TEXTBOX','COMBOBOX')
								IF .resizefontsize
									.columns(k).controls(l).FontSize=MIN(MAX(Round(.F*This.sh,0),this.nminfont),this.nmaxfont)
								ENDIF
							endif
						NEXT
					ENDIF
				Next
				IF .resizefontsize
					.RowHeight=Round(.rh*This.sh,0)
					.HeaderHeight=Round(.hh*This.sh,0)
				ENDIF
				If .lresizecolumns
					For k=1 To .ColumnCount
						.Columns(k).cw = IIF(ABS(.Columns(k).Width - .Columns(k).cw) > 1, .Columns(k).Width, .Columns(k).cw) * (.Width-17) / (lnOldWidth-17)
						.Columns(k).Width = ROUND(.Columns(k).cw,0)
					Next
				Endif
			Endwith
		Case Inlist(Upper(toControl.BaseClass),"PAGEFRAME")
			With toControl
				* Fonts must be resized first because it affects on height of page tab and then affects on PageHeight.
				For j=1 To Alen(.pf)
					.Pages(j).FontSize=Max(Round(.pf(j)*This.sh,0),4)
				Next
				.Left=Round(.l*This.sw,0)
				.Width=Round(.w*This.sw,0)
				.Height=Round((.h-SYSMETRIC(9))*This.sh,0)+SYSMETRIC(9)
				.Top=Round(.T*This.sh,0)
				lnOldScaleWidth = this.sw
				lnOldScaleHeight = this.sh
				this.sw = .PageWidth / .pw
				this.sh = .PageHeight / .ph
				For j=1 To Alen(.pf)
					FOR EACH loControl IN .Pages(j).Controls FOXOBJECT
						this.resizeobjects(loControl)
					NEXT
				Next
				this.sw = lnOldScaleWidth
				this.sh = lnOldScaleHeight
			Endw
		Case Upper(toControl.BaseClass) = "OLEBOUNDCONTROL"
			With toControl
				.Left=Round(.l*This.sw,0)
				.Width=Round(.w*This.sw,0)
				.Height=Round(.h*This.sh,0)
				.Top=Round(.T*This.sh,0)
			ENDWITH
		Case Upper(toControl.BaseClass) = "OLECONTROL"	AND (Upper(toControl.Class) = "TOLETREE" OR Upper(toControl.Tag)="RESIZE_IT")
			With toControl
				.Left=Round(.l*This.sw,0)
				.Width=Round(.w*This.sw,0)
				.Height=Round(.h*This.sh,0)
				.Top=Round(.T*This.sh,0)
			ENDWITH
		Endcase
		
	ENDPROC

	PROCEDURE resizetdatectrl
		LPARAMETERS lp_oObj
		With lp_oObj
			.Left=Round(.l*This.sw,0)
			.Width=Round(.w*This.sw,0)
			.Height=Round(.h*This.sh,0)
			.Top=Round(.T*This.sh,0)
			IF .resizefontsize
				.FontSize=Max(Round(.F*This.sh,0),4)
			ELSE
				.FontSize=IIF(Max(Round(.F*This.sh,0),4)<.FontSize,Max(Round(.F*This.sh,0),4),MAX(.FontSize,9))
			ENDIF
			.PositionButton()
		ENDWITH
	ENDPROC

	PROCEDURE resizetselectctrl
		LPARAMETERS lp_oObj
		With lp_oObj
			.Left=Round(.l*This.sw,0)
			.Width=Round(.w*This.sw,0)
			.Height=Round(.h*This.sh,0)
			.Top=Round(.T*This.sh,0)
			IF .resizefontsize
				.FontSize=Max(Round(.F*This.sh,0),4)
			ELSE
				.FontSize=IIF(Max(Round(.F*This.sh,0),4)<.FontSize,Max(Round(.F*This.sh,0),4),MAX(.FontSize,9))
			ENDIF
			.PositionButton()
		ENDWITH
	ENDPROC

	PROCEDURE setfonfsize
		LPARAMETERS toControl
		LOCAL k, loControl
		
		IF PCOUNT() = 0
			toControl = this
		ENDIF
		
		DO CASE
			CASE this.sf = 0
			CASE TYPE("toControl.BaseClass") <> "C"
			CASE INLIST(toControl.BaseClass, "Label", "Checkbox")
				toControl.FontSize = MIN(MAX(ROUND(toControl.F*this.sf,0),this.nminfont), this.nmaxfont)
			CASE toControl.BaseClass = "Optiongroup"
				FOR k = 1 TO MIN(toControl.ButtonCount, ALEN(toControl.bw))
					toControl.Buttons(k).FontSize = MIN(MAX(ROUND(toControl.bf(k)*this.sf,0),this.nminfont), this.nmaxfont)
				NEXT
			CASE toControl.BaseClass == "Pageframe"
				FOR EACH loControl IN toControl.Pages FOXOBJECT
					this.SetFonfsize(loControl)
				NEXT
			CASE INLIST(toControl.BaseClass, "Form", "Page", "Container", "Control")
				FOR EACH loControl IN toControl.Controls FOXOBJECT
					this.SetFonfsize(loControl)
				NEXT
		ENDCASE
		
		IF toControl = this
			this.sf = 0
		ENDIF
	ENDPROC

	PROCEDURE setformsize
		LPARAMETERS tlDontResize, tlDontRefresh, tlNoWhRatio
		
		this.mSetGridWidths()
		
		_screen.oGlobal.Screen_RestoreState(this, tlDontResize, tlDontRefresh, tlNoWhRatio)
	ENDPROC

	PROCEDURE toolbardefinition
		IF NOT EMPTY(this.cTbrClass)
			IF NOT PEMSTATUS(this,"TbrCtrl",5)
				this.AddObject("TbrCtrl", this.cTbrClass)
			ENDIF
		ENDIF
	ENDPROC

	PROCEDURE Unload
		IF this.lOnFirstActivate
			this.HideToolbar()
			ChildTitle("")
		ENDIF
		IF VARTYPE(this.oCallingObj) = "O"
			this.oCallingObj.Enabled = .T.
		ENDIF
		DODEFAULT()
	ENDPROC

	PROCEDURE writeformsize
		_screen.oGlobal.Screen_SaveState(this)
		
		this.mSaveGridWidths()
	ENDPROC

ENDDEFINE

DEFINE CLASS tformcommon AS tform OF "main.vcx" 
 	*< CLASSDATA: Baseclass="form" Timestamp="" Scale="Pixels" Uniqueid="" />

	*<DefinedPropArrayMethod>
		*m: activatebeforefirsttime
		*m: setcontrolsource
		*p: lactivatefirsttime
		*p: lusecommonshortcuts		&& When .T., use ctrl+S for onsave, ctrl+D + ondelete, ctrl+E for edit, ctrl+N for onnew
	*</DefinedPropArrayMethod>

	PROTECTED lactivatefirsttime
	AlwaysOnTop = .F.
	ControlBox = .T.
	DataSession = 2
	DoCreate = .T.
	doini = .T.
	doiniopencommontables = .T.
	Icon = ..\bitmap\icons\browse16.ico
	lusecommonshortcuts = .T.		&& When .T., use ctrl+S for onsave, ctrl+D + ondelete, ctrl+E for edit, ctrl+N for onnew
	Name = "tformcommon"
	saveformsize = .T.
	savegridwidths = .T.
	
	PROCEDURE Activate
		IF NOT this.lActivateFirstTime
			this.lActivateFirstTime = .T.
			this.ActivateBeforeFirstTime()
		ENDIF
		DODEFAULT()
	ENDPROC

	PROCEDURE activatebeforefirsttime
	ENDPROC

	PROCEDURE Init
		DODEFAULT()
		
		this.AssignCaption()
		this.SetControlSource()
	ENDPROC

	PROCEDURE KeyPress
		LPARAMETERS nKeyCode, nShiftAltCtrl
		
		DO CASE
			CASE NOT this.lUseCommonShortcuts
				DODEFAULT(nKeyCode, nShiftAltCtrl)
			CASE nKeyCode = 27 AND nShiftAltCtrl = 0
				NODEFAULT
				this.OnClose()
			CASE nKeyCode = 5 AND nShiftAltCtrl = 2		&& Ctrl+E
				NODEFAULT
				this.OnEdit()
			CASE nKeyCode = 14 AND nShiftAltCtrl = 2	&& Ctrl+N
				NODEFAULT
				this.OnNew()
			CASE nKeyCode = 4 AND nShiftAltCtrl = 2		&& Ctrl+D
				NODEFAULT
				this.OnDelete()
			CASE nKeyCode = 19 AND nShiftAltCtrl = 2	&& Ctrl+S
				NODEFAULT
				this.OnSave()
			CASE nKeyCode = 141 AND nShiftAltCtrl = 2	&& Ctrl+UP ARROW
				NODEFAULT
				this.OnPrevious()
			CASE nKeyCode = 145 AND nShiftAltCtrl = 2	&& Ctrl+DOWN ARROW
				NODEFAULT
				this.OnNext()
			CASE nKeyCode = 29 AND nShiftAltCtrl = 2	&& Ctrl+HOME
				NODEFAULT
				this.OnTop()
			CASE nKeyCode = 23 AND nShiftAltCtrl = 2	&& Ctrl+END
				NODEFAULT
				this.OnBottom()
			OTHERWISE
				DODEFAULT(nKeyCode, nShiftAltCtrl)
		ENDCASE
	ENDPROC

	PROCEDURE onclose
		this.Release()
	ENDPROC

	PROCEDURE QueryUnload
		NODEFAULT
		this.OnClose()
	ENDPROC

	PROCEDURE setcontrolsource
	ENDPROC

ENDDEFINE

DEFINE CLASS tgrid AS grid 
 	*< CLASSDATA: Baseclass="grid" Timestamp="" Scale="Pixels" Uniqueid="" />

	#INCLUDE "..\include\constdefines.h"
	*<DefinedPropArrayMethod>
		*m: changecolumnorder
		*m: columncount_assign
		*m: defaultpropertiesset
		*m: defineudpopupmenu
		*m: deletecolumnobj
		*m: doudcolumnpopupmenu
		*m: getgridlabel
		*m: getposition
		*m: headerheight_assign
		*m: m_setgriddynamiccolor
		*m: popupcolumnmenu
		*m: recordsource_assign
		*m: refreshsortcursor
		*m: removefocusfromgrid
		*m: restorecolumn
		*m: restorestate		&& Restores its state from Grid table.
		*m: savestate		&& Saves its state to Grid table.
		*m: selectedisfirst		&& Currently selected record is set to be in first row in Grid
		*m: setcolumnproperty
		*p: ccommandtoremovefocus		&& Used by method selectedisfirst, to execute and remove focus from grid
		*p: cdefaultpropertiessetgridcursor
		*p: cgriddynamicbackcolor
		*p: cgridlabelname		&& Used as name of grid in grid.gr_label field.
		*p: ctooltiptext
		*p: f
		*p: h
		*p: hh
		*p: l
		*p: labout2leavegrid
		*p: ladduserdefinedcolumns
		*p: lgetmouseposition
		*p: lnotusesortcursor
		*p: lresizecolumns		&& When .T., resize column when form is resizing.
		*p: lsetgridprop		&& When .T., set grid properties from gridprop table.
		*p: luseudcolumnpopupmenu
		*p: luseudpopupmenu
		*p: ngridcol
		*p: ngridrow
		*p: nrecno
		*p: resizefontsize		&& Resize Font in Grid .T./.F.
		*p: resizeheaderfont
		*p: rh
		*p: savegridpropdone
		*p: savegridsettings		&& When .T., Grid and column properties are saved to grid table
		*p: setcolumns		&& When .T., synchrinize grid properties on init. with settings saved in grid table.
		*p: t
		*p: toprow
		*p: w
		*a: acolumnpopupmenu[1,0]
		*a: apopupmenu[1,0]
	*</DefinedPropArrayMethod>

	ccommandtoremovefocus = 		&& Used by method selectedisfirst, to execute and remove focus from grid
	cdefaultpropertiessetgridcursor = 
	cgriddynamicbackcolor = 
	cgridlabelname = 		&& Used as name of grid in grid.gr_label field.
	ColumnCount = -1
	GridLineColor = 192,192,192
	Height = 200
	HighlightBackColor = 10,36,106
	HighlightStyle = 2
	lresizecolumns = .T.		&& When .T., resize column when form is resizing.
	lsetgridprop = .T.		&& When .T., set grid properties from gridprop table.
	Name = "tgrid"
	ngridcol = 0
	ngridrow = 0
	RecordMark = .F.
	resizefontsize = .T.		&& Resize Font in Grid .T./.F.
	savegridsettings = .T.		&& When .T., Grid and column properties are saved to grid table
	toprow = 0
	Width = 320
	
	PROCEDURE changecolumnorder
		LPARAMETERS toColumn, tnColumnOrder
		LOCAL i, lnOldColumnOrder
		
		IF NOT EMPTY(tnColumnOrder) AND toColumn.ColumnOrder <> tnColumnOrder
			lnOldColumnOrder = toColumn.ColumnOrder
			FOR i = lnOldColumnOrder TO tnColumnOrder STEP SIGN(tnColumnOrder-lnOldColumnOrder)
				toColumn.ColumnOrder = i
			NEXT
		ENDIF
	ENDPROC

	PROCEDURE columncount_assign
		LPARAMETERS tnNewVal
		*To do: Modify this routine for the Assign method
		this.ColumnCount = tnNewVal
	ENDPROC

	PROCEDURE DblClick
		DO CASE
			CASE TYPE("thisformset") = "O"
				_screen.oProcessHandler(ALLTRIM(STR(P_EDIT))).Execute(thisformset, "GridDblClick")
			CASE TYPE("thisform") = "O"
				_screen.oProcessHandler(ALLTRIM(STR(P_EDIT))).Execute(thisform, "GridDblClick")
		ENDCASE
	ENDPROC

	PROCEDURE defaultpropertiesset
		LPARAMETERS tnColumn, tcField, tuValue
		LOCAL llOK
		
		IF VARTYPE(tnColumn) = "N" AND NOT ISNULL(_screen.oGlobal.Grid_GetColumnProperty(this, this.Columns(tnColumn), tcField))
			TRY
				this.Columns(tnColumn).AddProperty("l"+STRTRAN(tcField,"gr_"), tuValue)
			CATCH
			ENDTRY
			llOK = .T.
		ENDIF
		
		RETURN llOK
	ENDPROC

	PROCEDURE defineudpopupmenu
	ENDPROC

	PROCEDURE deletecolumnobj
		LPARAMETERS lp_oColumnObject
		
		lp_oColumnObject.Parent.DeleteColumn(lp_oColumnObject.ColumnOrder)
		
	ENDPROC

	PROCEDURE Destroy
		_screen.oGlobal.Grid_SaveProp(thisform, this)
		
		DODEFAULT()
	ENDPROC

	PROCEDURE doudcolumnpopupmenu
		LPARAMETERS tnColumnNo
	ENDPROC

	PROCEDURE getgridlabel
		IF EMPTY(this.cgridlabelname)
			this.cgridlabelname = this.Name
		ENDIF
		RETURN this.cgridlabelname
	ENDPROC

	PROCEDURE getposition
		LPARAMETERS nXCoord_In, nYCoord_In, nRelRow_Out, nRelCol_Out
		LOCAL nWhere_Out, nView_Out
		LOCAL lnArea, lnRecno
		
		* GridHitTest method probably take afects on selected alias.
		lnArea = SELECT()
		lnRecno = RECNO()
		
		nRelRow_Out = 0
		nRelCol_Out = 0
		nWhere_Out = 0
		nView_Out = 0
		this.GridHitTest(nXCoord_In, nYCoord_In, @nWhere_Out, @nRelRow_Out, @nRelCol_Out, @nView_Out)
		this.TopRow = this.ActiveRow - this.RelativeRow + 1
		IF NOT EMPTY(nRelRow_Out)
			this.nGridRow = this.TopRow + nRelRow_Out - 1
		ENDIF
		IF NOT EMPTY(nRelCol_Out)
			this.nGridCol = this.LeftColumn + nRelCol_Out - 1
		ENDIF
		
		SELECT (lnArea)
		GO lnRecno
	ENDPROC

	PROCEDURE headerheight_assign
		LPARAMETERS vNewVal
		*To do: Modify this routine for the Assign method
		THIS.HeaderHeight = m.vNewVal
		
	ENDPROC

	PROCEDURE Init
		LOCAL loColumn AS Column
		
		this.GetGridLabel()
		This.w=This.Width
		This.h=This.Height
		This.F=This.FontSize
		This.T=This.Top
		This.l=This.Left
		This.rh=This.RowHeight
		This.hh=This.HeaderHeight
		This.labout2leavegrid=.F.
		This.nrecno = 0
		
		TEXT TO this.cGridDynamicBackColor TEXTMERGE NOSHOW PRETEXT 15
			ICASE(MOD(RECNO(),7)=0,<<g_oPredefinedColors.GridRowColor7>>,
			MOD(RECNO(),7)=1,<<g_oPredefinedColors.GridRowColor1>>,
			MOD(RECNO(),7)=2,<<g_oPredefinedColors.GridRowColor6>>,
			MOD(RECNO(),7)=3,<<g_oPredefinedColors.GridRowColor2>>,
			MOD(RECNO(),7)=4,<<g_oPredefinedColors.GridRowColor5>>,
			MOD(RECNO(),7)=5,<<g_oPredefinedColors.GridRowColor3>>,<<g_oPredefinedColors.GridRowColor4>>)
		ENDTEXT
		
		IF This.ColumnCount > 0
			FOR EACH loColumn IN this.Columns
				loColumn.AddProperty("cw", loColumn.Width)
				loColumn.AddProperty("cn", ALLTRIM(UPPER(loColumn.Name)))
				loColumn.AddProperty("lUDCol")
			NEXT
		ENDIF
		
		this.DefineUdPopupMenu()
		
		_screen.oGlobal.Grid_Init(thisform, this)
	ENDPROC

	PROCEDURE MouseDown
		LPARAMETERS nButton, nShift, nXCoord, nYCoord
		
		IF this.lGetMousePosition
			this.GetPosition(nXCoord, nYCoord)
		ENDIF
	ENDPROC

	PROCEDURE MouseEnter
		LPARAMETERS nButton, nShift, nXCoord, nYCoord
		IF NOT EMPTY(this.ctooltiptext)
		*	LOCAL lnWhere, lnRow, lnCol
		*	LOCAL ARRAY l_aMouse(1)
		*	STORE 0 TO lnWhere, lnRow, lnCol
		*	AMOUSEOBJ("l_aMouse")
		*	IF this.GridHitTest(l_aMouse(3), l_aMouse(4), @lnWhere, @lnRow, @lnCol)
		*		IF lnRow = this.RelativeRow
					FoxGUI_ShowToolTip(THIS, THISFORM, 0, 0, 0)
		*		ENDIF
		*	ENDIF
		ENDIF
		DODEFAULT()
	ENDPROC

	PROCEDURE MouseUp
		LPARAMETERS nButton, nShift, nXCoord, nYCoord
		
		IF nButton = 2 AND VARTYPE(goTbrMain) = "O" AND goTbrMain.lToolVisible AND NOT EMPTY(thisform.cTbrClass)
			goTbrMain.ShowPopup()
		ENDIF
	ENDPROC

	PROCEDURE m_setgriddynamiccolor
		RETURN .T.
	ENDPROC

	PROCEDURE popupcolumnmenu
		LPARAMETERS tcObject, tcGrid, tnXPos
		LOCAL llCreated, lnColumnNo, loColumn, loControl, lcUDFunction
		LOCAL ARRAY laColumns[1]
		
		DIMENSION laColumns[&tcObject..ColumnCount]
		FOR lnColumnNo = 1 TO ALEN(laColumns)
			laColumns[&tcObject..Columns[lnColumnNo].ColumnOrder] = lnColumnNo
		NEXT
		FOR EACH lnColumnNo IN laColumns
			loColumn = &tcObject..Columns[lnColumnNo]
			FOR EACH loControl IN loColumn.Controls
				IF LOWER(loControl.BaseClass) == "header"
					IF _screen.oGlobal.Grid_GetColumnProperty(IIF(EMPTY(this.cGridLabelName), tcGrid, this), loColumn, "gr_show")
						DEFINE BAR lnColumnNo OF pucol PROMPT loControl.Caption
						SET MARK OF BAR lnColumnNo OF pucol TO loColumn.Visible
						lcUDFunction = "SwitchColumn(BAR(), '"+tcObject+"')"
						ON SELECTION BAR lnColumnNo OF pucol &lcUDFunction
						llCreated = .T.
					ENDIF
					EXIT
				ENDIF
			NEXT
		NEXT
		IF NOT llCreated
			DEFINE BAR 1 OF pucol PROMPT GetLangText("COMMON", "TXT_NO_COLUMNS")
		ENDIF
		
		RETURN .T.
	ENDPROC

	PROCEDURE recordsource_assign
		LPARAMETERS lp_cNewVal
		
		this.RecordSource = lp_cNewVal
	ENDPROC

	PROCEDURE refreshsortcursor
		IF this.lNotUseSortCursor OR EMPTY(this.RecordSource)
			RETURN .T.
		ENDIF
		LOCAL l_oCol, l_cDynamicBackColor
		
		* Try to generate diffrent color for every row in grid
		FOR EACH l_oCol IN this.Columns
			IF EMPTY(l_oCol.DynamicBackColor) OR TYPE("l_oCol.nBackColorCoef") = "N"
				l_cDynamicBackColor = ""
				IF TYPE("l_oCol.cCustomDynamicBackColor") = "C" AND NOT EMPTY(l_oCol.cCustomDynamicBackColor)
					l_cDynamicBackColor = l_oCol.cCustomDynamicBackColor
				ENDIF
				IF .T.
				IF EMPTY(l_cDynamicBackColor)
					l_cDynamicBackColor = this.cGridDynamicBackColor
				ELSE
					l_cDynamicBackColor = "ICASE(" + l_cDynamicBackColor + "," + this.cGridDynamicBackColor + ")"
				ENDIF
				ELSE
				* Ne radi dobro new availability
				IF NOT EMPTY(l_oCol.DynamicBackColor) OR EMPTY(this.cGridDynamicBackColor)
					IF NOT EMPTY(l_cDynamicBackColor)
						l_cDynamicBackColor = "ICASE(" + l_cDynamicBackColor + ",RGB(255,255,255))"
					ENDIF
				ELSE
					IF EMPTY(l_cDynamicBackColor)
						l_cDynamicBackColor = "ConvColorsA(RGB(255,255,255)," + this.cGridDynamicBackColor + ")"
					ELSE
						l_cDynamicBackColor = "ConvColorsA(ICASE(" + l_cDynamicBackColor + ",RGB(255,255,255))," + this.cGridDynamicBackColor + ")"
					ENDIF
				ENDIF
				ENDIF
				IF TYPE("l_oCol.nBackColorCoef") = "N" AND NOT INLIST(l_oCol.nBackColorCoef, 0, 1)
					l_cDynamicBackColor = "ConvColors(" + EVL(EVL(l_cDynamicBackColor,l_oCol.DynamicBackColor),"RGB(255,255,255)") + "," + STRTRAN(TRANSFORM(l_oCol.nBackColorCoef),",",".") + ")"
				ENDIF
				l_oCol.DynamicBackColor = l_cDynamicBackColor
			ENDIF
		ENDFOR
		
		RETURN .T.
	ENDPROC

	PROCEDURE removefocusfromgrid
		IF NOT this.Visible
			RETURN .T.
		ENDIF
		
		LOCAL l_oCtrl
		FOR EACH l_oCtrl IN thisform.Controls
			IF LOWER(l_oCtrl.BaseClass)="commandbutton"
				l_oCtrl.SetFocus()
				EXIT
			ENDIF
		ENDFOR
		
		RETURN .T.
	ENDPROC

	PROCEDURE restorecolumn
		LPARAMETERS lp_oColumn
	ENDPROC

	PROCEDURE restorestate		&& Restores its state from Grid table.
		LPARAMETERS toColumn, tlGridDontRefresh
		
		_screen.oGlobal.Grid_RestoreState(thisform, this, toColumn, tlGridDontRefresh)
	ENDPROC

	PROCEDURE savestate		&& Saves its state to Grid table.
		LPARAMETERS toColumn, tlGridDontRefresh
		
		_screen.oGlobal.Grid_SaveState(thisform, this, toColumn, tlGridDontRefresh)
	ENDPROC

	PROCEDURE selectedisfirst		&& Currently selected record is set to be in first row in Grid
		LOCAL l_nHeight, l_lLockScreen, l_cMacro
		IF EMPTY(this.cCommandToRemoveFocus)
			ASSERT .F. MESSAGE "Must define cCommandToRemoveFocus property! " + PROGRAM()
			RETURN .F.
		ENDIF
		l_lLockScreen = _screen.LockScreen
		_screen.LockScreen = .T.
		l_nHeight = this.Height
		this.Height = this.HeaderHeight + this.RowHeight
		* Remove focus
		l_cMacro = this.cCommandToRemoveFocus
		TRY
			&l_cMacro
		CATCH
		ENDTRY
		this.Height = l_nHeight
		_screen.LockScreen = l_lLockScreen
		
		RETURN .T.
	ENDPROC

	PROCEDURE setcolumnproperty
		LPARAMETERS toColumn, tcColumnProperty, tuValue
		
		TRY
			toColumn.&tcColumnProperty = tuValue
		CATCH
		ENDTRY
	ENDPROC

ENDDEFINE

DEFINE CLASS tgriddef AS _form OF "..\common\libs\_lbasev.vcx" 
 	*< CLASSDATA: Baseclass="form" Timestamp="" Scale="Pixels" Uniqueid="" />

	*-- OBJECTDATA items order determines ZOrder / El orden de los items OBJECTDATA determina el ZOrder 
	*< OBJECTDATA: ObjPath="lblCaption" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="lblShow" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="lblExpression" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="lstGrid" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="cmdInsert" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="cmdDelete" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="cmdOK" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="cmdCancel" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="cntEdit" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="cntEdit.txtCaption" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="cntEdit.cboShow" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="cntEdit.txtExpression" UniqueID="" Timestamp="" />

	*<DefinedPropArrayMethod>
		*m: getrowvalue
		*m: oncancel
		*m: ondelete
		*m: oninsert
		*m: onok
		*p: ckey
		*p: clabel
		*p: cuser
		*p: ogrid
	*</DefinedPropArrayMethod>

	Caption = "Define columns"
	ckey = 
	clabel = 
	cuser = 
	DataSession = 2
	DoCreate = .T.
	Height = 250
	Icon = ..\bitmap\browse.ico
	MinHeight = 250
	MinWidth = 500
	Name = "tgriddef"
	ogrid = .NULL.
	Top = 0
	Width = 500
	WindowType = 1

	ADD OBJECT 'cmdCancel' AS _commandbutton WITH ;
		Anchor = 12, ;
		Cancel = .T., ;
		Caption = "Cancel", ;
		Height = 24, ;
		Left = 420, ;
		Name = "cmdCancel", ;
		Top = 216, ;
		Width = 72, ;
		ZOrderSet = 7
		*< END OBJECT: ClassLib="..\common\libs\_lbasev.vcx" BaseClass="commandbutton" />

	ADD OBJECT 'cmdDelete' AS _commandbutton WITH ;
		Anchor = 4, ;
		Caption = "Delete", ;
		Height = 24, ;
		Left = 96, ;
		Name = "cmdDelete", ;
		Top = 216, ;
		Width = 72, ;
		ZOrderSet = 5
		*< END OBJECT: ClassLib="..\common\libs\_lbasev.vcx" BaseClass="commandbutton" />

	ADD OBJECT 'cmdInsert' AS _commandbutton WITH ;
		Anchor = 4, ;
		Caption = "Insert", ;
		Height = 24, ;
		Left = 12, ;
		Name = "cmdInsert", ;
		Top = 216, ;
		Width = 72, ;
		ZOrderSet = 4
		*< END OBJECT: ClassLib="..\common\libs\_lbasev.vcx" BaseClass="commandbutton" />

	ADD OBJECT 'cmdOK' AS _commandbutton WITH ;
		Anchor = 12, ;
		Caption = "OK", ;
		Default = .T., ;
		Height = 24, ;
		Left = 336, ;
		Name = "cmdOK", ;
		Top = 216, ;
		Width = 72, ;
		ZOrderSet = 6
		*< END OBJECT: ClassLib="..\common\libs\_lbasev.vcx" BaseClass="commandbutton" />

	ADD OBJECT 'cntEdit' AS _container WITH ;
		Anchor = 10, ;
		BorderWidth = 0, ;
		Height = 22, ;
		Left = 22, ;
		Name = "cntEdit", ;
		Top = 24, ;
		Width = 457, ;
		ZOrderSet = 8
		*< END OBJECT: ClassLib="..\common\libs\_lbasev.vcx" BaseClass="container" />

	ADD OBJECT 'cntEdit.cboShow' AS _combobox WITH ;
		Height = 22, ;
		Left = 148, ;
		Name = "cboShow", ;
		RowSource = "Yes,No", ;
		RowSourceType = 1, ;
		Style = 2, ;
		Top = 0, ;
		Width = 53
		*< END OBJECT: ClassLib="..\common\libs\_lbasev.vcx" BaseClass="combobox" />

	ADD OBJECT 'cntEdit.txtCaption' AS _textbox WITH ;
		BackStyle = 0, ;
		Height = 22, ;
		Left = 0, ;
		Name = "txtCaption", ;
		Top = 0, ;
		Width = 149
		*< END OBJECT: ClassLib="..\common\libs\_lbasev.vcx" BaseClass="textbox" />

	ADD OBJECT 'cntEdit.txtExpression' AS _textbox WITH ;
		Anchor = 10, ;
		BackStyle = 0, ;
		Height = 22, ;
		Left = 200, ;
		Name = "txtExpression", ;
		Top = 0, ;
		Width = 300
		*< END OBJECT: ClassLib="..\common\libs\_lbasev.vcx" BaseClass="textbox" />

	ADD OBJECT 'lblCaption' AS _label WITH ;
		BackStyle = 0, ;
		Caption = "Caption", ;
		Left = 23, ;
		Name = "lblCaption", ;
		Top = 7, ;
		Width = 150, ;
		ZOrderSet = 0
		*< END OBJECT: ClassLib="..\common\libs\_lbasev.vcx" BaseClass="label" />

	ADD OBJECT 'lblExpression' AS _label WITH ;
		Anchor = 10, ;
		BackStyle = 0, ;
		Caption = "Expression", ;
		Height = 17, ;
		Left = 229, ;
		Name = "lblExpression", ;
		Top = 7, ;
		Width = 300, ;
		ZOrderSet = 2
		*< END OBJECT: ClassLib="..\common\libs\_lbasev.vcx" BaseClass="label" />

	ADD OBJECT 'lblShow' AS _label WITH ;
		BackStyle = 0, ;
		Caption = "Show", ;
		Height = 17, ;
		Left = 176, ;
		Name = "lblShow", ;
		Top = 7, ;
		Width = 50, ;
		ZOrderSet = 1
		*< END OBJECT: ClassLib="..\common\libs\_lbasev.vcx" BaseClass="label" />

	ADD OBJECT 'lstGrid' AS _listbox WITH ;
		Anchor = 15, ;
		ColumnCount = 4, ;
		ColumnLines = .F., ;
		ColumnWidths = "150,50,500,0", ;
		Height = 180, ;
		Left = 2, ;
		MoverBars = .T., ;
		Name = "lstGrid", ;
		Top = 24, ;
		Width = 496, ;
		ZOrderSet = 3
		*< END OBJECT: ClassLib="..\common\libs\_lbasev.vcx" BaseClass="listbox" />
	
	PROCEDURE getrowvalue
		LPARAMETERS tnListIndex
		
		this.cntEdit.Top = this.lstGrid.Top + 17 * MAX(0,tnListIndex-this.lstGrid.TopIndex)
		this.cntEdit.txtCaption.Value = this.lstGrid.List(tnListIndex,1)
		this.cntEdit.cboShow.Value = this.lstGrid.List(tnListIndex,2)
		this.cntEdit.txtExpression.Value = this.lstGrid.List(tnListIndex,3)
		this.cntEdit.txtCaption.SetFocus()
	ENDPROC

	PROCEDURE Init
		LPARAMETERS toGrid, tcGrid
		
		IF VARTYPE(toGrid) # "O" OR UPPER(toGrid.BaseClass) # "GRID"
			RETURN .F.
		ENDIF
		
		this.oGrid = toGrid
		this.cUser = g_userid
		this.cLabel = tcGrid&&toGrid.Name
		this.cKey = UPPER(PADR(this.cUser,10)+PADR(this.cLabel,30))
		
		SELECT grid
		SET ORDER TO Tag2 
		SCAN FOR UPPER(gr_user+gr_label+gr_column) = this.cKey
			this.OnInsert(gr_caption, gr_show, gr_source, gr_column)
		ENDSCAN
		
		this.lstGrid.ListIndex = 1
		this.GetRowValue(1)
	ENDPROC

	PROCEDURE Load
		Ini(.T.)
		this.AutoCenter = _screen.oGlobal.lAutoCenterForms
	ENDPROC

	PROCEDURE oncancel
		this.Release()
	ENDPROC

	PROCEDURE ondelete
		LOCAL lnListIndex
		
		lnListIndex = MIN(MAX(1,this.lstGrid.ListCount-1), this.lstGrid.ListIndex)
		IF this.lstGrid.ListCount > 1
			this.lstGrid.RemoveItem(this.lstGrid.ListIndex)
			this.lstGrid.ListIndex = lnListIndex
		ELSE
			this.lstGrid.List(1,1) = []
			this.lstGrid.List(1,2) = []
			this.lstGrid.List(1,3) = []
		ENDIF
		this.GetRowValue(lnListIndex)
	ENDPROC

	PROCEDURE oninsert
		LPARAMETERS tcCaption, tlShow, tcSource, tcColumn
		LOCAL lcCaption, lcSource, lcColumn
		
		lcCaption = IIF(EMPTY(tcCaption), [<New column>], ALLTRIM(tcCaption))
		lcSource = IIF(EMPTY(tcSource), [], ALLTRIM(tcSource))
		this.lstGrid.AddListItem(lcCaption)
		this.lstGrid.AddListItem(IIF(tlShow,[Yes],[No]), this.lstGrid.NewItemID, 2)
		this.lstGrid.AddListItem(lcSource, this.lstGrid.NewItemID, 3)
		lcColumn = IIF(EMPTY(tcColumn), [Column]+ALLTRIM(STR(this.lstGrid.NewItemID)), tcColumn)
		this.lstGrid.AddListItem(lcColumn, this.lstGrid.NewItemID, 4)
	ENDPROC

	PROCEDURE onok
		this.Release()
	ENDPROC

	PROCEDURE cmdCancel.Click
		thisform.OnCancel()
	ENDPROC

	PROCEDURE cmdDelete.Click
		thisform.OnDelete()
	ENDPROC

	PROCEDURE cmdInsert.Click
		thisform.OnInsert()
	ENDPROC

	PROCEDURE cmdOK.Click
		thisform.OnOK()
	ENDPROC

	PROCEDURE cntEdit.cboShow.LostFocus
		thisform.lstGrid.List(thisform.lstGrid.ListIndex,2) = this.Value
	ENDPROC

	PROCEDURE cntEdit.txtCaption.LostFocus
		thisform.lstGrid.List(thisform.lstGrid.ListIndex,1) = this.Value
	ENDPROC

	PROCEDURE cntEdit.txtExpression.LostFocus
		thisform.lstGrid.List(thisform.lstGrid.ListIndex,3) = this.Value
	ENDPROC

	PROCEDURE lstGrid.InteractiveChange
		thisform.GetRowValue(this.ListIndex)
	ENDPROC

ENDDEFINE

DEFINE CLASS timage AS image 
 	*< CLASSDATA: Baseclass="image" Timestamp="" Scale="Pixels" Uniqueid="" />

	*<DefinedPropArrayMethod>
		*p: h
		*p: l
		*p: t
		*p: w
	*</DefinedPropArrayMethod>

	Height = 17
	Name = "timage"
	Width = 100
	
	PROCEDURE Init
		this.l=this.left
		this.t=this.top
		this.w=this.Width
		this.h=this.Height
		
	ENDPROC

ENDDEFINE

DEFINE CLASS tlabel AS label 
 	*< CLASSDATA: Baseclass="label" Timestamp="" Scale="Pixels" Uniqueid="" />

	*<DefinedPropArrayMethod>
		*p: ctooltiptext		&& Extended Tooltiptext, over 127 Chars
		*p: f
		*p: h
		*p: l
		*p: ldontresize
		*p: resizefontsize
		*p: t
		*p: w
	*</DefinedPropArrayMethod>

	AutoSize = .F.
	BackStyle = 0
	Caption = "Label1"
	FontSize = 9
	ldontresize = .F.
	Name = "tlabel"
	resizefontsize = .T.
	
	PROCEDURE Init
		this.w=this.width
		this.h=this.height
		this.f=this.fontsize
		this.t=this.top
		this.l=this.left
	ENDPROC

	PROCEDURE MouseEnter
		LPARAMETERS nButton, nShift, nXCoord, nYCoord
		*FoxGUI_ShowToolTip(THIS, THISFORM, 0, 0, 0)
		DODEFAULT()
	ENDPROC

ENDDEFINE

DEFINE CLASS tlistbox AS listbox 
 	*< CLASSDATA: Baseclass="listbox" Timestamp="" Scale="Pixels" Uniqueid="" />

	*<DefinedPropArrayMethod>
		*p: f
		*p: h
		*p: l
		*p: nlineheight
		*p: resizefontsize
		*p: t
		*p: w
	*</DefinedPropArrayMethod>

	Height = 167
	Name = "tlistbox"
	nlineheight = 7
	resizefontsize = .T.
	
	PROCEDURE Click
		IF PEMSTATUS(thisform, "HndClick", 5)
			thisform.HndClick(this)
		ENDIF
	ENDPROC

	PROCEDURE GotFocus
		IF PEMSTATUS(thisform, "HndGotFocus", 5)
			thisform.HndGotFocus(this)
		ENDIF
	ENDPROC

	PROCEDURE Init
		this.w = this.Width
		this.h = this.Height
		this.f = this.FontSize
		this.t = this.Top
		this.l = this.Left
		
		If this.ColumnCount > 0
			LOCAL lcColumnWidths
			this.AddProperty("cw(1)")
			DIMENSION this.cw(this.ColumnCount)
			STORE 0 TO this.cw
			lcColumnWidths = STRTRAN(This.ColumnWidths, ",", " , ")
			FOR i = 1 TO GETWORDCOUNT(lcColumnWidths,",")
				this.cw(i) = INT(VAL(GETWORDNUM(lcColumnWidths,i,",")))
			NEXT
		ENDIF
	ENDPROC

	PROCEDURE InteractiveChange
		IF PEMSTATUS(thisform, "HndInteractiveChange", 5)
			thisform.HndInteractiveChange(this)
		ENDIF
	ENDPROC

	PROCEDURE LostFocus
		IF PEMSTATUS(thisform, "HndLostFocus", 5)
			thisform.HndLostFocus(this)
		ENDIF
	ENDPROC

	PROCEDURE Valid
		IF PEMSTATUS(thisform, "HndValid", 5)
			RETURN thisform.HndValid(this)
		ENDIF
	ENDPROC

	PROCEDURE When
		IF PEMSTATUS(thisform, "HndWhen", 5)
			RETURN thisform.HndWhen(this)
		ENDIF
	ENDPROC

ENDDEFINE

DEFINE CLASS tolebound AS oleboundcontrol 
 	*< CLASSDATA: Baseclass="oleboundcontrol" Timestamp="" Scale="Pixels" Uniqueid="" />

	*<DefinedPropArrayMethod>
		*p: h
		*p: l
		*p: t
		*p: w
	*</DefinedPropArrayMethod>

	Height = 100
	Name = "tolebound"
	Width = 100
	
	PROCEDURE Init
		this.w=this.width
		this.h=this.height
		this.t=this.top
		this.l=this.left
		
	ENDPROC

ENDDEFINE

DEFINE CLASS toletree AS olecontrol 
 	*< CLASSDATA: Baseclass="olecontrol" Timestamp="" Scale="Pixels" Uniqueid="" Nombre="toletree" Parent="" ObjName="toletree" OLEObject="C:\WINDOWS\system32\MSCOMCTL.OCX" Value="0M8R4KGxGuEAAAAAAAAAAAAAAAAAAAAAPgADAP7/CQAGAAAAAAAAAAAAAAABAAAAAQAAAAAAAAAAEAAAAgAAAAEAAAD+////AAAAAAAAAAD////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////9/////v////7////+/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////1IAbwBvAHQAIABFAG4AdAByAHkAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAWAAUA//////////8BAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPCf4jAnWsUBAwAAAEABAAAAAAAAAwBPAGwAZQBPAGIAagBlAGMAdABEAGEAdABhAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAB4AAgEDAAAAAgAAAP////8AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAZAAAAAAAAAADAEEAYwBjAGUAcwBzAE8AYgBqAFMAaQB0AGUARABhAHQAYQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAJgACAP///////////////wAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEAAABcAAAAAAAAAAMAQwBoAGEAbgBnAGUAZABQAHIAbwBwAHMAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAcAAIA////////////////AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAwAAAAQAAAAAAAAABAAAAAIAAAD+/////v////7///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////+2kEHHiYXREbFqAMDwKDYoIUM0EggAAABWCgAAVgoAALE8wWoBAAYAHAAAAJwAAADoAwAACAAAAAgIGQAB782rXAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAACQAAAA4AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA5MzY4MjY1RS04NUZFLTExZDEtOEJFMy0wMDAwRjg3NTREQTFXAEkATgBEAE8AVwBTAFwAUwB5AHMAdABlAG0AMwAyAFwAbAABAACAdAAuAGQAbABsAAAATQBpAGMAcgBvAHMAbwBmAHQAIABJAG0AYQBnAGUATABpAHMAdAAgAEMAbwBuAHQAAAAFANgJGQAGAAAAAAAAAAUAAICU4hIAH97svQEABQDY4hIAUwBQADIAKQAJAHsANQA4AEQAQQA4AEQAOABGAC0AOQBEADYAQQAtADEAMAAxAEIALQBBAEYAQwAwAC0ANAAyADEAMAAxADAAMgBBADgARABBADcAfQAgAEMAOgBcAFcASQBOAEQATwBXAFMAXABzAHkAcwB0AGUAbQAzADIAXABDAE8ATQBDAFQATAAzADIALgBPAEMAWAAAABQA6jppEKLYCAArMDCdGQAvRDpcAAAAAAAAAAAAAAAAAAAAAAAAADwAMQAAAAAAAAAAABAAY2l0YWRlbAAmAAMABA==" />

	*<DefinedPropArrayMethod>
		*p: h
		*p: l
		*p: t
		*p: w
	*</DefinedPropArrayMethod>

	Height = 100
	Name = "toletree"
	Width = 100
	
	PROCEDURE Init
		this.w=this.width
		this.h=this.height
		this.t=this.top
		this.l=this.left
		
	ENDPROC

ENDDEFINE

DEFINE CLASS toptiongroup AS optiongroup 
 	*< CLASSDATA: Baseclass="optiongroup" Timestamp="" Scale="Pixels" Uniqueid="" />

	*<DefinedPropArrayMethod>
		*p: f
		*p: h
		*p: l
		*p: nlineheight
		*p: resizefontsize
		*p: t
		*p: w
	*</DefinedPropArrayMethod>

	ButtonCount = 0
	Height = 46
	Name = "toptiongroup"
	nlineheight = 0
	resizefontsize = .T.
	Value = 0
	Width = 71
	
	PROCEDURE Init
		this.w=this.width
		this.h=this.height
		this.l=this.left
		this.t=this.top
		
		this.AddProperty("bw("+ALLTRIM(STR(this.buttonCount))+")")
		this.AddProperty("bh("+ALLTRIM(STR(this.buttonCount))+")")
		this.AddProperty("bl("+ALLTRIM(STR(this.buttonCount))+")")
		this.AddProperty("bt("+ALLTRIM(STR(this.buttonCount))+")")
		this.AddProperty("bf("+ALLTRIM(STR(this.buttonCount))+")")
		FOR i=1 TO this.buttoncount
			this.bw(i)=this.buttons(i).width
			this.bh(i)=this.buttons(i).height
			this.bl(i)=this.buttons(i).left
			this.bt(i)=this.buttons(i).top
			this.bf(i)=this.buttons(i).fontsize
		NEXT
		
	ENDPROC

ENDDEFINE

DEFINE CLASS tpageframe AS pageframe 
 	*< CLASSDATA: Baseclass="pageframe" Timestamp="" Scale="Pixels" Uniqueid="" />

	*<DefinedPropArrayMethod>
		*p: h
		*p: l
		*p: ph
		*p: pw
		*p: t
		*p: w
	*</DefinedPropArrayMethod>

	ActivePage = 0
	ErasePage = .T.
	Height = 169
	Name = "tpageframe"
	PageCount = 0
	Width = 241
	
	PROCEDURE Init
		this.w=this.width
		this.h=this.height
		this.t=this.top
		this.l=this.left
		this.pw=this.pagewidth
		this.ph=this.pageheight
		this.AddProperty("pf("+ALLTRIM(STR(this.PageCount))+")")
		FOR i=1 TO this.PageCount
			this.pf(i)=this.pages(i).fontsize
		next
	ENDPROC

ENDDEFINE

DEFINE CLASS tselectctrl AS ttext OF "main.vcx" 
 	*< CLASSDATA: Baseclass="textbox" Timestamp="" Scale="Pixels" Uniqueid="" />

	*<DefinedPropArrayMethod>
		*m: dropdown		&& Cit class DropDown method.
		*m: enabled_assign
		*m: positionbutton		&& Positions DropDown Button.
		*m: refreshvalue
		*m: visible_assign
		*p: curselect
		*p: lactive
		*p: obutton
		*p: oform
	*</DefinedPropArrayMethod>

	curselect = 
	Name = "tselectctrl"
	obutton = .NULL.
	oform = .NULL.
	ReadOnly = .T.
	
	PROCEDURE dropdown		&& Cit class DropDown method.
		DO CASE
			CASE this.lActive
			CASE TYPE("this.Parent."+this.Name+"list") = "O"
				LOCAL lcListObject
				lcListObject = "this.Parent." + this.Name + "list"
				&lcListObject..OnActivate(this)
			OTHERWISE
				DO FORM "common\forms\_selectlist" WITH this
		ENDCASE
	ENDPROC

	PROCEDURE enabled_assign
		LPARAMETERS tlNewVal
		
		this.Enabled = tlNewVal
		this.oButton.Enabled = this.Enabled
	ENDPROC

	PROCEDURE GotFocus
		this.oButton.Refresh()
		DODEFAULT()
	ENDPROC

	PROCEDURE Init
		this.curSelect = SYS(2015)
		this.oForm = thisform
		DODEFAULT()
		this.ToolTipText = GetLangText("COMMON","TT_PRESS_CTRL_L_SELECT")
		IF EMPTY(this.ControlSource) AND EMPTY(this.Value)
			this.Value = ""
		ENDIF
		
		this.Parent.AddObject(this.Name + "button", "tCommandDropDown")
		this.oButton = EVALUATE("this.Parent." + this.Name + "button")
		this.PositionButton()
		this.oButton.TabStop = .F.
		this.oButton.oParent = this
		IF thisform.WindowType = 1
			this.Parent.AddObject(this.Name + "list", "tSelectCnt")
		ENDIF
		this.Enabled = this.Enabled
		this.Visible = this.Visible
	ENDPROC

	PROCEDURE KeyPress
		LPARAMETERS nKeyCode, nShiftAltCtrl
		
		DO CASE
			CASE nKeyCode = 12 AND nShiftAltCtrl = 2 OR nKeyCode = 160 AND nShiftAltCtrl = 4
				this.DropDown()
		ENDCASE
	ENDPROC

	PROCEDURE positionbutton		&& Positions DropDown Button.
		LOCAL lnNumber, lnButtonWith
		
		lnButtonWith = SYSMETRIC(5)
		WITH this.oButton
			.Anchor = 0
			.Height = this.Height - 3
			.Left = this.Left + this.Width - lnButtonWith - 2
			.Top = this.Top + 2
			.Width = lnButtonWith
			.Anchor = this.Anchor
			IF NOT EMPTY(this.Tag) AND ISDIGIT(this.Tag)
				***********************************************************************
				*
				* Copy order of appereance of parent control into little button, but
				* make it to be last in order.
				*
				***********************************************************************
				lnNumber = INT(VAL(this.Tag)) + 1000
				.Tag = TRANSFORM(lnNumber)
			ENDIF
		ENDWITH
	ENDPROC

	PROCEDURE refreshvalue
		LOCAL lnSelect, lnRecno, lcField2, lcField3, lcTT, lcVal
		
		IF NOT USED(this.curSelect)
			RETURN .T.
		ENDIF
		
		STORE "" TO lcTT, lcVal
		
		lnSelect = SELECT()
		
		SELECT (this.curSelect)
		lcField2 = FIELD(2)
		lcField3 = FIELD(3)
		lnRecno = RECNO()
		SCAN FOR c_selected
			IF RECNO() = 1
				EXIT
			ELSE
				lcVal = lcVal + IIF(EMPTY(lcVal), "", ", ") + ALLTRIM(&lcField2)
				lcTT = lcTT + IIF(EMPTY(lcTT), "", CHR(13)+CHR(10)) + &lcField2 + IIF(EMPTY(lcField3) OR EMPTY(&lcField3), "", " - " + &lcField3)
			ENDIF
		ENDSCAN
		GO lnRecno
		
		SELECT (lnSelect)
		
		this.Value = lcVal
		this.ToolTipText = EVL(lcTT, GetLangText("COMMON","TT_PRESS_CTRL_L_SELECT"))
	ENDPROC

	PROCEDURE visible_assign
		LPARAMETERS tlNewVal
		
		this.Visible = tlNewVal
		this.oButton.Visible = tlNewVal
	ENDPROC

ENDDEFINE

DEFINE CLASS tspinner AS spinner 
 	*< CLASSDATA: Baseclass="spinner" Timestamp="" Scale="Pixels" Uniqueid="" />

	*<DefinedPropArrayMethod>
		*p: f
		*p: h
		*p: l
		*p: ldontresize
		*p: resizefontsize
		*p: t
		*p: w
	*</DefinedPropArrayMethod>

	Height = 23
	Name = "tspinner"
	resizefontsize = .T.
	Width = 117
	
	PROCEDURE Click
		IF PEMSTATUS(thisform, "HndClick", 5)
			thisform.HndClick(this)
		ENDIF
	ENDPROC

	PROCEDURE GotFocus
		IF PEMSTATUS(thisform, "HndGotFocus", 5)
			thisform.HndGotFocus(this)
		ENDIF
		DODEFAULT()
	ENDPROC

	PROCEDURE Init
		this.w=this.width
		this.h=this.height
		this.f=this.fontsize
		this.t=this.top
		this.l=this.left
	ENDPROC

	PROCEDURE InteractiveChange
		IF PEMSTATUS(thisform, "HndInteractiveChange", 5)
			thisform.HndInteractiveChange(this)
		ENDIF
	ENDPROC

	PROCEDURE LostFocus
		IF PEMSTATUS(thisform, "HndLostFocus", 5)
			thisform.HndLostFocus(this)
		ENDIF
	ENDPROC

	PROCEDURE Valid
		IF PEMSTATUS(thisform, "HndValid", 5)
			RETURN thisform.HndValid(this)
		ENDIF
	ENDPROC

	PROCEDURE When
		IF PEMSTATUS(thisform, "HndWhen", 5)
			RETURN thisform.HndWhen(this)
		ENDIF
	ENDPROC

ENDDEFINE

DEFINE CLASS ttext AS textbox 
 	*< CLASSDATA: Baseclass="textbox" Timestamp="" Scale="Pixels" Uniqueid="" />

	*<DefinedPropArrayMethod>
		*p: ctooltiptext
		*p: f
		*p: h
		*p: l
		*p: ldontresize
		*p: nlineheight
		*p: resizefontsize
		*p: t
		*p: w
	*</DefinedPropArrayMethod>

	Height = 23
	ldontresize = .F.
	Name = "ttext"
	nlineheight = 1
	resizefontsize = .T.
	SelectOnEntry = .T.
	Width = 100
	
	PROCEDURE Click
		IF PEMSTATUS(thisform, "HndClick", 5)
			thisform.HndClick(this)
		ENDIF
	ENDPROC

	PROCEDURE GotFocus
		IF PEMSTATUS(thisform, "HndGotFocus", 5)
			thisform.HndGotFocus(this)
		ENDIF
	ENDPROC

	PROCEDURE Init
		this.w=this.width
		this.h=this.height
		this.f=this.fontsize
		this.t=this.top
		this.l=this.left
	ENDPROC

	PROCEDURE InteractiveChange
		IF PEMSTATUS(thisform, "HndInteractiveChange", 5)
			thisform.HndInteractiveChange(this)
		ENDIF
	ENDPROC

	PROCEDURE LostFocus
		IF PEMSTATUS(thisform, "HndLostFocus", 5)
			thisform.HndLostFocus(this)
		ENDIF
	ENDPROC

	PROCEDURE MouseEnter
		LPARAMETERS nButton, nShift, nXCoord, nYCoord
		IF NOT EMPTY(this.ctooltiptext)
			FoxGUI_ShowToolTip(THIS, THISFORM, 0, 0, 0)
		ENDIF
		DODEFAULT()
	ENDPROC

	PROCEDURE Valid
		IF PEMSTATUS(thisform, "HndValid", 5)
			RETURN thisform.HndValid(this)
		ENDIF
	ENDPROC

	PROCEDURE When
		IF PEMSTATUS(thisform, "HndWhen", 5)
			RETURN thisform.HndWhen(this)
		ENDIF
	ENDPROC

ENDDEFINE

DEFINE CLASS ttoolbar AS toolbar 
 	*< CLASSDATA: Baseclass="toolbar" Timestamp="" Scale="Pixels" Uniqueid="" />

	*-- OBJECTDATA items order determines ZOrder / El orden de los items OBJECTDATA determina el ZOrder 
	*< OBJECTDATA: ObjPath="Tcommandbutton3" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Tcommandbutton2" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Tcommandbutton1" UniqueID="" Timestamp="" />

	Caption = "Toolbar1"
	Height = 33
	Left = 0
	Name = "ttoolbar"
	Top = 0
	Width = 260

	ADD OBJECT 'Tcommandbutton1' AS tcommandbutton WITH ;
		Left = 171, ;
		Name = "Tcommandbutton1", ;
		Top = 3
		*< END OBJECT: ClassLib="main.vcx" BaseClass="commandbutton" />

	ADD OBJECT 'Tcommandbutton2' AS tcommandbutton WITH ;
		Left = 88, ;
		Name = "Tcommandbutton2", ;
		Top = 3
		*< END OBJECT: ClassLib="main.vcx" BaseClass="commandbutton" />

	ADD OBJECT 'Tcommandbutton3' AS tcommandbutton WITH ;
		Left = 5, ;
		Name = "Tcommandbutton3", ;
		Top = 3
		*< END OBJECT: ClassLib="main.vcx" BaseClass="commandbutton" />

ENDDEFINE

DEFINE CLASS ttooltip AS form 
 	*< CLASSDATA: Baseclass="form" Timestamp="" Scale="Pixels" Uniqueid="" />

	*-- OBJECTDATA items order determines ZOrder / El orden de los items OBJECTDATA determina el ZOrder 
	*< OBJECTDATA: ObjPath="shpCover" UniqueID="" Timestamp="" />

	*<DefinedPropArrayMethod>
		*m: mltext_assign
		*m: owner_assign
		*m: visible_assign
		*p: lcanhide
		*p: mltext		&& Specifies the text that appears as a ToolTip for a control.
		*p: owner
	*</DefinedPropArrayMethod>

	AlwaysOnTop = .T.
	BorderStyle = 0
	Caption = ""
	ControlBox = .F.
	DoCreate = .T.
	mltext = 		&& Specifies the text that appears as a ToolTip for a control.
	Name = "ttooltip"
	owner = .NULL.
	TitleBar = 0

	ADD OBJECT 'shpCover' AS shape WITH ;
		Anchor = 15, ;
		BackStyle = 0, ;
		BorderWidth = 0, ;
		Height = 250, ;
		Name = "shpCover", ;
		Width = 375
		*< END OBJECT: BaseClass="shape" />
	
	PROCEDURE Destroy
		this.Owner = .NULL.
	ENDPROC

	PROCEDURE Init
		LPARAMETERS tcClass
		
		this.AddObject("cntText", tcClass)
		this.cntText.Top = 0
		this.cntText.Left = 0
		this.cntText.Height = thisform.Height
		this.cntText.Width = thisform.Width
		this.cntText.Anchor = 15
		this.cntText.Visible = .T.
		this.shpCover.ZOrder()
	ENDPROC

	PROCEDURE mltext_assign
		LPARAMETERS tcNewVal
		
		this.MLText = tcNewVal
		
		this.cntText.MLText = tcNewVal
	ENDPROC

	PROCEDURE owner_assign
		LPARAMETERS toNewVal
		
		this.Owner = toNewVal
		
		this.cntText.Owner = toNewVal
	ENDPROC

	PROCEDURE Paint
		this.lCanHide = .T.
	ENDPROC

	PROCEDURE visible_assign
		LPARAMETERS tlNewVal
		
		this.Visible = tlNewVal
		DO CASE
			CASE TYPE("this.Owner.BaseClass") <> "C" OR this.Owner.BaseClass <> "Form"
			CASE NOT this.Visible
				IF NOT this.Owner.AlwaysOnTop AND this.Owner.nOldAlwaysOnTop = 2
					this.Owner.AlwaysOnTop = .T.
				ENDIF
				this.Owner.nOldAlwaysOnTop = 0
			CASE this.Owner.AlwaysOnTop
				this.Owner.nOldAlwaysOnTop = 2
				this.Owner.AlwaysOnTop = .F.
			OTHERWISE
		ENDCASE
	ENDPROC

	PROCEDURE shpCover.MouseMove
		LPARAMETERS nButton, nShift, nXCoord, nYCoord
		
		IF thisform.lCanHide
			thisform.Visible = .F.
			thisform.lCanHide = .F.
		ENDIF
	ENDPROC

ENDDEFINE

DEFINE CLASS tuserdatectrl AS tdatectrl OF "main.vcx" 
 	*< CLASSDATA: Baseclass="textbox" Timestamp="" Scale="Pixels" Uniqueid="" />

	Name = "tuserdatectrl"
	
	PROCEDURE Init
		LPARAMETERS lp_lDoInit
		IF NOT lp_lDoInit
			RETURN .T.
		ENDIF
		
		this.oForm = thisform
		this.w = this.Width
		this.h = this.Height
		this.f = this.FontSize
		this.t = this.Top
		this.l = this.Left
		TRY
			this.lUseAlwaysOnTopDataPicker = (thisform.WindowType = 1)
		CATCH
		ENDTRY
		this.ToolTipText = GetLangText("COMMON","TT_PRESS_CTRL_L")
		IF EMPTY(this.ControlSource) AND EMPTY(this.Value)
			this.Value = {}
		ENDIF
		IF ocalendar && ocalendar is global variable
			LOCAL l_cNewObj
			this.Parent.AddObject(this.Name + "button", "tCommandDropDown")
			this.positionbutton()
			l_cNewObj = "this.Parent." + this.Name + "button"
			WITH &l_cNewObj
				.TabStop = .F.
				.oParent = this
				.Anchor = 240 && Needed when Init method is called after creating object. When resizing form, without this, drop down button wasn't resized
			ENDWITH
			this.ReadOnly = this.ReadOnly
			this.Enabled = this.Enabled
			this.Visible = this.Visible
		ENDIF
	ENDPROC

ENDDEFINE

DEFINE CLASS txtgrid AS ttext OF "main.vcx" 
 	*< CLASSDATA: Baseclass="textbox" Timestamp="" Scale="Pixels" Uniqueid="" />

	BorderStyle = 0
	DisabledBackColor = 10,36,106
	DisabledForeColor = 255,255,255
	Name = "txtgrid"
	
	PROCEDURE When
		this.BackColor=this.SelectedBackColor
		this.ForeColor=this.SelectedForeColor
		WITH This.Parent.Parent
			.nRecNo = RECNO( .RecordSource )
		ENDWITH
		RETURN DODEFAULT()
	ENDPROC

ENDDEFINE

DEFINE CLASS txttimemonthview AS textbox 
 	*< CLASSDATA: Baseclass="textbox" Timestamp="" Scale="Pixels" Uniqueid="" />

	BackStyle = 0
	BorderStyle = 0
	Height = 23
	Name = "txttimemonthview"
	Width = 100
	
	PROCEDURE KeyPress
		LPARAMETERS nKeyCode, nShiftAltCtrl
		LOCAL l_nXCoord, l_nYCoord
		
		DO CASE
			CASE nShiftAltCtrl = 0 AND nKeyCode = 108 OR nShiftAltCtrl = 2 AND nKeyCode = 12
				l_nXCoord = thisform.Left+SYSMETRIC(3)+OBJTOCLIENT(this,2)+OBJTOCLIENT(this,3)
				l_nYCoord = thisform.Top+SYSMETRIC(4)+SYSMETRIC(9)+OBJTOCLIENT(this,1)+OBJTOCLIENT(this,4)
				thisform.SetValue(this.Parent.ColumnOrder, l_nXCoord/6, l_nYCoord/16)
				NODEFAULT
			CASE nShiftAltCtrl = 0 AND nKeyCode = 7
				thisform.SetValue(this.Parent.ColumnOrder,,,999)
			CASE nShiftAltCtrl = 0 AND INLIST(nKeyCode, 3, 4, 5, 9, 18, 19, 24, 27)
			OTHERWISE
				NODEFAULT
		ENDCASE
		
		RETURN .T.
	ENDPROC

	PROCEDURE MouseUp
		LPARAMETERS nButton, nShift, nXCoord, nYCoord
		
		IF nButton = 2
			thisform.SetValue(this.Parent.ColumnOrder)
		ENDIF
	ENDPROC

ENDDEFINE
