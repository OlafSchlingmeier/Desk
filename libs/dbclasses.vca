*--------------------------------------------------------------------------------------------------------------------------------------------------------
* (ES) AUTOGENERADO - ¡¡ATENCIÓN!! - ¡¡NO PENSADO PARA EJECUTAR!! USAR SOLAMENTE PARA INTEGRAR CAMBIOS Y ALMACENAR CON HERRAMIENTAS SCM!!
* (EN) AUTOGENERATED - ATTENTION!! - NOT INTENDED FOR EXECUTION!! USE ONLY FOR MERGING CHANGES AND STORING WITH SCM TOOLS!!
*--------------------------------------------------------------------------------------------------------------------------------------------------------
*< FOXBIN2PRG: Version="1.19" SourceFile="dbclasses.vcx" /> (Solo para binarios VFP 9 / Only for VFP 9 binaries)
*
*
DEFINE CLASS cenvr AS custom 
 	*< CLASSDATA: Baseclass="custom" Timestamp="" Scale="Pixels" Uniqueid="" />

	*<DefinedPropArrayMethod>
		*m: addtable
		*m: inenvtables
		*m: restore
		*m: save
		*p: alrdopen
		*p: oldactiv
		*p: saved
		*a: envtables[1,2]
	*</DefinedPropArrayMethod>

	HIDDEN alrdopen,envtables,oldactiv,saved
	Name = "cenvr"
	
	PROCEDURE addtable
		LParameters TableAlias, TableName
		
		Local m.EnvTbNo, m.EnvTables
		
		if Empty(this.EnvTables[1, 1])
			m.EnvTbNo = 1
		else
			m.EnvTbNo = ALen(this.EnvTables, 1) + 1
		endif
		Dimension m.EnvTables(m.EnvTbNo, 2)
		
		ACopy(this.EnvTables, m.EnvTables)
		
		m.EnvTables[m.EnvTbNo, 1] = TableAlias
		m.EnvTables[m.EnvTbNo, 2] = TableName
		
		this.AddProperty("EnvTables(m.EnvTbNo, 2)")
		
		ACopy(m.EnvTables, this.EnvTables)
		
		this.Saved = .F.
		
	ENDPROC

	PROTECTED PROCEDURE inenvtables
		LParameters TAlias
		
		TAlias = Upper(TAlias)
		
		Local m.EnvTbNo, i
		m.EnvTbNo = ALen(this.EnvTables, 1)
		
		for i = 1 to m.EnvTbNo
			if Upper(this.EnvTables[i, 1]) == TAlias
				return .T.
			endif
		endfor
		
		return .F.
		
	ENDPROC

	PROCEDURE Init
		this.EnvTables[1, 1] = ""
		
	ENDPROC

	PROCEDURE restore
		LParameter m.ForceRestore
		
		Local m.EnvTbNo, i, m.AllTables, m.LRelNo, m.RelNo, m.CurrRel, m.CurrTarget, CMacro
		
		if NOT this.Saved
			return
		endif
		
		m.EnvTbNo = ALen(this.EnvTables, 1)
		
		for i = 1 to m.EnvTbNo
			if this.ArldOpen[i]
				if m.ForceRestore AND NOT Used(this.EnvTables[i, 1])
					Local m.TableName, m.TableAlias
					m.TableName = this.EnvTables[i, 2]
					m.TableAlias = this.EnvTables[i, 1]
		
					Select 0
					Use &TableName Alias &TableAlias
				endif
				if Used(this.EnvTables[i, 1])
					Select this.EnvTables[i, 1]
					Set Relation To
		
					CMacro = this.OldFilter[i]
					Set Order To this.OldOrder[i]
					Set Filter To &CMacro
					if this.OldRecNo[i] > 0
						Goto this.OldRecNo[i]
					else
						Goto bottom
						if NOT Eof()
							skip
						endif
					endif
				endif
			else
				if Used(this.EnvTables[i, 1])
					Select this.EnvTables[i, 1]
					Use
				endif
			endif
		endfor
		
		i = 1
		do while NOT Empty(this.OldRel[i, 1])
			if Used(this.OldRel[i, 1]) AND Used(this.OldRel[i, 3])
				CMacro = this.OldRel[i, 2]
				Set Relation To &CMacro Into this.OldRel[i, 3] In this.OldRel[i, 1] additive
			endif
			i = i + 1
		enddo
		
		CMacro = this.OldActiv
		if Empty(CMacro)
			Select 0
		else
			Select &CMacro
		endif
		
	ENDPROC

	PROCEDURE save
		Local m.EnvTbNo, i, m.AllTables, m.LRelNo, m.RelNo, m.CurrRel, m.CurrTarget
		
		if Empty(this.EnvTables[1, 1])
			return
		endif
		
		this.OldActiv = Alias()
		
		Dimension m.AllTables(1)
		m.EnvTbNo = AUsed(m.AllTables)
		
		this.AddProperty("OldRel(m.EnvTbNo, 3)")
		
		m.RelNo = 1
		for i = 1 to m.EnvTbNo
			Select m.AllTables[i, 2]
			m.LRelNo = 1
			do while .T.
				m.CurrRel = RELATION(1)
				if Empty(m.CurrRel)
					exit
				else
					m.CurrTarget = TARGET(1)
					if this.InEnvTables(m.AllTables[i, 1]) .OR. this.InEnvTables(m.CurrTarget)
						this.OldRel[m.RelNo, 1] = m.AllTables[i, 1]
						this.OldRel[m.RelNo, 2] = m.CurrRel
						this.OldRel[m.RelNo, 3] = m.CurrTarget
						m.RelNo = m.RelNo + 1
						SET RELATION OFF INTO m.CurrTarget
					endif
					m.LRelNo = m.LRelNo + 1
				endif
			enddo
		endfor
		this.OldRel[m.RelNo, 1] = ""
		
		m.EnvTbNo = ALen(this.EnvTables, 1)
		this.AddProperty("ArldOpen(m.EnvTbNo)")
		this.AddProperty("OldRecNo(m.EnvTbNo)")
		this.AddProperty("OldFilter(m.EnvTbNo)")
		this.AddProperty("OldOrder(m.EnvTbNo)")
		
		for i = 1 to m.EnvTbNo
			if Used(this.EnvTables[i, 1])
				this.ArldOpen[i] = .T.
		
				Select this.EnvTables[i, 1]
		
				if NOT Eof()
					this.OldRecNo[i] = RecNo()
				else
					this.OldRecNo[i] = -1
				endif
				this.OldFilter[i] = Filter()
				this.OldOrder[i] = Order()
				Set Order To
				Set Filter To
				Goto Top
			else
				Local m.TableName, m.TableAlias
				m.TableName = this.EnvTables[i, 2]
				m.TableAlias = this.EnvTables[i, 1]
		
				this.ArldOpen[i] = .F.
				Select 0
				Use &TableName Alias &TableAlias shared
				goto top
			endif
		endfor
		
		this.Saved = .T.
		
	ENDPROC

ENDDEFINE

DEFINE CLASS companydcclass AS custom 
 	*< CLASSDATA: Baseclass="custom" Timestamp="" Scale="Pixels" Uniqueid="" />

	#INCLUDE "..\include\constdefines.h"
	*<DefinedPropArrayMethod>
		*m: check
		*m: findfirst
		*p: firstrecno
	*</DefinedPropArrayMethod>

	HIDDEN firstrecno
	Name = "companydcclass"
	
	PROCEDURE check
		if Empty(ad_company)
			goto this.FirstRecNo
		endif
		
	ENDPROC

	PROCEDURE findfirst
		Local m.OldOrder, m.OldRecNo, i, m.AdrRecCount, m.EmptyCount, m.AdrRecNo
		
		Select Address1
		m.OldOrder = Order()
		m.OldRecNo = RecNo()
		
		set order to TAG3
		goto this.FirstRecNo
		if NOT Deleted() AND NOT Empty(ad_company)
			skip -1
			if Empty(ad_company)
				set order to m.OldOrder
		*		goto top
				goto m.OldRecNo
				return
			endif
		endif
		
		#define SAMPLE_RATE 100
		
		m.EmptyCount = 0
		
		m.AdrRecCount = RecCount()
		
		Rand(-1)
		for i = 1 to SAMPLE_RATE
			do while .T.
				m.AdrRecNo = Int(Rand() * m.AdrRecCount) + 1
				goto m.AdrRecNo
				if NOT Deleted()
					exit
				endif
			enddo
			if Empty(ad_company)
				m.EmptyCount = m.EmptyCount + 1
			endif
		endfor
		
		m.EmptyCount = Round(m.AdrRecCount * m.EmptyCount / SAMPLE_RATE, 0)
		
		if m.EmptyCount < 1000
			set order to TAG3
			goto top
			scan while Empty(ad_company)
			endscan
		else
			set order to TAG2
			goto bottom
		
			do while NOT Empty(ad_company)
				skip -1
			enddo
		
			set order to TAG3
			do while Empty(ad_company)
				skip
			enddo
		endif
		this.FirstRecNo = RecNo()
		
		set order to m.OldOrder
		goto m.OldRecNo
		
	ENDPROC

	PROCEDURE Init
		Select AddressTAlias
		this.FirstRecNo = RecNo()
		
	ENDPROC

ENDDEFINE

DEFINE CLASS namedcclass AS custom 
 	*< CLASSDATA: Baseclass="custom" Timestamp="" Scale="Pixels" Uniqueid="" />

	#INCLUDE "..\include\constdefines.h"
	*<DefinedPropArrayMethod>
		*m: check
		*m: findfirst
		*p: firstrecno
	*</DefinedPropArrayMethod>

	HIDDEN firstrecno
	Name = "namedcclass"
	
	PROCEDURE check
		return
		if Empty(ad_lname)
			goto this.FirstRecNo
		endif
		
	ENDPROC

	PROCEDURE findfirst
		Local m.OldOrder, m.OldRecNo, i, m.PartCount, m.AdrRecNo, m.nStep, m.RightCount
		return
		Select Address1
		m.OldOrder = Order()
		m.OldRecNo = RecNo()
		
		set order to TAG2
		goto this.FirstRecNo
		if NOT Deleted() AND NOT Empty(ad_lname)
			skip -1
			if Empty(ad_lname)
				set order to m.OldOrder
				goto m.OldRecNo
				return
			endif
		endif
		
		
		m.PartCount = RecCount()
		goto top
		m.nStep = Int(m.PartCount / 2)
		if 2 * m.nStep = m.PartCount
			m.RightCount = m.nStep - 1
		else
			m.RightCount = m.nStep
		endif
		skip m.nStep
		
		do while m.nStep <> 0
			if Empty(ad_lname)
				m.PartCount = m.RightCount
				m.nStep = Int(m.AdrRecCount / 2)
				m.LeftCount = m.nStep
				if 2 * m.nStep = m.PartCount
					m.RightCount = m.nStep - 1
				else
					m.RightCount = m.nStep
				endif
				skip m.nStep + 1
			else
				m.PartCount = m.nStep
				m.nStep = Int(m.AdrRecCount / 2)
				m.LeftCount = m.nStep
				if 2 * m.nStep = m.PartCount
					m.RightCount = m.nStep - 1
				else
					m.RightCount = m.nStep
				endif
				skip m.PartCount - m.nStep
			endif
		enddo
		
		this.FirstRecNo = RecNo()
		
		set order to m.OldOrder
		goto m.OldRecNo
		
	ENDPROC

	PROCEDURE Init
		Select AddressTAlias
		this.FirstRecNo = RecNo()
		
	ENDPROC

ENDDEFINE
