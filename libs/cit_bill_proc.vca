*--------------------------------------------------------------------------------------------------------------------------------------------------------
* (ES) AUTOGENERADO - ¡¡ATENCIÓN!! - ¡¡NO PENSADO PARA EJECUTAR!! USAR SOLAMENTE PARA INTEGRAR CAMBIOS Y ALMACENAR CON HERRAMIENTAS SCM!!
* (EN) AUTOGENERATED - ATTENTION!! - NOT INTENDED FOR EXECUTION!! USE ONLY FOR MERGING CHANGES AND STORING WITH SCM TOOLS!!
*--------------------------------------------------------------------------------------------------------------------------------------------------------
*< FOXBIN2PRG: Version="1.19" SourceFile="cit_bill_proc.vcx" /> (Solo para binarios VFP 9 / Only for VFP 9 binaries)
*
*
DEFINE CLASS billsplitposting AS custom 
 	*< CLASSDATA: Baseclass="custom" Timestamp="" Scale="Pixels" Uniqueid="" />

	*<DefinedPropArrayMethod>
		*m: extractsplits
		*m: split
		*m: splitarticle
		*m: splitratecode
		*p: cpostalias
		*p: csourcecursor
		*p: nsplitamount
	*</DefinedPropArrayMethod>

	cpostalias = postbuf
	csourcecursor = 
	Name = "billsplitposting"
	nsplitamount = 
	
	PROCEDURE extractsplits
		LPARAMETERS lp_cSourceCursor
		LOCAL l_nPercent, l_nOldRecord, l_nMarkCount, l_nSelect, l_cPostAlias, l_cPostSelCur, l_cPostCur, l_oPost, l_cSql, l_cRcName, l_lSuccess, l_nRet
		
		l_lSuccess = .T.
		this.cSourceCursor = lp_cSourceCursor
		l_cPostAlias = this.cPostAlias
		
		l_nSelect = SELECT()
		
		SELECT(this.cSourceCursor)
		
		l_nOldRecord = RECNO()
		l_nMarkCount = 0
		
		* Unmark normal postings (not ratecodes)
		REPLACE tw_mark WITH .F. FOR tw_mark AND EMPTY(ps_ratecod)
		
		* If no posting is marked, mark selected if it is ratecode
		COUNT FOR tw_mark TO l_nMarkCount
		GOTO l_nOldRecord
		IF l_nMarkCount = 0
			IF EMPTY(ps_ratecod)
				SELECT (l_nSelect)
				Alert(GetLangText("BILL", "TA_NO_SELECTED_RECORDS"))
				RETURN .F.
			ELSE
				REPLACE tw_mark WITH .T.
			ENDIF
		ENDIF
		
		* now process ratecode postings
		* Get all records for set
		TEXT TO l_cSql TEXTMERGE NOSHOW PRETEXT 15
		SELECT ps_rcname, ps_rccount, <<l_cPostAlias>>.ps_artinum, ar_lang<<g_langnum>> AS ar_lang, COUNT(<<l_cPostAlias>>.ps_artinum) AS ps_arcount, .F. AS ps_mark FROM <<l_cPostAlias>> 
			INNER JOIN <<this.cSourceCursor>> ON <<l_cPostAlias>>.ps_setid = <<this.cSourceCursor>>.ps_setid 
			INNER JOIN (SELECT LEFT(ps_ratecod,10) AS ps_rcname, COUNT(ps_ratecod) AS ps_rccount FROM <<this.cSourceCursor>> 
				WHERE tw_mark AND ps_setid > 0 GROUP BY 1) AS c1 ON LEFT(<<this.cSourceCursor>>.ps_ratecod,10) = c1.ps_rcname 
			INNER JOIN article ON <<l_cPostAlias>>.ps_artinum = ar_artinum 
			WHERE tw_mark AND <<this.cSourceCursor>>.ps_setid > 0 AND <<l_cPostAlias>>.ps_artinum <> <<this.cSourceCursor>>.ps_artinum 
			GROUP BY ps_rcname, ps_rccount, <<l_cPostAlias>>.ps_artinum, ar_lang
		ENDTEXT
		
		l_cPostCur = SqlCursor(l_cSql,,,,,,,.T.)
		
		SELECT &l_cPostCur
		l_cRcName = ""
		SCAN
			IF l_cRcName == ps_rcname
				BLANK FIELDS ps_rcname
			ELSE
				l_cRcName = ps_rcname
			ENDIF
		ENDSCAN
		GO TOP
		
		LOCAL ARRAY l_aDefs(6, 5)
		l_aDefs(1, 1) = "ps_rcname"
		l_aDefs(1, 2) = 70
		l_aDefs(1, 3) = GetLangText("BILL", "TXT_RATECODE")
		l_aDefs(1, 4) = "TXT"
		l_aDefs(2, 1) = "ps_rccount"
		l_aDefs(2, 2) = 40
		l_aDefs(2, 3) = GetLangText("BILL", "TXT_NO_OF_SELECTED")
		l_aDefs(2, 4) = "TXT"
		l_aDefs(3, 1) = "ps_artinum"
		l_aDefs(3, 2) = 40
		l_aDefs(3, 3) = GetLangText("BILL", "TXT_ARTINUM")
		l_aDefs(3, 4) = "TXT"
		l_aDefs(4, 1) = "ar_lang"
		l_aDefs(4, 2) = 150
		l_aDefs(4, 3) = GetLangText("BILL", "TXT_ARTICLE")
		l_aDefs(4, 4) = "TXT"
		l_aDefs(5, 1) = "ps_arcount"
		l_aDefs(5, 2) = 40
		l_aDefs(5, 3) = GetLangText("BILL", "TXT_NO_OF_RECORDS")
		l_aDefs(5, 4) = "TXT"
		l_aDefs(6, 1) = "ps_mark"
		l_aDefs(6, 2) = 25
		l_aDefs(6, 3) = GetLangText("BILL", "TXT_MARK")
		l_aDefs(6, 4) = "CHK"
		SELECT 0
		DO FORM Forms\BrwMulSel WITH l_cPostCur, l_aDefs, GetLangText("BILL", "TXT_ARTICLE"), .F., .T. TO l_nRet
		IF NOT EMPTY(l_nRet)
			TEXT TO l_cSql TEXTMERGE NOSHOW PRETEXT 15
			SELECT DISTINCT <<l_cPostAlias>>.ps_postid FROM <<l_cPostAlias>>
				INNER JOIN <<this.cSourceCursor>> ON <<l_cPostAlias>>.ps_setid = <<this.cSourceCursor>>.ps_setid
				INNER JOIN <<l_cPostCur>> ON <<l_cPostAlias>>.ps_artinum = <<l_cPostCur>>.ps_artinum
				WHERE <<l_cPostCur>>.ps_mark AND <<this.cSourceCursor>>.tw_mark AND <<this.cSourceCursor>>.ps_setid > 0
			ENDTEXT
			l_cPostSelCur = SqlCursor(l_cSql)
		
			SELECT &l_cPostSelCur
			SCAN FOR SEEK(ps_postid, l_cPostAlias, "tag3")
			    SELECT &l_cPostAlias
				SCATTER NAME l_oPost
				BLANK FIELDS ps_ratecod, ps_setid, ps_split
				REPLACE ps_touched WITH .T.
				REPLACE ps_amount WITH ps_amount - l_oPost.ps_amount, ;
						ps_price WITH ps_amount / ps_units, ;
						ps_vat0 WITH ps_vat0 - l_oPost.ps_vat0, ;
						ps_vat1 WITH ps_vat1 - l_oPost.ps_vat1, ;
						ps_vat2 WITH ps_vat2 - l_oPost.ps_vat2, ;
						ps_vat3 WITH ps_vat3 - l_oPost.ps_vat3, ;
						ps_vat4 WITH ps_vat4 - l_oPost.ps_vat4, ;
						ps_vat5 WITH ps_vat5 - l_oPost.ps_vat5, ;
						ps_vat6 WITH ps_vat6 - l_oPost.ps_vat6, ;
						ps_vat7 WITH ps_vat7 - l_oPost.ps_vat7, ;
						ps_vat8 WITH ps_vat8 - l_oPost.ps_vat8, ;
						ps_vat9 WITH ps_vat9 - l_oPost.ps_vat9, ;
						ps_touched WITH .T. ;
						FOR ps_setid = l_oPost.ps_setid AND NOT ps_split	&& Correct ratecode main article
			    SELECT &l_cPostSelCur
			ENDSCAN
			dclose(l_cPostSelCur)
			DoTableUpdate(.T.,.T.,l_cPostAlias)
			l_lSuccess = EndTransaction()
		ENDIF
		
		dclose(l_cPostCur)
		* Unmark all
		SELECT (this.cSourceCursor)
		
		REPLACE tw_mark WITH .F. ALL
		GOTO l_nOldRecord
		
		SELECT (l_nSelect)
		
		RETURN l_lSuccess
	ENDPROC

	PROCEDURE split
		LPARAMETERS lp_cSourceCursor, lp_nSplitAmount, lp_nPercent
		LOCAL l_nPercent, l_oBillWin, l_nOldRecord, l_cRecSource, l_nMarkCount, l_nSelect, l_cPost, l_lSuccess
		
		l_lSuccess = .T.
		this.cSourceCursor = lp_cSourceCursor
		this.nSplitAmount = lp_nSplitAmount
		l_cPost = this.cPostAlias
		
		IF NOT EMPTY(lp_nPercent)
			this.nSplitAmount = 0
			l_nPercent = lp_nPercent
		ELSE
			this.nSplitAmount = lp_nSplitAmount
			l_nPercent = 0
		ENDIF
		
		l_nSelect = SELECT()
		
		SELECT(this.cSourceCursor)
		
		l_nOldRecord = RECNO()
		l_nMarkCount = 0
		
		* If no posting is marked, mark selected
		COUNT FOR tw_mark TO l_nMarkCount
		GOTO l_nOldRecord
		IF l_nMarkCount = 0
			REPLACE tw_mark WITH .T.
		ENDIF
		
		* First process normal postings
		SCAN FOR tw_mark AND EMPTY(ps_ratecod) AND l_lSuccess
			=SEEK(ps_postid, l_cPost, "tag3")
			IF l_nPercent>0
				this.nSplitAmount = ROUND(&l_cPost..ps_amount * l_nPercent / 100, param.pa_currdec)
			ENDIF
			l_lSuccess = this.SplitArticle()
			REPLACE tw_mark WITH .F.
		ENDSCAN
		
		* now process ratecode postings
		SCAN FOR tw_mark AND NOT EMPTY(ps_ratecod) AND l_lSuccess
			=SEEK(ps_postid, l_cPost, "tag3")
			IF l_nPercent>0
				this.nSplitAmount = ROUND(&l_cPost..ps_amount * l_nPercent / 100, param.pa_currdec)
			ENDIF
			l_lSuccess = this.SplitRatecode()
			REPLACE tw_mark WITH .F.
		ENDSCAN
		GOTO l_nOldRecord
		
		RETURN l_lSuccess
	ENDPROC

	PROCEDURE splitarticle
		LOCAL l_oOldPost, l_oNewPost, l_nOldArea, l_nOldRec, l_lSuccess
		LOCAL l_nAmount, l_nVat1, l_nVat2, l_nVat3, l_nVat4, l_nVat5, l_nVat6, l_nVat7, l_nVat8, l_nVat9, l_nVat0
		l_nOldRec = RECNO()
		l_nOldArea = SELECT()
		l_cPostAlias = this.cPostAlias
		l_lSuccess = .T.
		IF (&l_cPostAlias..ps_artinum>0 AND this.nSplitAmount>0 AND this.nSplitAmount<&l_cPostAlias..ps_amount) OR ;
				(&l_cPostAlias..ps_artinum>0 AND &l_cPostAlias..ps_artinum=_screen.oGlobal.oParam.pa_depxfer AND ;
				this.nSplitAmount<0 AND this.nSplitAmount>&l_cPostAlias..ps_amount) OR ;
				(&l_cPostAlias..ps_paynum>0 AND this.nSplitAmount<0 AND this.nSplitAmount>&l_cPostAlias..ps_amount)
			
			* We allow special case for deposit article with negative amount
			
			SELECT (l_cPostAlias)
			SCATTER MEMVAR
			l_nAmount = m.ps_amount
			l_nVat0 = m.ps_vat0
			l_nVat1 = m.ps_vat1
			l_nVat2 = m.ps_vat2
			l_nVat3 = m.ps_vat3
			l_nVat4 = m.ps_vat4
			l_nVat5 = m.ps_vat5
			l_nVat6 = m.ps_vat6
			l_nVat7 = m.ps_vat7
			l_nVat8 = m.ps_vat8
			l_nVat9 = m.ps_vat9
			m.ps_amount = m.ps_amount-this.nSplitAmount
			IF (&l_cPostAlias..ps_artinum>0 .AND. this.nSplitAmount>0 .AND. this.nSplitAmount<l_nAmount)
				m.ps_units = 1
				m.ps_price = m.ps_amount
			ELSE
				m.ps_units = -m.ps_amount
				m.ps_price = 1
			ENDIF
			m.ps_vat0 = m.ps_vat0*(l_nAmount-this.nSplitAmount)/l_nAmount
			m.ps_vat1 = m.ps_vat1*(l_nAmount-this.nSplitAmount)/l_nAmount
			m.ps_vat2 = m.ps_vat2*(l_nAmount-this.nSplitAmount)/l_nAmount
			m.ps_vat3 = m.ps_vat3*(l_nAmount-this.nSplitAmount)/l_nAmount
			m.ps_vat4 = m.ps_vat4*(l_nAmount-this.nSplitAmount)/l_nAmount
			m.ps_vat5 = m.ps_vat5*(l_nAmount-this.nSplitAmount)/l_nAmount
			m.ps_vat6 = m.ps_vat6*(l_nAmount-this.nSplitAmount)/l_nAmount
			m.ps_vat7 = m.ps_vat7*(l_nAmount-this.nSplitAmount)/l_nAmount
			m.ps_vat8 = m.ps_vat8*(l_nAmount-this.nSplitAmount)/l_nAmount
			m.ps_vat9 = m.ps_vat9*(l_nAmount-this.nSplitAmount)/l_nAmount
			m.ps_touched = .T.
			SCATTER NAME l_oOldPost
			GATHER MEMVAR
			SELECT(this.cSourceCursor)
			GATHER MEMVAR
			*FLUSH
			m.ps_amount = this.nSplitAmount
			IF &l_cPostAlias..ps_artinum>0 AND this.nSplitAmount>0 AND this.nSplitAmount<l_nAmount
				m.ps_units = 1
				m.ps_price = m.ps_amount
			ELSE
				m.ps_units = -m.ps_amount
				m.ps_price = 1
			ENDIF
			m.ps_vat0 = l_nVat0*this.nSplitAmount/l_nAmount
			m.ps_vat1 = l_nVat1*this.nSplitAmount/l_nAmount
			m.ps_vat2 = l_nVat2*this.nSplitAmount/l_nAmount
			m.ps_vat3 = l_nVat3*this.nSplitAmount/l_nAmount
			m.ps_vat4 = l_nVat4*this.nSplitAmount/l_nAmount
			m.ps_vat5 = l_nVat5*this.nSplitAmount/l_nAmount
			m.ps_vat6 = l_nVat6*this.nSplitAmount/l_nAmount
			m.ps_vat7 = l_nVat7*this.nSplitAmount/l_nAmount
			m.ps_vat8 = l_nVat8*this.nSplitAmount/l_nAmount
			m.ps_vat9 = l_nVat9*this.nSplitAmount/l_nAmount
			m.ps_touched = .T.
			m.ps_setid = 0
			m.ps_postid = nextid('post')
			SELECT (l_cPostAlias)
			APPEND BLANK
			GATHER MEMVAR
			DoTableUpdate(.T.,.T.,l_cPostAlias)
			l_lSuccess = EndTransaction()
			IF l_lSuccess
				SCATTER NAME l_oNewPost
				PostHistory(l_oOldPost, l_oNewPost, "SPLITTED")
			ENDIF
		ENDIF
		SELECT(l_nOldArea)
		GOTO l_nOldRec
		
		RETURN l_lSuccess
	ENDPROC

	PROCEDURE splitratecode
		LOCAL l_nRecNo, l_nSelect, l_cSql, l_nSetId, l_nArtiNum, l_cVatMacro, l_nVatAmount, l_cUsCur, ;
			l_oChoose, l_oProp, l_nMainSplitOld, l_nSetIdNew, l_nSumSplitOld, l_nMainSplitPostId, ;
			l_oData, l_cPostAlias, l_lSuccess, l_oOldPost, l_oNewPost, l_cPostCur, l_oNew, l_oOld, l_oVats
		l_lSuccess = .T.
		l_cPostAlias = this.cPostAlias
		
		* Main condition
		IF NOT (&l_cPostAlias..ps_artinum>0 AND this.nSplitAmount>0 AND this.nSplitAmount<&l_cPostAlias..ps_amount)
			RETURN .F.
		ENDIF
		
		l_nSelect = SELECT()
		l_nSetId = &l_cPostAlias..ps_setid
		l_nArtiNum = 0
		l_nSumSplitOld = 0
		l_cUsCur = SYS(2015)
		l_nMainSplitOld = 0
		
		* Get all records for set
		TEXT TO l_cSql TEXTMERGE NOSHOW PRETEXT 15
		SELECT post.*, <<"ar_lang"+g_langnum>> AS ar_lang, ar_price, ar_vat, pl_numval AS vatpct ;
			FROM post ;
			INNER JOIN ( ;
						SELECT ps_setid FROM post ;
								INNER JOIN article ON ps_artinum = ar_artinum ;
								WHERE ps_setid = <<sqlcnv(l_nSetId,.T.)>> ;
								GROUP BY 1 ;
						) AS c1 ON post.ps_setid = c1.ps_setid ;
			INNER JOIN article ON ps_artinum = ar_artinum ;
			INNER JOIN picklist ON pl_label = "VATGROUP" AND pl_numcod = ar_vat ;
			ORDER BY ps_postid
		ENDTEXT
		
		l_cPostCur = sqlcursor(l_cSql,"",.F.,"",.NULL.,.T.)
		
		* Create cursors for changes
		SELECT * FROM (l_cPostCur) INTO CURSOR curSource READWRITE
		SELECT * FROM (l_cPostCur) WHERE .F. INTO CURSOR curTarget READWRITE
		
		* Copy split records into cursor for grid
		SELECT ps_artinum, ar_lang, ps_amount, ps_units, ps_price, ps_price AS ps_oldprc, ps_postid, ps_split, 1 AS cur_main ;
				FROM (l_cPostCur) WHERE ps_split ;
				INTO CURSOR (l_cUsCur) READWRITE
		SCAN ALL
			IF RECNO()=RECCOUNT()
				* as default, assign splited amount to main split article
				REPLACE ps_price WITH this.nSplitAmount, ;
						ps_oldprc WITH this.nSplitAmount, ;
						ps_amount WITH this.nSplitAmount, ;
						cur_main WITH 0
				l_nArtiNum = &l_cUsCur..ps_artinum
				l_nMainSplitPostId = &l_cUsCur..ps_postid
			ELSE
				REPLACE ps_price WITH 0, ;
						ps_amount WITH 0
			ENDIF
		ENDSCAN
		GO TOP
		IF RECCOUNT()>1
			* If we have more then 1 split article, show splited articles to user.
			* He can now choose, which split articles should receive new amount.
			
			* Sort first main split
			INDEX ON STR(cur_main,1) + STR(ps_postid,8) TAG TAG1
			
			l_oProp = CREATEOBJECT("Empty")
			ADDPROPERTY(l_oProp,"lok",.F.)
			ADDPROPERTY(l_oProp,"ccursor",l_cUsCur)
			ADDPROPERTY(l_oProp,"nsplit",this.nSplitAmount)
			ADDPROPERTY(l_oProp,"nMainPostId",l_nMainSplitPostId)
			l_oChoose = NEWOBJECT("billsplitarticleratecode","cit_bill")
			l_oChoose.oProp = l_oProp
			l_oChoose.Show(1)
			IF NOT l_oProp.lok
				dclose(l_cUsCur)
				dclose(l_cPostCur)
				SELECT(l_nSelect)
				RETURN .T.
			ENDIF
			SET ORDER TO "" IN (l_cPostCur)
		ENDIF
		
		* We know, that records are ordered in set so:
		* First main article, ps_split = .F.
		* Then all split articles
		* At end main article ps_split = .T.
		
		l_nSetIdNew = nextid("SPLITSET")
		
		SELECT (l_cPostCur)
		SCAN ALL
			SCATTER NAME l_oOld MEMO
			SCATTER NAME l_oNew MEMO
		
			* When we spliting some posting, then we change only price. So we must change only ps_amount in ps_units*ps_price.
			STORE .T. TO l_oOld.ps_touched, l_oNew.ps_touched
		
			DO CASE
				CASE NOT l_oOld.ps_split
		
					* Main not split article. This comes first.
					* Here we write new price for new record.
					l_oNew.ps_price = this.nSplitAmount
				
					* We must adjust old record.
					l_oOld.ps_price = l_oOld.ps_price - l_oNew.ps_price
					l_nMainSplitOld = l_oOld.ps_price
		
				CASE l_oOld.ps_postid = l_nMainSplitPostId
		
					* Main split article. This is comming last.
					= dlocate(l_cUsCur,"ps_postid = "+sqlcnv(l_oNew.ps_postid))
					l_oNew.ps_price = &l_cUsCur..ps_price
					l_oOld.ps_price = l_nMainSplitOld - l_nSumSplitOld
				OTHERWISE
		
					* split article
					= dlocate(l_cUsCur,"ps_postid = "+sqlcnv(l_oNew.ps_postid))
					l_oNew.ps_price = &l_cUsCur..ps_price
					l_oOld.ps_price = l_oOld.ps_price - l_oNew.ps_price
					l_nSumSplitOld = l_nSumSplitOld + l_oOld.ps_units*l_oOld.ps_price
		
			ENDCASE
		
			* Amount and price have same amount, becouse quantity is 1
			l_oNew.ps_amount = l_oNew.ps_units*l_oNew.ps_price
			l_oOld.ps_amount = l_oOld.ps_units*l_oOld.ps_price
		
			* Update old record
			* Delete all VATs
			
			SELECT cursource
			IF dlocate("cursource","ps_postid = "+sqlcnv(&l_cPostCur..ps_postid))
				
				STORE 0 TO l_oOld.ps_vat1, l_oOld.ps_vat2, l_oOld.ps_vat3, l_oOld.ps_vat4, l_oOld.ps_vat5, l_oOld.ps_vat6, l_oOld.ps_vat7, l_oOld.ps_vat8, l_oOld.ps_vat9
				IF NOT &l_cPostCur..ps_split
					* Multiple vats for main article
					* We calculate this am end
				ELSE
					l_cVatMacro = "l_oOld.ps_vat"+LTRIM(STR(l_oOld.ar_vat))
					l_nVatAmount = l_oOld.ps_amount * l_oOld.vatpct / (100 + IIF(param.pa_exclvat, 0, l_oOld.vatpct))
					&l_cVatMacro = l_nVatAmount
				ENDIF
				GATHER NAME l_oOld MEMO
				
				* Insert new record
				STORE 0 TO l_oNew.ps_vat1, l_oNew.ps_vat2, l_oNew.ps_vat3, l_oNew.ps_vat4, l_oNew.ps_vat5, l_oNew.ps_vat6, l_oNew.ps_vat7, l_oNew.ps_vat8, l_oNew.ps_vat9
				
				IF NOT &l_cPostCur..ps_split
					* Multiple vats for main article
					* We calculate this am end
				ELSE
					l_cVatMacro = "l_oNew.ps_vat"+LTRIM(STR(l_oNew.ar_vat))
					l_nVatAmount = l_oNew.ps_amount * l_oNew.vatpct / (100 + IIF(param.pa_exclvat, 0, l_oNew.vatpct))
					&l_cVatMacro = l_nVatAmount
				ENDIF
				l_oNew.ps_postid = nextid("POST")
				l_oNew.ps_setid = l_nSetIdNew
				
				INSERT INTO curtarget FROM NAME l_oNew
			ELSE
				l_lSuccess = .F.
				EXIT
			ENDIF
		ENDSCAN
		
		IF l_lSuccess
			* now calculate vats for main article
		
			* source
			SELECT SUM(ps_vat1) AS ps_vat1, ;
					SUM(ps_vat2) AS ps_vat2, ;
					SUM(ps_vat3) AS ps_vat3, ;
					SUM(ps_vat4) AS ps_vat4, ;
					SUM(ps_vat5) AS ps_vat5, ;
					SUM(ps_vat6) AS ps_vat6, ;
					SUM(ps_vat7) AS ps_vat7, ;
					SUM(ps_vat8) AS ps_vat8, ;
					SUM(ps_vat9) AS ps_vat9 ;
					FROM cursource ;
					WHERE ps_split ;
					INTO CURSOR curvatssource
			SCATTER NAME l_oVats
			IF dlocate("cursource","NOT ps_split")
				SELECT cursource
				GATHER NAME l_oVats
			ENDIF
		
			* target
			SELECT SUM(ps_vat1) AS ps_vat1, ;
					SUM(ps_vat2) AS ps_vat2, ;
					SUM(ps_vat3) AS ps_vat3, ;
					SUM(ps_vat4) AS ps_vat4, ;
					SUM(ps_vat5) AS ps_vat5, ;
					SUM(ps_vat6) AS ps_vat6, ;
					SUM(ps_vat7) AS ps_vat7, ;
					SUM(ps_vat8) AS ps_vat8, ;
					SUM(ps_vat9) AS ps_vat9 ;
					FROM curtarget ;
					WHERE ps_split ;
					INTO CURSOR curvatstarget
			SCATTER NAME l_oVats
			IF dlocate("curtarget","NOT ps_split")
				SELECT curtarget
				GATHER NAME l_oVats
			ENDIF
		
			* Now write changes to table
			SELECT cursource
			SCAN ALL
				SCATTER NAME l_oData MEMO
				IF SEEK(l_oData.ps_postid,l_cPostAlias,"tag3")
					SELECT (l_cPostAlias)
					GATHER NAME l_oData MEMO
				ENDIF
			ENDSCAN
			SELECT curtarget
			SCAN ALL
				SCATTER NAME l_oData MEMO
				INSERT INTO (l_cPostAlias) FROM NAME l_oData
			ENDSCAN
			
			DoTableUpdate(.T.,.T.,l_cPostAlias)
			l_lSuccess = EndTransaction()
			
			IF l_lSuccess
				* Write to log
				SELECT (l_cPostCur)
				SCAN ALL
					SCATTER NAME l_oOldPost MEMO
					GO RECNO(l_cPostCur) IN curtarget
					SELECT curtarget
					SCATTER NAME l_oNewPost MEMO
					PostHistory(l_oOldPost, l_oNewPost, "SPLITTED")
				ENDSCAN
			ENDIF
		ENDIF
		dclose(l_cPostCur)
		dclose(l_cUsCur)
		dclose("curvatssource")
		dclose("curvatstarget")
		dclose("cursource")
		dclose("curtarget")
		
		SELECT (l_nSelect)
		
		RETURN l_lSuccess
	ENDPROC

ENDDEFINE
