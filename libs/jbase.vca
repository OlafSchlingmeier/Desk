*--------------------------------------------------------------------------------------------------------------------------------------------------------
* (ES) AUTOGENERADO - ¡¡ATENCIÓN!! - ¡¡NO PENSADO PARA EJECUTAR!! USAR SOLAMENTE PARA INTEGRAR CAMBIOS Y ALMACENAR CON HERRAMIENTAS SCM!!
* (EN) AUTOGENERATED - ATTENTION!! - NOT INTENDED FOR EXECUTION!! USE ONLY FOR MERGING CHANGES AND STORING WITH SCM TOOLS!!
*--------------------------------------------------------------------------------------------------------------------------------------------------------
*< FOXBIN2PRG: Version="1.19" SourceFile="jbase.vcx" /> (Solo para binarios VFP 9 / Only for VFP 9 binaries)
*
*
DEFINE CLASS cbodb AS jcombobox OF "jbase.vcx" 
 	*< CLASSDATA: Baseclass="combobox" Timestamp="" Scale="Pixels" Uniqueid="" />

	*<DefinedPropArrayMethod>
		*m: beforeinteractivechange
		*m: beforevalueinsertintorowsource		&& Here put code to retrieve value which is displayed in combo value. Used when combo controlsource is id, but user sees in combo real value.
		*m: getrowsource
		*m: getrowsourcebefore		&& Put here SQL statment to populate combolist
		*m: getrowsourceconditionunchanged		&& Put here code, to detect that where condition to populate rowsource is changed, so that we must get it again.
		*m: getrowsourcereset
		*m: oninteractivechange
		*m: valueinsertintorowsource
		*m: valueinsertintorowsourceuserinputdata
		*p: controlsourcefieldtype		&& Type of field in ctempcurname cursor.
		*p: controlsourcefieldtype2		&& Type of 2. field in ctempcurname cursor. Used when lBoundTo2Column is .T.
		*p: crowsourceboundfield		&& Enter here name of field from rowsource, which is bounded to controlsource.
		*p: ctempcurname		&& Name of cursor with values, which come to value propery.
		*p: cwhere		&& Where condition for SQL to populate combo list. Used to detect change in where condition.
		*p: jcursoruserinserted		&& Name of cursor with user inserted data
		*p: lallowautoinsert		&& .T. - Allow user to enter custom data into combobox. Entered data would be added to combolist.
		*p: lboundto2column		&& Set to .T., when controlsource is bound to id, not to value which user can see.
		*p: ldelayinit		&& Set .T., when you handle manualy init of combo later, perahps in form.init
		*p: lresetrowsourceonlostfocus		&& .T. - When lostfocus, delete all from rowsource, and switch in mode where only 1 record in rowsource is automaticly generated. Use it when rowlist can change on every value change.
	*</DefinedPropArrayMethod>

	controlsourcefieldtype = c(254)		&& Type of field in ctempcurname cursor.
	controlsourcefieldtype2 = 		&& Type of 2. field in ctempcurname cursor. Used when lBoundTo2Column is .T.
	crowsourceboundfield = 		&& Enter here name of field from rowsource, which is bounded to controlsource.
	ctempcurname = 		&& Name of cursor with values, which come to value propery.
	cwhere = 		&& Where condition for SQL to populate combo list. Used to detect change in where condition.
	DisabledForeColor = 0,0,0
	Format = "KR"
	jcursoruserinserted = 		&& Name of cursor with user inserted data
	lallowautoinsert = .F.		&& .T. - Allow user to enter custom data into combobox. Entered data would be added to combolist.
	lboundto2column = .F.		&& Set to .T., when controlsource is bound to id, not to value which user can see.
	ldelayinit = .F.		&& Set .T., when you handle manualy init of combo later, perahps in form.init
	lresetrowsourceonlostfocus = .F.		&& .T. - When lostfocus, delete all from rowsource, and switch in mode where only 1 record in rowsource is automaticly generated. Use it when rowlist can change on every value change.
	Name = "cbodb"
	
	PROCEDURE beforeinteractivechange
		IF NOT EMPTY(this.jcursor) AND USED(this.jcursor)
			this.OnInteractiveChange()
		ENDIF
	ENDPROC

	PROCEDURE beforevalueinsertintorowsource		&& Here put code to retrieve value which is displayed in combo value. Used when combo controlsource is id, but user sees in combo real value.
		LPARAMETERS lp_cNewDisplayValue
		RETURN lp_cNewDisplayValue
	ENDPROC

	PROCEDURE Destroy
		DODEFAULT()
		IF NOT EMPTY(this.cTempCurName)
			dclose(this.cTempCurName)
		ENDIF
		dclose(this.jcursoruserinserted)
	ENDPROC

	PROCEDURE DropDown
		this.GetRowSource()
		this.BeforeInteractiveChange()
		DODEFAULT()
	ENDPROC

	PROCEDURE getrowsource
		* Fill ComboBox RowSource.
		* When used ctempcurname cursor, we don't have real data in rowsource yet.
		IF USED(this.ctempcurname) OR NOT this.GetRowSourceConditionUnchanged()
			LOCAL l_cTempText
			l_cTempText = this.DisplayValue
			
			this.getrowsourcebefore()
		
			this.RowSource = ""
			this.RowSourceType= 3
		
			dclose(this.ctempcurname)
		
			IF this.lallowautoinsert
				IF NOT EMPTY(this.crowsourceboundfield)
					this.jcursorreadwrite = .T.
					this.jcursoruserinserted = SYS(2015)
				ELSE
					this.lallowautoinsert = .F.
				ENDIF
			ENDIF
			
			jcombobox::Init()
			
			IF this.lallowautoinsert
				* Use another temp cursor, to store what user has entered, and not in combolist.
				SELECT * FROM (this.jcursor) WHERE 0=1 INTO CURSOR (this.jcursoruserinserted) READWRITE
			ENDIF
			
			this.DisplayValue = l_cTempText
			this.SelStart = LEN(ALLTRIM(this.DisplayValue))
		ENDIF
	ENDPROC

	PROCEDURE getrowsourcebefore		&& Put here SQL statment to populate combolist
	ENDPROC

	PROCEDURE getrowsourceconditionunchanged		&& Put here code, to detect that where condition to populate rowsource is changed, so that we must get it again.
	ENDPROC

	PROCEDURE getrowsourcereset
		LOCAL l_uValue
		WITH this
			IF NOT USED(.ctempcurname)
				l_uValue = .Value
				.RowSource = ""
				.RowSourceType = 0
				.BoundTo = .F.
				.jsql = ""	
				.Init()
				dclose(.jcursor)
				.Value = l_uValue
			ENDIF
		ENDWITH
	ENDPROC

	PROCEDURE Init
		LPARAMETERS lp_lDoInit
		* Create temp cursor, and fill it when value changes.
		* Change combo settings for rowsource in getrowsourcebefore method!
		IF this.ldelayinit AND NOT lp_lDoInit
			RETURN .T.
		ENDIF
		
		IF this.ldelayinit
			* Delay init only once
			this.ldelayinit = .F.
		ENDIF
		
		LOCAL l_cMacro, l_cMacro2
		
		IF EMPTY(this.cTempCurName)
			this.cTempCurName = SYS(2015)
		ENDIF
		l_cMacro = this.controlsourcefieldtype
		IF NOT EMPTY(this.controlsourcefieldtype2)
			l_cMacro2 = this.controlsourcefieldtype2
		ELSE
			l_cMacro2 = l_cMacro
		ENDIF
		CREATE CURSOR (this.cTempCurName) (cs &l_cMacro, cs2 &l_cMacro2)
		APPEND BLANK
		
		WITH this
			IF .lboundto2column
				.BoundColumn = 2
			ENDIF
			.BoundTo = .T.
			.RowSourceType = 6
			.RowSource = this.cTempCurName
		ENDWITH
		
		DODEFAULT()
	ENDPROC

	PROCEDURE InteractiveChange
		this.GetRowSource()
		this.BeforeInteractiveChange()
		
		DODEFAULT()
	ENDPROC

	PROCEDURE LostFocus
		DODEFAULT()
		
		this.BeforeInteractiveChange()
		
		IF this.lresetrowsourceonlostfocus
			this.Getrowsourcereset()
		ENDIF
	ENDPROC

	PROCEDURE oninteractivechange
	ENDPROC

	PROCEDURE sqlrowsource
		DODEFAULT()
		
		IF NOT EMPTY(this.jcursoruserinserted) AND USED(this.jcursoruserinserted)
			LOCAL l_nSelect
			l_nSelect = SELECT()
			SELECT (this.jcursor)
			APPEND FROM DBF(this.jcursoruserinserted)
			SELECT (l_nSelect)
		ENDIF
	ENDPROC

	PROCEDURE Valid
		IF this.ValueInsertIntoRowSourceUserInputData()
			RETURN .T.
		ELSE
			RETURN DODEFAULT()
		ENDIF
		
		
		
	ENDPROC

	PROCEDURE valueinsertintorowsource
		* When new value is assigned to combobox, insert this value in ctempcurname cursor,
		* so this value can be displayed in combobox, without to pull all data in rowsoruce.
		
		LPARAMETERS vNewVal
		
		IF USED(this.ctempcurname)
			LOCAL l_cNewDisplayValue
			l_cNewDisplayValue = this.BeforeValueInsertIntoRowSource(vNewVal)
			IF this.lboundto2column
				REPLACE cs WITH l_cNewDisplayValue, ;
					cs2 WITH vNewVal IN (this.ctempcurname)
			ELSE
				REPLACE cs WITH l_cNewDisplayValue IN (this.ctempcurname)
			ENDIF
			this.Requery()
		ENDIF
	ENDPROC

	PROCEDURE valueinsertintorowsourceuserinputdata
		* Get what user insered in combo, and when this not exists in rowsource, add it, so
		* that value becomes also valid.
		
		IF this.lAllowAutoInsert AND NOT EMPTY(this.jcursor) AND USED(this.jcursor)
			LOCAL l_nSelect, l_oData, l_nRecNo, l_cMacro, l_cText
			l_nSelect = SELECT()
			l_nRecNo = RECNO(this.jcursor)
			l_cText = this.DisplayValue
		
			SELECT (this.jcursor)
			l_cMacro = this.crowsourceboundfield
			LOCATE FOR &l_cMacro = l_cText
		
			IF NOT FOUND()
				SCATTER NAME l_oData BLANK
				l_cMacro = "l_oData." + this.crowsourceboundfield
				&l_cMacro = l_cText
				INSERT INTO (this.jcursoruserinserted) FROM NAME l_oData
				this.Requery()
		
				SELECT (this.jcursor)
				LOCATE FOR &l_cMacro = l_cText
				this.DisplayValue = &l_cMacro
			ELSE
				GO l_nRecNo IN this.jcursor	
			ENDIF
		
			SELECT (l_nSelect)
			
			RETURN .T.
		ELSE
			RETURN .F.
		ENDIF
	ENDPROC

	PROCEDURE value_assign
		LPARAMETERS vNewVal
		this.ValueInsertIntoRowSource(vNewVal)
		DODEFAULT(vNewVal)
	ENDPROC

ENDDEFINE

DEFINE CLASS jcbomain AS jcombobox OF "jbase.vcx" 
 	*< CLASSDATA: Baseclass="combobox" Timestamp="" Scale="Pixels" Uniqueid="" />

	*<DefinedPropArrayMethod>
		*m: initsqlproperties
		*p: coldval
		*p: corder
		*p: csqlselect
		*p: csqlunion
		*p: cwhere
		*p: lappendblank
	*</DefinedPropArrayMethod>

	coldval = 
	ColumnLines = .F.
	corder = pl_charcod
	csqlselect = 
	csqlunion = UNION SELECT CAST('' AS Char(3)) AS pl_charcod, CAST(NULL AS Char(25)) AS pl_lang FROM param
	cwhere = NOT pl_inactiv
	DisabledForeColor = 0,0,0
	Format = "K"
	InputMask = (REPLICATE("!",3))
	jboundcolumn = 1
	jcolumnwidths = 50,150
	lappendblank = .T.
	ldisplayallcolumns = .T.
	Name = "jcbomain"
	SelectOnEntry = .T.
	
	PROCEDURE GotFocus
		this.cOldVal = this.Value
		DODEFAULT()
	ENDPROC

	PROCEDURE Init
		this.InitSqlProperties()
		this.jSql = this.cSqlSelect + " " + SqlWhere("", this.cWhere) + ;
			IIF(this.lAppendBlank, this.cSqlUnion, "") + ;
			IIF(EMPTY(this.cOrder), "", " ORDER BY " + this.cOrder)
		
		DODEFAULT()
		
		RETURN .T.
	ENDPROC

	PROCEDURE initsqlproperties
		TEXT TO this.cSqlSelect TEXTMERGE NOSHOW PRETEXT 2 + 8
			SELECT pl_charcod, pl_lang<<g_langnum>> AS pl_lang FROM picklist
		ENDTEXT
	ENDPROC

	PROCEDURE Valid
		IF NOT this.CheckListValues()
			this.Value = this.cOldVal
			KEYBOARD '{ALT+DNARROW}'
			RETURN 0
		ENDIF
		IF PEMSTATUS(thisform, "HndValid", 5)
			RETURN thisform.HndValid(this)
		ENDIF
	ENDPROC

ENDDEFINE

DEFINE CLASS jcombobox AS tcombobox OF "main.vcx" 
 	*< CLASSDATA: Baseclass="combobox" Timestamp="" Scale="Pixels" Uniqueid="" />

	*<DefinedPropArrayMethod>
		*m: evalfield
		*m: setcontrolsource
		*m: sqlrequery
		*m: sqlrowsource
		*m: value_assign
		*p: ecsql
		*p: jboundcolumn
		*p: jcolumncount
		*p: jcolumnwidths
		*p: jcursor
		*p: jcursorreadwrite		&& .T. - Created cursor with SQL for rowsource is READWRITE, so we can add another records later.
		*p: jrequired
		*p: jsql
		*p: ldisplayallcolumns
		*p: ldontsetcontrolsource		&& Set to .T., to prevent in init to ser controlsource (when combo used in grid)
		*p: lsqlcursorfromalias		&& When .T., dont use sqlcursor() function, perform SELECT SQL directly. Should be used when populating from cursor.
		*p: uparam1
	*</DefinedPropArrayMethod>

	BoundTo = .T.
	ecsql = 
	jboundcolumn = 0
	jcolumncount = 0
	jcolumnwidths = 
	jcursor = 
	jsql = 
	Name = "jcombobox"
	
	PROCEDURE Destroy
		IF !EMPTY(this.jcursor)
		     dclose(this.jcursor)
		ENDIF
	ENDPROC

	PROCEDURE evalfield
		LOCAL i, lnArea, lnRecno, lcField
		
		lnArea = SELECT()
		
		SELECT (this.jCursor)
		lnRecno = RECNO()
		
		FOR i = 1 TO FCOUNT()
			lcField = FIELD(i)
			IF TYPE(lcField) = "C" AND LEFT(&lcField,6) = "||EV||"
				TRY
					REPLACE &lcField WITH EVALUATE(SUBSTR(&lcField,7)) ALL
				CATCH
				ENDTRY
			ENDIF
		NEXT
		
		GO lnRecno
		
		SELECT (lnArea)
	ENDPROC

	PROCEDURE Init
		LOCAL ncol, nvalue
		WITH this
		     IF !EMPTY(.jsql)
		          .rowsource = ''
		          IF LEFT(.jsql, 7) = 'SELECT '
		               IF EMPTY(.jcursor)
		                    .jcursor = SYS(2015)
		               ELSE
		                    IF USED(.jcursor)
		                         USE IN (.jcursor)
		                    ENDIF
		               ENDIF
		               .rowsourcetype = 3
		               .SqlRequery()
		               ncol = FCOUNT(.jcursor)
		          ELSE
		               IF INLIST(LOWER(.jsql), "padow", "pamonths")
		                    nvalue = this.Value
		                    .rowsourcetype = 5
		                    .boundto = .F.
		                    .value = nvalue
		                    ncol = 1
		               ELSE
		                    .rowsourcetype = 1
		                    ncol = 2
		               ENDIF
		               .rowsource = .jsql
		          ENDIF
		          IF EMPTY(.jcolumncount)
		               .columncount = ncol
		          ELSE
		               .columncount = .jcolumncount
		          ENDIF
		          IF EMPTY(.jboundcolumn)
		               .boundcolumn = ncol
		          ELSE
		               .boundcolumn = .jboundcolumn
		          ENDIF
		          DO CASE
		               CASE NOT EMPTY(.jcolumnwidths)
		                    .columnwidths = .jcolumnwidths
		               CASE .lDisplayAllColumns AND ncol > 2
		                    .columnwidths = ntoc(.width - 8) + REPLICATE(',100', ncol - 2) + ',0'
		               OTHERWISE
		                    .columnwidths = ntoc(.width - 8) + REPLICATE(',0', ncol - 1)
		          ENDCASE
		          IF EMPTY(.controlsource) AND USED(.jcursor)
		               .value = blank(eval(.jcursor+'.'+field(.boundcolumn,.jcursor)))
		          ENDIF
		          IF NOT .lDontSetControlSource
		               .controlsource = .controlsource
		          ENDIF
		     ENDIF
		ENDWITH
		
		DODEFAULT()
		
		IF NOT this.lInitDone
		     this.lInitDone = .T.
		ENDIF
		
	ENDPROC

	PROCEDURE LostFocus
		DODEFAULT()
		IF LASTKEY() = 27
		     RETURN .T.
		ENDIF
		WITH this
		     IF .jrequired
		          IF EMPTY(.value)
		               alert("This field is required!")
		               .backcolor = RGB(255, 0, 0)
		          ELSE
		               .backcolor = RGB(255, 255, 255)
		          ENDIF
		     ENDIF
		ENDWITH
		RETURN .T.
	ENDPROC

	PROCEDURE setcontrolsource
		LPARAMETERS lp_cControlSource
		
		* Here initialize cursor
	ENDPROC

	PROCEDURE sqlrequery
		WITH this
			IF "__UPARAM1__" $ .jsql
				.ecsql = STRTRAN(.jsql, "__UPARAM1__",sqlcnv(.uparam1))
			ELSE
				.ecsql = .jsql
			ENDIF
		     .RowSource = 'this.sqlrowsource()'
		ENDWITH
	ENDPROC

	PROCEDURE sqlrowsource
		WITH this
			IF .lsqlcursorfromalias
				LOCAL l_cMacro
				l_cMacro = .ecsql + " INTO CURSOR " + .jcursor
				IF .jcursorreadwrite
					l_cMacro = l_cMacro + " READWRITE"
				ENDIF
				&l_cMacro
			ELSE
				=SqlCursor(.ecsql,.jcursor,,,,,,.jcursorreadwrite)
			ENDIF
			.EvalField()
		ENDWITH
	ENDPROC

	PROCEDURE value_assign
		LPARAMETERS vNewVal
		*To do: Modify this routine for the Assign method
		THIS.Value = m.vNewVal
		
	ENDPROC

ENDDEFINE

DEFINE CLASS jlistbox AS tlistbox OF "main.vcx" 
 	*< CLASSDATA: Baseclass="listbox" Timestamp="" Scale="Pixels" Uniqueid="" />

	*<DefinedPropArrayMethod>
		*m: setcontrolsource
		*m: sqlrequery
		*m: sqlrowsource
		*m: value_assign
		*p: ecsql
		*p: jboundcolumn
		*p: jcolumncount
		*p: jcolumnwidths
		*p: jcursor
		*p: jcursorreadwrite		&& .T. - Created cursor with SQL for rowsource is READWRITE, so we can add another records later.
		*p: jsql
		*p: ldisplayallcolumns
		*p: ldontsetcontrolsource		&& Set to .T., to prevent in init to ser controlsource (when combo used in grid)
		*p: linitdone
		*p: lsqlcursorfromalias		&& When .T., dont use sqlcursor() function, perform SELECT SQL directly. Should be used when populating from cursor.
		*p: uparam1
	*</DefinedPropArrayMethod>

	ecsql = 
	jboundcolumn = 0
	jcolumncount = 0
	jcolumnwidths = 
	jcursor = 
	jsql = 
	Name = "jlistbox"
	
	PROCEDURE Destroy
		IF NOT EMPTY(this.jCursor)
		     DClose(this.jCursor)
		ENDIF
	ENDPROC

	PROCEDURE Init
		LOCAL lnCol
		
		WITH this
		     IF NOT EMPTY(.jSql)
		          .RowSource = ''
		          IF LEFT(.jSql, 7) = 'SELECT '
		               IF EMPTY(.jCursor)
		                    .jCursor = SYS(2015)
		               ELSE
		                    DClose(.jCursor)
		               ENDIF
		               .RowSourceType = 3
		               .SqlRequery()
		               lnCol = FCOUNT(.jCursor)
		          ELSE
		               .RowSourceType = 1
		               .RowSource = .jSql
		               lnCol = 2
		          ENDIF
		          IF EMPTY(.jColumnCount)
		               .ColumnCount = lnCol
		          ELSE
		               .ColumnCount = .jColumnCount
		          ENDIF
		          IF EMPTY(.jBoundColumn)
		               .BoundColumn = lnCol
		          ELSE
		               .BoundColumn = .jBoundColumn
		          ENDIF
		          DO CASE
		               CASE NOT EMPTY(.jColumnWidths)
		                    .ColumnWidths = .jColumnWidths
		               CASE .lDisplayAllColumns AND lnCol > 2
		                    .ColumnWidths = ntoc(.Width - 8) + REPLICATE(',100', lnCol - 2) + ',0'
		               OTHERWISE
		                    .ColumnWidths = ntoc(.Width - 8) + REPLICATE(',0', lnCol - 1)
		          ENDCASE
		          IF EMPTY(.ControlSource) AND USED(.jCursor)
		               .Value = Blank(EVALUATE(.jCursor+'.'+FIELD(.BoundColumn,.jCursor)))
		          ENDIF
		          .ControlSource = .ControlSource
		     ENDIF
		ENDWITH
		
		
		IF NOT this.lInitDone
		     DODEFAULT()
		     this.lInitDone = .T.
		ENDIF
	ENDPROC

	PROCEDURE setcontrolsource
		LPARAMETERS tcControlSource
		* Here initialize cursor
	ENDPROC

	PROCEDURE sqlrequery
		WITH this
			IF "__UPARAM1__" $ .jSql
				.ecSql = STRTRAN(.jSql, "__UPARAM1__",sqlcnv(.uParam1))
			ELSE
				.ecSql = .jSql
			ENDIF
		     .RowSource = 'this.SqlRowSource()'
		ENDWITH
	ENDPROC

	PROCEDURE sqlrowsource
		LOCAL lcMacro
		
		WITH this
			IF .lSqlCursorFromAlias
				lcMacro = .ecSql + " INTO CURSOR " + .jCursor
				IF .jCursorReadWrite
					lcMacro = lcMacro + " READWRITE"
				ENDIF
				&lcMacro
			ELSE
				SqlCursor(.ecSql,.jCursor,,,,,,.jCursorReadWrite)
			ENDIF
		ENDWITH
	ENDPROC

	PROCEDURE value_assign
		LPARAMETERS tvNewVal
		*To do: Modify this routine for the Assign method
		this.Value = tvNewVal
	ENDPROC

ENDDEFINE
