*--------------------------------------------------------------------------------------------------------------------------------------------------------
* (ES) AUTOGENERADO - ¡¡ATENCIÓN!! - ¡¡NO PENSADO PARA EJECUTAR!! USAR SOLAMENTE PARA INTEGRAR CAMBIOS Y ALMACENAR CON HERRAMIENTAS SCM!!
* (EN) AUTOGENERATED - ATTENTION!! - NOT INTENDED FOR EXECUTION!! USE ONLY FOR MERGING CHANGES AND STORING WITH SCM TOOLS!!
*--------------------------------------------------------------------------------------------------------------------------------------------------------
*< FOXBIN2PRG: Version="1.19" SourceFile="cit_bridge.vcx" /> (Solo para binarios VFP 9 / Only for VFP 9 binaries)
*
*
DEFINE CLASS brilliantfunc AS functions OF "..\common\libs\cit_functions.vcx" 
 	*< CLASSDATA: Baseclass="custom" Timestamp="" Scale="Pixels" Uniqueid="" />

	Name = "brilliantfunc"
	
	PROCEDURE alert
		LPARAMETERS lp_cText, lp_cHeader, lp_nButtons
		alert(lp_cText)
		RETURN
	ENDPROC

	PROCEDURE dlocate
		LPARAMETERS tcAlias, tcExpr
		RETURN DLocate(tcAlias, tcExpr)
	ENDPROC

	PROCEDURE dlookup
		LPARAMETERS lp_cAlias, lp_cWhere, lp_cExpr, lp_lCache
		RETURN DLookUp(lp_cAlias, lp_cWhere, lp_cExpr, lp_lCache)
	ENDPROC

	PROCEDURE getdayname
		LPARAMETERS lp_dDate
		RETURN LEFT(MyCDoW(DOW(lp_dDate)),2)
	ENDPROC

	PROCEDURE getlanguagetext
		LPARAMETERS tcLabel, tcText, tuParam1, tuParam2, tuParam3, tuParam4, tuParam5, tuParam6, tuParam7, tuParam8, tuParam9
		LOCAL lcLabel, lcText
		
		DO CASE
			CASE GETWORDCOUNT(tcLabel,"|") > 1
				LOCAL lcContext, lcId
				lcContext = GETWORDNUM(tcLabel,1,"|")
				lcId = GETWORDNUM(tcLabel,3,"|")
				lcLabel = STRTRAN("T"+lcContext+" "+UPPER(IIF(lcContext="A", GETWORDNUM(tcLabel,2,"|"), tcText)), " ", "_")
				lcText = GetLangText(lcId,lcLabel)
			CASE VARTYPE(tcText) = "C"
				lcText = GetLangText(tcLabel, tcText)
			CASE UPPER(tcLabel) == "SUM"
				lcText = GetLangText("EMPLOYEE","TXT_SUM")
			CASE UPPER(tcLabel) == "ACCURATELY"
				lcText = GetLangText("EMPLOYEE","TXT_ACCURATELY")
			CASE UPPER(tcLabel) == "ROUND_UP"
				lcText = GetLangText("EMPLOYEE","TXT_ROUND_UP")
			CASE UPPER(tcLabel) == "ROUND_DOWN"
				lcText = GetLangText("EMPLOYEE","TXT_ROUND_DOWN")
			CASE UPPER(tcLabel) == "BY_NIGHT"
				lcText = GetLangText("FUNC","TXT_NIGHT")
			CASE UPPER(tcLabel) == "TXT_REQUIRED"
				lcText = GetLangText("EMPLOYEE","TXT_REQUIRED")
			CASE UPPER(tcLabel) == "TXT_INVALID_FIELD"
				lcText = GetLangText("EMPLOYEE","TXT_INVALID_FIELD")
			OTHERWISE
				lcText = ""
		ENDCASE
		
		lcText = DODEFAULT(tcLabel, lcText, tuParam1, tuParam2, tuParam3, tuParam4, tuParam5, tuParam6, tuParam7, tuParam8, tuParam9)
		
		RETURN lcText
	ENDPROC

	PROCEDURE getmaincompanylangcode
		RETURN GetHotelLangNum()
	ENDPROC

	PROCEDURE getusername
		LPARAMETERS tnType
		
		IF EMPTY(tnType) OR tnType # 1
			RETURN g_username			&& Return Username
		ELSE
			RETURN TRANSFORM(g_userid)	&& Return Userid
		ENDIF
	ENDPROC

	PROCEDURE nextid
		LPARAMETERS tcCode, tcAlias, tlForceLocal
		LOCAL lnNextId
		
		tcAlias = IIF(EMPTY(tcAlias), tcCode, tcAlias)
		
		IF NOT tlForceLocal AND param.pa_argus AND ALLTRIM(UPPER(param2.pa_argusdr)) $ DBF(tcAlias) AND ArgusFrontOfficeExists()
			lnNextId = ArgusOffice('NextId', tcCode)
		ELSE
			lnNextId = NextID(tcCode)
		ENDIF
		
		RETURN lnNextId
	ENDPROC

	PROCEDURE oncardpresent
		LOCAL loForm, llFormExists, lcContent1, lnForeColor1, lcContent2, lnForeColor2, luParam
		
		_screen.oCardReaderHandler.DisplayContent(.T., @lcContent1, @lnForeColor1, @lcContent2, @lnForeColor2)
		
		IF TYPE("_screen.ActiveForm") = "O"
			loForm = _screen.ActiveForm
			IF LOWER(loForm.ParentClass) = "crvisual"
				FOR EACH loForm IN _screen.Forms
					IF LOWER(loForm.BaseClass) <> "toolbar" AND NOT INLIST(LOWER(loForm.ParentClass), "crvisual") AND ;
							NOT INLIST(LOWER(loForm.Name), "messagesform", "frmnavpane", "tnbthemedoutlooknavbarfrm")
						llFormExists = .T.
						EXIT
					ENDIF
				NEXT
				IF NOT llFormExists
					loForm = .NULL.
				ENDIF
			ELSE
				IF INLIST(LOWER(loForm.Name), "messagesform", "frmnavpane", "tnbthemedoutlooknavbarfrm")
					loForm = .NULL.
				ENDIF
			ENDIF
		ELSE
			loForm = .NULL.
		ENDIF
		DO CASE
			CASE ISNULL(loForm)
				IF NOT EMPTY(_screen.oCardReaderHandler.Content.ReserId)
					IF Odbc()
						luParam = _screen.oCardReaderHandler.Content.ReserId
					ELSE
						luParam = this.DLookUp("reservat", "rs_rsid = " + this.SqlCnv(_screen.oCardReaderHandler.Content.ReserId), "RECNO()")
					ENDIF
					DoForm('resbrw','forms\resbrw with 1, ' + this.SqlCnv(luParam))
				ENDIF
			CASE UPPER(_screen.ActiveForm.Class) = "TFORM"
				DO CASE
					CASE NOT EMPTY(loForm.FormName) AND UPPER(loForm.FormName) = "KEYCARDFORM"
						loForm.Parent.DisplayContent(lcContent1, lnForeColor1)
					CASE NOT EMPTY(loForm.FormName) AND UPPER(loForm.FormName) = "BMSACCOUNTFORM"
						loForm.DisplayContent(lcContent2, lnForeColor2)
					OTHERWISE
				ENDCASE
			OTHERWISE
		ENDCASE
	ENDPROC

	PROCEDURE oncardremove
		LOCAL loForm, lcContent1, lnForeColor1, lcContent2, lnForeColor2
		
		_screen.oCardReaderHandler.DisplayContent(.F., @lcContent1, @lnForeColor1, @lcContent2, @lnForeColor2)
		
		DO CASE
			CASE TYPE("_screen.ActiveForm") # "O"
			CASE UPPER(_screen.ActiveForm.Class) = "TFORM"
				loForm = _screen.ActiveForm
				DO CASE
					CASE NOT EMPTY(loForm.FormName) AND UPPER(loForm.FormName) = "KEYCARDFORM"
						loForm.Parent.DisplayContent(lcContent1, lnForeColor1)
					CASE NOT EMPTY(loForm.FormName) AND UPPER(loForm.FormName) = "BMSACCOUNTFORM"
						loForm.DisplayContent(lcContent2, lnForeColor2)
					OTHERWISE
				ENDCASE
			OTHERWISE
		ENDCASE
	ENDPROC

	PROCEDURE pickavailtableform
		LPARAMETERS toTableRes
		
		DO FORM PickAvailTableForm WITH toTableRes
	ENDPROC

	PROCEDURE prepareenvironment
		LPARAMETERS tnDataSessionId, tcModule, tcTables
		LOCAL lnTableNo, lcTable
		
		this.ChangeDatasession(tnDataSessionId)
		DO CASE
			CASE tcModule == 'ARGUS'
				IF ArgusOffice(,,,,.T.)
					ArgusOffice("Use", tcTables)
				ENDIF
			CASE tcModule == 'BRILLIANT'
				FOR lnTableNo = 1 TO GETWORDCOUNT(tcTables,",")
					lcTable = ALLTRIM(GETWORDNUM(tcTables,lnTableNo,","))
					this.TbOpen(lcTable,"FO"+lcTable)
				NEXT
			OTHERWISE
		ENDCASE
	ENDPROC

	PROCEDURE restoreenvironment
		LPARAMETERS tnDataSessionId, tcModule
		
		DO CASE
			CASE tcModule == 'ARGUS'
				ArgusOffice("Exit")
			OTHERWISE
		ENDCASE
		this.RestoreDatasession()
	ENDPROC

	PROCEDURE sqlcnv
		LPARAMETERS lp_uExpr, lp_lForceOdbc
		RETURN sqlcnv(lp_uExpr, lp_lForceOdbc)
	ENDPROC

	PROCEDURE sqlcursor
		LPARAMETERS lp_cSql, lp_cCursor, lp_lNoFilter, lp_cSqlDef, lp_oParam, lp_lRemovesign, lp_aResult, lp_nDatasessionId
		LOCAL l_cCurName
		this.changedatasession(lp_nDatasessionId)
		l_cCurName = sqlcursor(lp_cSql, lp_cCursor, lp_lNoFilter, lp_cSqlDef, lp_oParam, lp_lRemovesign, lp_aResult)
		this.Restoredatasession()
		RETURN l_cCurName
	ENDPROC

	PROCEDURE sqlwhere
		LPARAMETERS lp_cWhere, lp_cExpr
		LOCAL l_cRet
		DO CASE
		     CASE EMPTY(lp_cExpr)
		          l_cRet = lp_cWhere
		     CASE EMPTY(lp_cWhere) AND !EMPTY(lp_cExpr)
		          l_cRet = " WHERE (" + lp_cExpr + ")"
		     CASE !EMPTY(lp_cWhere) AND !EMPTY(lp_cExpr)
		          l_cRet = lp_cWhere + " AND (" + lp_cExpr + ")"
		ENDCASE
		RETURN l_cRet
	ENDPROC

	PROCEDURE tbclose
		LPARAMETERS lp_cCursorName, lp_ndatasessionid
		this.ChangeDatasession(lp_ndatasessionid)
		=closefile(lp_cCursorName)
		IF NOT EMPTY(lp_ndatasessionid)
			this.RestoreDatasession()
		ENDIF
		RETURN .T.
	ENDPROC

	PROCEDURE tbopen
		LPARAMETERS lp_ctable, lp_calias, lp_ndatasessionid
		LOCAL l_lSuccess
		this.ChangeDatasession(lp_ndatasessionid)
		l_lSuccess = openfiledirect(.F.,lp_ctable,lp_calias)
		IF NOT EMPTY(lp_ndatasessionid)
			this.RestoreDatasession()
		ENDIF
		RETURN l_lSuccess
	ENDPROC

	PROCEDURE winpc
		RETURN winpc()
	ENDPROC

	PROCEDURE yesno
		LPARAMETERS tcText, tcHeader, tcString
		LOCAL lcParams
		
		lcParams = ",tcText,tcHeader,tcString,"
		lcParams = SUBSTR(lcParams,2,AT(",",lcParams,PCOUNT()+1)-2)
		
		RETURN YesNo(&lcParams)
	ENDPROC

	PROCEDURE yesnocancel
		LPARAMETERS tcText, tcHeader
		LOCAL lcParams
		
		lcParams = ",tcText,tcHeader,"
		lcParams = SUBSTR(lcParams,2,AT(",",lcParams,PCOUNT()+1)-2)
		
		RETURN YesNoCancel(&lcParams)
	ENDPROC

ENDDEFINE

DEFINE CLASS brilliantshandler AS shandler OF "..\common\libs\_search.vcx" 
 	*< CLASSDATA: Baseclass="custom" Timestamp="" Scale="Pixels" Uniqueid="" />

	Name = "brilliantshandler"
	
	PROCEDURE createcriterium
		LPARAMETERS tcCaption, tcControlSource, tcFieldSource, tlExtended
		* Fill and initialize properties for controls (ControlSource, FieldType, FieldSource, FirstValue, SecondValue).
		* Add criterium object to the collection of main criteriums.
		**** if tlExtended = .T. then FieldType = tcControlSource ***
		LOCAL loCriterium, luValue, lcMacro
		
		loCriterium = CREATEOBJECT("sCriterium")
		loCriterium.Caption = tcCaption
		loCriterium.lExtended = tlExtended
		
		IF NOT EMPTY(tcControlSource) OR NOT EMPTY(tcFieldSource)
			IF loCriterium.lExtended
				loCriterium.FieldType = tcControlSource
			ELSE
				loCriterium.FieldType = TYPE(tcControlSource)
				IF loCriterium.FieldType = "C"
					lcMacro = Str2Msg("%s1 == [%s2] OR %s3 == [%s4]", "%s", tcControlSource, GetText("COMMON", "TXT_YES"), tcControlSource, GetText("COMMON", "TXT_NO"))
					IF &lcMacro
						loCriterium.FieldType = "B"
					ENDIF
				ENDIF
			ENDIF
		
			DO CASE
				CASE INLIST(loCriterium.FieldType, "C", "M")
					luValue = ""
					IF NOT loCriterium.lExtended
						tcControlSource = "UPPER(" + tcControlSource + ")"
					ENDIF
				CASE INLIST(loCriterium.FieldType, "N", "I")
					luValue = 0
				CASE loCriterium.FieldType = "Y"
					luValue = NTOM(0)
				CASE loCriterium.FieldType = "L"
					luValue = .F.
				CASE INLIST(loCriterium.FieldType, "D", "T")
					luValue = {}
				OTHERWISE
					luValue = ""
			ENDCASE
		
			IF NOT loCriterium.lExtended
				loCriterium.ControlSource = tcControlSource
			ENDIF
			loCriterium.FieldSource = tcFieldSource
			loCriterium.FirstValue = luValue
			loCriterium.SecondValue = luValue
		ENDIF
		
		this.oCriteriums.Add(loCriterium, loCriterium.cKey)
	ENDPROC

	PROCEDURE createfilter
		LPARAMETERS toCriterium
		* Create a filter expression for grid source.
		LOCAL loCriterium, lcSecondValue
		
		DO CASE
			CASE VARTYPE(toCriterium) # "O"
				this.cOrder = ""
				this.cFilter = ""
				FOR EACH loCriterium IN this.oCriteriums
					IF NOT EMPTY(loCriterium.FieldSource)
						this.CreateFilter(loCriterium)
					ENDIF
				NEXT
				IF EMPTY(this.cFilter)
					this.cFilter = "1=1"
				ENDIF
			CASE EMPTY(toCriterium.FirstValue)
			CASE INLIST(toCriterium.FieldType, "C", "M")
				this.cOrder = this.cOrder + IIF(EMPTY(this.cOrder), "", ",") + toCriterium.FieldSource
				this.cFilter = this.cFilter + IIF(EMPTY(this.cFilter), "", " AND ") + "UPPER(" + toCriterium.FieldSource + ")"
				IF EMPTY(toCriterium.SecondValue)
					this.cFilter = this.cFilter + Str2Msg(" LIKE %s", "%s", SqlCnv(toCriterium.FirstValue+"%",.T.))
				ELSE
					* Replace last character with character that has asci code greater by 1.
					*lcSecondValue = STUFF(toCriterium.SecondValue, LEN(toCriterium.SecondValue), 1, CHR(ASC(RIGHT(toCriterium.SecondValue,1))+1))
					lcSecondValue = toCriterium.SecondValue
					this.cFilter = this.cFilter + Str2Msg(" BETWEEN %s1 AND %s2", "%s", SqlCnv(toCriterium.FirstValue,.T.), SqlCnv(lcSecondValue,.T.))
				ENDIF
			CASE toCriterium.FieldType = "L"
				this.cOrder = this.cOrder + IIF(EMPTY(this.cOrder), "", ",") + toCriterium.FieldSource
				this.cFilter = this.cFilter + IIF(EMPTY(this.cFilter), "", " AND ") + toCriterium.ControlSource
			CASE toCriterium.FieldType = "B"
				this.cOrder = this.cOrder + IIF(EMPTY(this.cOrder), "", ",") + toCriterium.FieldSource
				this.cFilter = this.cFilter + IIF(EMPTY(this.cFilter), "", " AND ") + Str2Msg("%s1 = %s2", "%s", toCriterium.FieldSource, SqlCnv(toCriterium.FirstValue,.T.))
			OTHERWISE
				this.cOrder = this.cOrder + IIF(EMPTY(this.cOrder), "", ",") + toCriterium.FieldSource
				this.cFilter = this.cFilter + IIF(EMPTY(this.cFilter), "", " AND ") + toCriterium.FieldSource
				IF EMPTY(toCriterium.SecondValue)
					this.cFilter = this.cFilter + Str2Msg(" = %s", "%s", SqlCnv(toCriterium.FirstValue,.T.))
				ELSE
					this.cFilter = this.cFilter + Str2Msg(" BETWEEN %s1 AND %s2", "%s", SqlCnv(toCriterium.FirstValue,.T.), SqlCnv(toCriterium.SecondValue,.T.))
				ENDIF
		ENDCASE
		
		RETURN this.cFilter
	ENDPROC

	PROCEDURE setasdefault
		NODEFAULT
	ENDPROC

ENDDEFINE

DEFINE CLASS brilliantworktime AS worktimecontrol OF "..\common\libs\worktimehandler.vcx" 
 	*< CLASSDATA: Baseclass="custom" Timestamp="" Scale="Pixels" Uniqueid="" />

	asgemplalias = asgempl
	azepickalias = azepick
	employeealias = employee
	employehalias = employeh
	Name = "brilliantworktime"
	paramalias = param2
	timetypealias = timetype
	workbrkalias = workbrk
	workbrkdalias = workbrkd
	workintalias = workint
	
	PROCEDURE Init
		this.oFunctions = CREATEOBJECT("brilliantfunc")
		DODEFAULT()
	ENDPROC

	PROCEDURE userisemployee
		*
		LPARAMETERS lp_cUserID, lp_cEmployeeAlias
		
		IF EMPTY(lp_cUserID)
			lp_cUserID = g_UserID
		ENDIF
		IF EMPTY(lp_cEmployeeAlias)
			lp_cEmployeeAlias = this.EmployeeAlias
		ENDIF
		
		RETURN dlocate(lp_cEmployeeAlias, "UPPER(RTRIM(em_userid)) == [" + UPPER(RTRIM(lp_cUserID)) + "]")
	ENDPROC

	PROCEDURE workhourshandle
		IF NOT _SCREEN.AZE
		     RETURN .T.
		ENDIF
		
		IF NOT this.UserIsEmployee()
		     Alert(GetLangText("EMPLOYEE","TXT_NOT_WAITER"))
		     RETURN .F.
		ENDIF
		
		DODEFAULT()
	ENDPROC

	PROCEDURE workpausehandle
		IF NOT _SCREEN.AZE
		     RETURN .T.
		ENDIF
		
		IF NOT this.UserIsEmployee()
		     Alert(GetLangText("EMPLOYEE","TXT_NOT_WAITER"))
		     RETURN .F.
		ENDIF
		
		DODEFAULT()
	ENDPROC

ENDDEFINE

DEFINE CLASS editemployee AS custom 
 	*< CLASSDATA: Baseclass="custom" Timestamp="" Scale="Pixels" Uniqueid="" />

	*<DefinedPropArrayMethod>
		*m: validatefields
		*p: cfirstname
		*p: njobnum
		*p: npersonelnum
		*p: ofunctions
	*</DefinedPropArrayMethod>

	Name = "editemployee"
	
	PROCEDURE Init
		this.oFunctions = CREATEOBJECT("brilliantfunc")
		DODEFAULT()
	ENDPROC

	PROCEDURE validatefields
		LPARAMETERS lp_oEmployee
		LOCAL l_nErrorCode
		
		* l_nErrorCode values
		* -------------------
		* 0 everything OK
		* 1 invalid txtPersonalNumber
		* 2 invalid txtFirstName
		* 3 invalid cboActivity
		
		DO CASE
			CASE EMPTY(lp_oEmployee.em_pernr)
				alert(this.oFunctions.GetLanguageText("TXT_REQUIRED"))
				l_nErrorCode = 1
			CASE EMPTY(lp_oEmployee.em_lname)
				alert(this.oFunctions.GetLanguageText("TXT_REQUIRED"))
				l_nErrorCode = 2
			CASE EMPTY(lp_oEmployee.em_jbnr)
				alert(this.oFunctions.GetLanguageText("TXT_REQUIRED"))
				l_nErrorCode = 3
			OTHERWISE
				l_nErrorCode = 0
		ENDCASE
		RETURN l_nErrorCode
	ENDPROC

ENDDEFINE

DEFINE CLASS timeplanbase AS tform OF "main.vcx" 
 	*< CLASSDATA: Baseclass="form" Timestamp="" Scale="Pixels" Uniqueid="" />

	*-- OBJECTDATA items order determines ZOrder / El orden de los items OBJECTDATA determina el ZOrder 
	*< OBJECTDATA: ObjPath="grdTimePlan" UniqueID="" Timestamp="" />

	*<DefinedPropArrayMethod>
		*m: opentable
		*m: requerygrid
		*p: ccaption
		*p: curtemptimeplan
		*p: oworktimefunc
		*p: timeplancursor
	*</DefinedPropArrayMethod>

	AlwaysOnTop = .F.
	Caption = "TimePlanBase"
	ccaption = ""
	ContinuousScroll = .F.
	ControlBox = .T.
	ctbrclass = cTbrAze
	curtemptimeplan = ""
	DataSession = 2
	DoCreate = .T.
	doini = .T.
	doiniopencommontables = .T.
	Icon = ..\bitmap\icons\crdfle07.ico
	KeyPreview = .T.
	MaxButton = .F.
	MinButton = .F.
	Name = "timeplanbase"
	oworktimefunc = .NULL.
	resizeheaderfont = .F.
	savegridwidths = .T.
	ScrollBars = 2
	timeplancursor = 

	ADD OBJECT 'grdTimePlan' AS grdbase WITH ;
		ColumnCount = 0, ;
		DeleteMark = .F., ;
		Height = 405, ;
		lresizecolumns = .F., ;
		Name = "grdTimePlan", ;
		p_basecolumncontrol = tbgrid, ;
		resizefontsize = .F., ;
		ScrollBars = 2, ;
		setcolumns = .T., ;
		Width = 380
		*< END OBJECT: ClassLib="main.vcx" BaseClass="grid" />
	
	PROCEDURE Init
		LPARAMETERS lp_cCaption, lp_aProperties
		LOCAL l_nColumnCount, l_nColumnNumber, l_nFormWidth, l_nFormHieght, l_nOldFormWidth, l_nOldFormHieght, l_lSetWordWrap, l_lSetAlignment
		EXTERNAL ARRAY lp_aProperties
		
		this.cCaption = lp_cCaption
		l_nFormWidth = 0
		l_lSetWordWrap = (ALEN(lp_aProperties,2) > 3)
		l_lSetAlignment = (ALEN(lp_aProperties,2) > 4)
		
		l_nColumnCount = ALEN(lp_aProperties,1)
		WITH this.grdTimePlan
			.cGridLabelName = this.FormName
			.ColumnCount = 0
			.ColumnCount = l_nColumnCount
			SELECT (this.TimePlanCursor)
			.RecordSource = this.TimePlanCursor
			FOR l_nColumnNumber = 1 TO l_nColumnCount
				.Columns(l_nColumnNumber).ControlSource = lp_aProperties(l_nColumnNumber,1)
				.Columns(l_nColumnNumber).Header1.Caption = lp_aProperties(l_nColumnNumber,2)
				.Columns(l_nColumnNumber).Header1.Alignment = 2
				IF l_lSetWordWrap AND TYPE("lp_aProperties[l_nColumnNumber,4]") = "L"
					.Columns(l_nColumnNumber).Header1.WordWrap = lp_aProperties(l_nColumnNumber,4)
				ENDIF
				IF l_lSetAlignment AND TYPE("lp_aProperties[l_nColumnNumber,5]") = "N"
					.Columns(l_nColumnNumber).Alignment = lp_aProperties(l_nColumnNumber,5)
				ENDIF
				.Columns(l_nColumnNumber).Width = lp_aProperties(l_nColumnNumber,3)
				l_nFormWidth = l_nFormWidth + lp_aProperties(l_nColumnNumber,3) + .GridLineWidth
			NEXT
			l_nFormWidth = IIF(EMPTY(l_nFormWidth),.Width,l_nFormWidth+22)
			l_nFormHieght = MIN((RECCOUNT(this.TimePlanCursor)+3)*.RowHeight + .HeaderHeight,700)
			.Height = l_nFormHieght
			.Width = l_nFormWidth
			.Init()
		ENDWITH
		l_nOldFormHieght = this.Height
		l_nOldFormWidth = this.Width
		this.Height = l_nFormHieght
		this.Width = l_nFormWidth
		this.Top = this.Top - INT((this.Height - l_nOldFormHieght)/2)
		this.Left = this.Left - INT((this.Width - l_nOldFormWidth)/2)
		
		DODEFAULT()
		GO TOP IN (this.TimePlanCursor)
	ENDPROC

	PROCEDURE Load
		this.oWorkTimeFunc = CREATEOBJECT("brilliantworktime")
		this.TimePLanCursor = SYS(2015)
		this.OpenTable()
		DODEFAULT()
	ENDPROC

	PROCEDURE onclose
		this.Release()
	ENDPROC

	PROCEDURE opentable
		* opens required tables in forms data session
		
		OpenFile(,"employee")
	ENDPROC

	PROCEDURE QueryUnload
		thisform.OnClose()
		NODEFAULT
	ENDPROC

	PROCEDURE requerygrid
		LOCAL l_nRecNo
		l_nRecNo = RECNO(this.TimePlanCursor)
		
		SELECT (this.TimePlanCursor)
		ZAP
		APPEND FROM DBF(this.curTempTimePlan)
		USE IN (this.curTempTimePlan)
		SELECT (this.TimePlanCursor)
		GO l_nRecNo IN (this.TimePlanCursor)
		this.grdTimePlan.Refresh()
		RETURN .T.
	ENDPROC

ENDDEFINE

DEFINE CLASS timeplanbrilliant AS edittimeplan OF "worktimehandler.vcx" 
 	*< CLASSDATA: Baseclass="custom" Timestamp="" Scale="Pixels" Uniqueid="" />

	asgemplalias = asgempl
	Name = "timeplanbrilliant"
	timetypealias = timetype
	
	PROCEDURE Init
		this.oFunctions = CREATEOBJECT("brilliantfunc")
		DODEFAULT()
	ENDPROC

ENDDEFINE
