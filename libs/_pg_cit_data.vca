*--------------------------------------------------------------------------------------------------------------------------------------------------------
* (ES) AUTOGENERADO - ¡¡ATENCIÓN!! - ¡¡NO PENSADO PARA EJECUTAR!! USAR SOLAMENTE PARA INTEGRAR CAMBIOS Y ALMACENAR CON HERRAMIENTAS SCM!!
* (EN) AUTOGENERATED - ATTENTION!! - NOT INTENDED FOR EXECUTION!! USE ONLY FOR MERGING CHANGES AND STORING WITH SCM TOOLS!!
*--------------------------------------------------------------------------------------------------------------------------------------------------------
*< FOXBIN2PRG: Version="1.19" SourceFile="_pg_cit_data.vcx" /> (Solo para binarios VFP 9 / Only for VFP 9 binaries)
*
*
DEFINE CLASS _pg_tbrowse AS grdbase OF "main.vcx" 
 	*< CLASSDATA: Baseclass="grid" Timestamp="" Scale="Pixels" Uniqueid="" />

	*<DefinedPropArrayMethod>
		*m: acolumns_assign
		*m: adduserdefinedcolumn
		*m: browsego
		*m: browsekeypress
		*m: browsepropget
		*m: browsescroll
		*m: browsesource
		*m: enablebrowsescroll
		*m: getposition
		*m: requerycursor
		*m: uselectedpk_assign
		*p: cdefaultcolumninputmask		&& Default input mask for column
		*p: cforclause
		*p: clocateforclause
		*p: cmaintainedalias
		*p: cnotlocatemessage
		*p: corder
		*p: cprimarykey
		*p: cseekexpression
		*p: csource
		*p: ctbrwdataname
		*p: cwhileclause
		*p: eseekvalue
		*p: lbrowsefromselected
		*p: lgetmouseposition
		*p: lneertoggle
		*p: lnotfoundmessage
		*p: lnotlocatemessage
		*p: lupdatecursordata
		*p: nbottomrecno
		*p: ngridcol
		*p: ngridrow
		*p: nlinetoscroll		&& specified number of lines to scroll with one scroll of the mouse whell (min. value: 1)
		*p: nselectedrecno
		*p: ntoprecno
		*p: obrwdata
		*p: toprow
		*p: uselectedorder
		*p: uselectedpk
		*a: acolumns[1,12]
	*</DefinedPropArrayMethod>

	AllowCellSelection = .F.
	cdefaultcolumninputmask = 		&& Default input mask for column
	cforclause = 
	clocateforclause = 
	cmaintainedalias = 
	cnotlocatemessage = 
	corder = 
	cprimarykey = 
	cseekexpression = 
	csource = 
	ctbrwdataname = 
	cwhileclause = 
	lnotfoundmessage = .T.
	lnotlocatemessage = .T.
	lresizecolumns = .F.
	Name = "_pg_tbrowse"
	nbottomrecno = 0
	ngridcol = 0
	ngridrow = 0
	nlinetoscroll = 1		&& specified number of lines to scroll with one scroll of the mouse whell (min. value: 1)
	ntoprecno = 0
	obrwdata = .NULL.
	p_basecolumncontrol = tbgrid
	resizefontsize = .F.
	setcolumns = .T.
	toprow = 0
	uselectedorder = 
	
	PROCEDURE acolumns_assign
		LPARAMETERS tvNewVal, tnIndex1, tnIndex2
		
		IF ISNULL(tnIndex1)								&& user didn't pass in a subscript
			this.aColumns = tvNewVal
		ELSE
			this.aColumns[tnIndex1, tnIndex2] = tvNewVal
		ENDIF
	ENDPROC

	PROCEDURE adduserdefinedcolumn
		LOCAL lnArrayRowsNumber, lnArrayColumnsNumber
		
		lnArrayRowsNumber = ALEN(this.aColumns,1)
		lnArrayColumnsNumber = ALEN(this.aColumns,2)
		
		FOR EACH loColumn IN this.Columns
			IF loColumn.lUDCol
				lnArrayRowsNumber = lnArrayRowsNumber + 1
				DIMENSION this.aColumns(lnArrayRowsNumber,lnArrayColumnsNumber)
				this.aColumns(lnArrayRowsNumber,1) = loColumn.ControlSource
				this.aColumns(lnArrayRowsNumber,2) = loColumn.Width
				this.aColumns(lnArrayRowsNumber,3) = loColumn.Header1.Caption
		
				* Dont set dynamic fore and back color. This coused error:
				* Error: 13 Message: Alias '_2I10VVU6U' is not found. 
				
				* this.aColumns(lnArrayRowsNumber,5) = loColumn.DynamicForeColor
				* this.aColumns(lnArrayRowsNumber,6) = loColumn.DynamicBackColor
		
				this.aColumns(lnArrayRowsNumber,7) = loColumn.Name
				this.aColumns(lnArrayRowsNumber,8) = loColumn.ColumnOrder
			ENDIF
		NEXT
	ENDPROC

	PROCEDURE AfterRowColChange
		LPARAMETERS nColIndex
		
		this.uSelectedPK = EVALUATE(this.RecordSource + "." + this.cPrimaryKey)
		IF this.lGetMousePosition
			this.GetPosition(nXCoord, nYCoord)
		ENDIF
	ENDPROC

	PROCEDURE browsego
		LPARAMETERS tlRequery
		LOCAL llFound, lcRecordSource, i
		
		IF tlRequery
			LOCAL ARRAY laColProp(this.ColumnCount,1)
			FOR i = 1 TO this.ColumnCount
				laColProp[i,1] = this.Columns(i).Alignment
			ENDFOR
			lcRecordSource = this.RecordSource
			this.RecordSource = ""
			ZAP IN (lcRecordSource)
			this.RecordSource = lcRecordSource
			SELECT (lcRecordSource)
			FOR i = 1 TO this.ColumnCount
				IF NOT EMPTY(this.aColumns[i,1])
					this.Columns(i).ControlSource = this.aColumns[i,1]
				ENDIF
				this.Columns(i).Alignment = laColProp[i,1]
			NEXT
		ENDIF
		
		IF this.oBrwData.BrowseLocate()
			llFound = .T.
			this.BrowseScroll(-3)
			this.BrowseScroll(-4)
			DLocate(this.RecordSource, this.cPrimaryKey + " = " + SqlCnv(this.uSelectedPK, .T.))
		ENDIF
		
		RETURN llFound
	ENDPROC

	PROCEDURE browsekeypress
		LPARAMETERS nKeyCode, nShiftAltCtrl
		* This method should be called from: this.Parent.KeyPress event.
		* Property this.Parent.KeyPreview should be set to True.
		LOCAL llRefresh
		
		DO CASE
			CASE nKeyCode =  5 AND nShiftAltCtrl = 0 && UP ARROW
				this.BrowseScroll(0)
				llRefresh = .T.
			CASE nKeyCode = 24 AND nShiftAltCtrl = 0 && DOWN ARROW
				this.BrowseScroll(1)
				llRefresh = .T.
			CASE nKeyCode = 18 AND nShiftAltCtrl = 0 && PAGE UP
				IF this.EnableBrowseScroll(2)
					this.BrowseScroll(2)
					llRefresh = .T.
				ENDIF
			CASE nKeyCode =  3 AND nShiftAltCtrl = 0 && PAGE DOWN
				IF this.EnableBrowseScroll(3)
					this.BrowseScroll(3)
					llRefresh = .T.
				ENDIF
		ENDCASE
		
		IF llRefresh
			this.Refresh()
		ENDIF
	ENDPROC

	PROCEDURE browsepropget
		LPARAMETERS tcColumnName, tcPropName
		LOCAL i, lePropVal
		
		FOR i = 1 TO ALEN(this.aColumns, 1)
			IF this.aColumns(i, 7) == tcColumnName
				DO CASE
					CASE tcPropName = "ControlSource"
						IF NOT EMPTY(this.aColumns(i, 1))
							lePropVal = this.aColumns(i, 1)
						ELSE
							lePropVal = ""
						ENDIF
					CASE tcPropName = "DynamicBackColor"
						IF NOT EMPTY(this.aColumns(i, 6))
							lePropVal = this.aColumns(i, 6)
						ELSE
							lePropVal = ""
						ENDIF
					CASE tcPropName = "DynamicForeColor"
						IF NOT EMPTY(this.aColumns(i, 5))
							lePropVal = this.aColumns(i, 5)
						ELSE
							lePropVal = ""
						ENDIF
				ENDCASE
			ENDIF
		ENDFOR
		
		RETURN lePropVal
	ENDPROC

	PROCEDURE browsescroll
		LPARAMETERS tnDirection, tnCount
		LOCAL lnRows, lnGridHeight, lnRecNo, lnRowsRefreshed, llUpdateCursorData
		
		lnRecNo = RECNO(this.RecordSource)
		lnGridHeight = CEILING((this.Height-this.HeaderHeight-2) / this.RowHeight) - 3
		
		DO CASE
			CASE tnDirection = 3								&& PAGE DOWN
				lnRows = lnGridHeight
			CASE tnDirection = 2								&& PAGE UP
				lnRows = -lnGridHeight
			CASE tnDirection = 1								&& DOWN ARROW
				lnRows = 3
			CASE tnDirection = 0								&& UP ARROW
				lnRows = -2
			CASE tnDirection = -1								&& GO BOTTOM
				lnRows = lnGridHeight
			CASE tnDirection = -2								&& GO TOP
				lnRows = -lnGridHeight
			CASE tnDirection = -3
				lnRows = 2 * lnGridHeight
			CASE tnDirection = -4
				lnRows = - 2 * lnGridHeight
			CASE tnDirection = -5
				lnRows = tnCount
			OTHERWISE
				RETURN 0
		ENDCASE
		
		lnRowsRefreshed = this.oBrwData.BrowseNext(lnRows, tnDirection)
		
		RETURN lnRowsRefreshed
	ENDPROC

	PROCEDURE browsesource
		LOCAL i
		
		this.oBrwData.BrowseSource()
		
		IF this.ColumnCount =< ALEN(this.aColumns, 1)
			this.ColumnCount = ALEN(this.aColumns, 1)
		ENDIF
		
		SELECT(this.RecordSource)
		FOR i = 1 TO MIN(this.ColumnCount, ALEN(this.aColumns, 1))
			this.aColumns(i, 7) = this.Columns(i).Name
			IF NOT EMPTY(this.aColumns(i, 1))
				this.Columns(i).ControlSource = this.aColumns(i, 1)
			ENDIF
			IF NOT EMPTY(this.aColumns(i, 2))
				this.Columns(i).Width = this.aColumns(i, 2)
			ENDIF
			IF NOT EMPTY(this.aColumns(i, 3))
				this.Columns(i).Header1.Caption = this.aColumns(i, 3)
			ENDIF
			IF NOT EMPTY(this.aColumns(i, 5))
				this.Columns(i).DynamicForeColor = "["+this.aColumns(i, 5)+"]"
			ENDIF
			IF NOT EMPTY(this.aColumns(i, 6))
				this.Columns(i).AddProperty("cCustomDynamicBackColor","!ISNULL("+this.aColumns(i, 6)+"),"+this.aColumns(i, 6))
			ENDIF
			IF NOT EMPTY(this.aColumns(i, 8))
				this.Columns(i).cSortOrder = this.aColumns(i, 8)
			ENDIF
			DO CASE
				CASE TYPE("this.aColumns(i, 10)") = "C" AND NOT EMPTY(this.aColumns(i, 10))
					this.Columns(i).InputMask = this.aColumns(i, 10)
				CASE NOT EMPTY(this.cDefaultColumnInputMask)
					this.Columns(i).InputMask = this.cDefaultColumnInputMask
				OTHERWISE
					this.Columns(i).InputMask = ""
			ENDCASE
			IF TYPE("this.aColumns(i, 11)")="L" AND this.aColumns(i, 11)
				this.Columns(i).FontBold = .T.
			ENDIF
			IF TYPE("this.aColumns(i, 12)")="C" AND NOT EMPTY(this.aColumns(i, 12))
				this.Columns(i).AddProperty("cDblClickScript", this.aColumns(i, 12))
			ENDIF
		ENDFOR
		
		RETURN .T.
	ENDPROC

	PROCEDURE DblClick
		LOCAL loColumn, lcScript
		
		* Find column object
		FOR EACH loColumn IN this.Columns
			IF loColumn.ColumnOrder = this.nGridCol
				IF TYPE("loColumn.cDblClickScript") = "C" AND NOT EMPTY(loColumn.cDblClickScript)
					lcScript = loColumn.cDblClickScript
				ENDIF
				EXIT
			ENDIF
		NEXT
		
		IF EMPTY(lcScript)
			DODEFAULT()
		ELSE
			IF &lcScript
				NODEFAULT
			ELSE
				DODEFAULT()
			ENDIF
		ENDIF
	ENDPROC

	PROCEDURE Destroy
		LOCAL lcSource
		
		lcSource = this.RecordSource
		this.RecordSource = ""
		DClose(lcSource)
		this.oBrwData = .NULL.
		
		RETURN .T.
	ENDPROC

	PROCEDURE enablebrowsescroll
		LPARAMETERS tnDirection, tnLineToScroll
		LOCAL lnArea, lnStep, lnSkip, llEnable, lnCount, lnRecNo
		
		lnArea = SELECT()
		
		DO CASE
			CASE tnDirection = 0	&& UP ARROW
				lnStep = 4
				lnSkip = -1
			CASE tnDirection = 1	&& DOWN ARROW
				lnStep = 4
				lnSkip = 1
			CASE tnDirection = 2	&& PAGE UP
				lnStep = 2 * CEILING((this.Height-this.HeaderHeight-2) / this.RowHeight) - 3
				lnSkip = -1
			CASE tnDirection = 3	&& PAGE DOWN
				lnStep = 2 * CEILING((this.Height-this.HeaderHeight-2) / this.RowHeight) - 3
				lnSkip = 1
		ENDCASE
		
		SELECT (this.RecordSource)
		lnRecNo = RECNO()
		lnCount = 0
		DO WHILE lnCount < lnStep
			IF IIF(lnSkip > 0, EOF(), BOF())
				llEnable = .T.
				EXIT
			ENDIF
			lnCount = lnCount + 1
			SKIP lnSkip
		ENDDO
		GO lnRecNo
		
		SELECT(lnArea)
		
		RETURN llEnable
	ENDPROC

	PROCEDURE getposition
		LPARAMETERS tnXCoord, tnYCoord
		LOCAL lnWhere_Out, lnRelRow_Out, lnRelColOut, lnView_Out
		LOCAL lnArea, lnRecno
		
		* GridHitTest method probably take afects on selected alias.
		lnArea = SELECT()
		lnRecno = RECNO()
		lnWhere_Out = 0
		lnRelRow_Out = 0
		lnRelColOut = 0
		lnView_Out = 0
		this.GridHitTest(tnXCoord, tnYCoord, @lnWhere_Out, @lnRelRow_Out, @lnRelColOut, @lnView_Out)
		IF lnWhere_Out = 3
			this.TopRow = this.ActiveRow - this.RelativeRow + 1
			this.nGridRow = this.TopRow + lnRelRow_Out - 1
			this.nGridCol = this.LeftColumn + lnRelColOut - 1
		ENDIF
		
		SELECT (lnArea)
		
		GO lnRecno
	ENDPROC

	PROCEDURE Init
		LPARAMETERS tlGoLater
		LOCAL lcTbrwData
		
		this.lcolumnsort = .T.
		
		DODEFAULT()
		
		IF this.lAddUserDefinedColumns
			this.AddUserDefinedColumn()
		ENDIF
		
		IF NOT EMPTY(this.cSource)
			lcTbrwData = "oBrwData"+SYS(2015)
			this.Parent.AddObject(lcTbrwData,"_pg_tbrwdata")
			this.oBrwData = EVALUATE("this.Parent."+lcTbrwData)
			this.oBrwData.oGridReference = this
			this.BrowseSource()
			IF NOT tlGoLater
				this.BrowseGo()
			ENDIF
		ENDIF
		
		RETURN .T.
	ENDPROC

	PROCEDURE MouseUp
		LPARAMETERS nButton, nShift, nXCoord, nYCoord
		
		IF nButton = 1
			this.BrowseScroll(-5,-2)
			this.BrowseScroll(-5,2)
		ENDIF
		
		DODEFAULT(nButton, nShift, nXCoord, nYCoord)
		
		this.Refresh()
	ENDPROC

	PROCEDURE requerycursor
		LPARAMETERS tlZapCursor, tlBrowseFromSelected
		LOCAL lnArea, llFound
		
		lnArea = SELECT()
		
		WaitWindowShow(GetLangText("COMMON", "T_PLEASEWAIT"))
		
		this.lBrowseFromSelected = tlBrowseFromSelected
		
		IF this.BrowseGo(tlZapCursor)
			llFound = .T.
			this.RefreshSortCursor()
			this.Refresh()
		ENDIF
		
		WaitWindowClear()
		
		SELECT (lnArea)
		
		RETURN llFound
	ENDPROC

	PROCEDURE Resize
		LOCAL lnRowsBefore, lnRowsAfter
		
		lnRowsBefore = CEILING((this.Height - this.HeaderHeight - 2) / this.RowHeight) - 2
		
		DODEFAULT()
		
		lnRowsAfter = CEILING((this.Height - this.HeaderHeight - 2) / this.RowHeight) - 2
		IF lnRowsAfter > lnRowsBefore
			this.BrowseScroll(-5, lnRowsAfter - lnRowsBefore)
		ENDIF
		
		this.Refresh()
		
		RETURN .T.
	ENDPROC

	PROCEDURE setordering
		LPARAMETERS tcOrder
		LOCAL lnSelect, lcOrder, llZapCursor, llBrowseFromSelected
		
		lnSelect = SELECT()
		
		lcOrder = IIF(EMPTY(tcOrder), "c_pk", "c_order")
		
		SELECT (this.RecordSource)
		DO CASE
			CASE NOT UPPER(this.cOrder) == UPPER(tcOrder)
				this.cOrder = tcOrder
				SET ORDER TO &lcOrder ASCENDING
			CASE DESCENDING()
				SET ORDER TO &lcOrder ASCENDING
			OTHERWISE
				SET ORDER TO &lcOrder DESCENDING
		ENDCASE
		
		llZapCursor = .T.
		llBrowseFromSelected = .T.
		this.RequeryCursor(llZapCursor, llBrowseFromSelected)
		this.RefreshSortCursor()
		
		SELECT (lnSelect)
		
		RETURN .T.
	ENDPROC

	PROCEDURE uselectedpk_assign
		LPARAMETERS tvNewVal
		
		this.uSelectedPk = tvNewVal
		
		this.uSelectedOrder = EVALUATE(this.RecordSource + ".c_order")
	ENDPROC

ENDDEFINE

DEFINE CLASS _pg_tbrwdata AS custom 
 	*< CLASSDATA: Baseclass="custom" Timestamp="" Scale="Pixels" Uniqueid="" />

	*<DefinedPropArrayMethod>
		*m: browselocate
		*m: browsenext
		*m: browsesource
		*m: browseupdateexistingrows
		*p: lmustrefreshsortcursor
		*p: ogridreference
	*</DefinedPropArrayMethod>

	Name = "_pg_tbrwdata"
	ogridreference = .NULL.
	
	PROCEDURE browselocate
		LOCAL lnArea, loGrid, lcSource, lcWhere, lcOrder
		
		lnArea = SELECT()
		
		loGrid = this.oGridReference
		
		DO CASE
			CASE NOT loGrid.lBrowseFromSelected
				IF EMPTY(loGrid.cSeekExpression) OR EMPTY(loGrid.eSeekValue)
					lcWhere = ""
					lcOrder = IIF(EMPTY(loGrid.cOrder), loGrid.cPrimaryKey, loGrid.cOrder)
				ELSE
					lcWhere = SqlWhere("", loGrid.cSeekExpression + " >= " + SqlCnv(loGrid.eSeekValue,.T.))
					lcOrder = loGrid.cSeekExpression
				ENDIF
				lcWhere = SqlWhere(lcWhere, loGrid.cForClause)
				lcSource = SqlCursor("SELECT TOP 1 " + loGrid.cPrimaryKey + IIF(EMPTY(loGrid.cOrder), "", ", " + loGrid.cOrder) + " FROM " + loGrid.cSource + lcWhere + " ORDER BY " + lcOrder,,,,,,,.T.)
				IF RECCOUNT() = 0
					loGrid.uSelectedPK = Blank(EVALUATE(loGrid.cPrimaryKey))
					IF loGrid.lNotFoundMessage
						Alert(GetLangText("AR", "TA_NODATAFOUND"))
					ENDIF
				ELSE
					loGrid.uSelectedPK = EVALUATE(loGrid.cPrimaryKey)
					IF NOT EMPTY(loGrid.cOrder)
						loGrid.uSelectedOrder = EVALUATE(SqlParse(_screen.oGlobal.GetOrderExpression(loGrid.cOrder)))
					ENDIF
				ENDIF
				DClose(lcSource)
			CASE EMPTY(loGrid.uSelectedPK)
				SELECT (loGrid.RecordSource)
				loGrid.uSelectedPK = EVALUATE(loGrid.cPrimaryKey)
			OTHERWISE
		ENDCASE
		
		SELECT(lnArea)
		
		RETURN NOT EMPTY(loGrid.uSelectedPK)
	ENDPROC

	PROCEDURE browsenext
		LPARAMETERS tnRows, tnDirection
		LOCAL lnArea, lnRecNo, loGrid, lcSource, lcWhere, lnCheckPK, lcOrder, loRecord, lcOrderExpression
		
		lnArea = SELECT()
		
		loGrid = this.oGridReference
		
		IF NOT EMPTY(loGrid.cOrder)
			lcOrderExpression = _screen.oGlobal.GetOrderExpression(loGrid.cOrder)
		ENDIF
		
		SELECT (loGrid.RecordSource)
		lnRecNo = RECNO()
		
		IF tnRows < 0
			IF EMPTY(loGrid.cOrder)
				lcWhere = IIF(tnDirection = -2, "", SqlWhere("", loGrid.cPrimaryKey + " <= " + SqlCnv(loGrid.uSelectedPK,.T.)))
				lcOrder = " ORDER BY " + STRTRAN(loGrid.cPrimaryKey, ",", " DESC,") + " DESC"
			ELSE
				lcWhere = IIF(tnDirection = -2, "", SqlWhere("", lcOrderExpression + " <= " + SqlCnv(loGrid.uSelectedOrder,.T.)))
				lcOrder = " ORDER BY " + STRTRAN(loGrid.cOrder, ",", " DESC,") + " DESC"
			ENDIF
		ELSE
			IF EMPTY(loGrid.cOrder)
				lcWhere = IIF(tnDirection = -1, "", SqlWhere("", loGrid.cPrimaryKey + " > " + SqlCnv(loGrid.uSelectedPK,.T.)))
				lcOrder = " ORDER BY " + loGrid.cPrimaryKey
			ELSE
				lcWhere = IIF(tnDirection = -1, "", SqlWhere("", lcOrderExpression + " > " + SqlCnv(loGrid.uSelectedOrder,.T.)))
				lcOrder = " ORDER BY " + loGrid.cOrder
			ENDIF
		ENDIF
		lcWhere = SqlWhere(lcWhere, loGrid.cForClause)
		
		lcSource = SqlCursor("SELECT TOP " + TRANSFORM(ABS(tnRows)) + " *, '' AS c_order FROM " + loGrid.cSource + lcWhere + lcOrder,,,,,,,.T.)
		CFCursorNullsRemove(.T.,lcSource)
		SCAN
			SCATTER MEMO NAME loRecord
			IF NOT EMPTY(loGrid.cOrder)
				loRecord.c_order = EVALUATE(SqlParse(lcOrderExpression))
			ENDIF
			IF SEEK(EVALUATE("loRecord."+loGrid.cPrimaryKey), loGrid.RecordSource, "c_pk")
				SELECT(loGrid.RecordSource)
				GATHER MEMO NAME loRecord
				SELECT(lcSource)
			ELSE
				INSERT INTO (loGrid.RecordSource) FROM NAME loRecord
			ENDIF
		ENDSCAN
		SELECT (loGrid.RecordSource)
		GO lnRecNo
		SqlCursor("SELECT " + loGrid.cPrimaryKey + " FROM " + loGrid.cSource + " WHERE " + loGrid.cPrimaryKey + " = " + SqlCnv(EVALUATE(loGrid.cPrimaryKey),.T.),lcSource)
		IF RECCOUNT(lcSource) = 0
			DELETE IN (loGrid.RecordSource)
		ENDIF
		DClose(lcSource)
		
		SELECT(lnArea)
		
		RETURN .T.
	ENDPROC

	PROCEDURE browsesource
		LOCAL loGrid, lcSource, lcOrder, lcKeyExpression
		
		loGrid = this.oGridReference
		* it is mostly job for browse...
		IF EMPTY(loGrid.RecordSource)
			lcSource = SqlCursor("SELECT *, CAST('' AS Character(100)) AS c_order FROM " + loGrid.cSource + " WHERE 0=1",,,,,,,.T.)
			lcKeyExpression = loGrid.cPrimaryKey
			INDEX ON &lcKeyExpression TAG c_pk
			INDEX ON c_order TAG c_order
		ELSE
			lcSource = loGrid.RecordSource
			loGrid.RecordSource = ""
			ZAP IN (lcSource)
		ENDIF
		loGrid.RecordSource = lcSource
		
		lcOrder = IIF(EMPTY(loGrid.cOrder), "c_pk", "c_order")
		SET ORDER TO &lcOrder IN (loGrid.RecordSource)
		
		RETURN .T.
	ENDPROC

	PROCEDURE browseupdateexistingrows
		LPARAMETERS tnRowsToUpdate
		LOCAL i, lnSkip, lnStep, llMainCondition, lnArea, lcSource, lcWhere, lcWherePK, loGrid, lnRecNo
		
		lnArea = SELECT()
		
		loGrid = this.oGridReference
		
		lnSkip = SIGN(tnRowsToUpdate)
		lnStep = ABS(tnRowsToUpdate)
		
		SELECT (loGrid.RecordSource)
		lnRecNo = RECNO()
		lcWherePK = "INLIST(" + loGrid.cPrimaryKey
		i = 0
		DO WHILE i < lnStep AND NOT IIF(lnSkip > 0, EOF(), BOF())
			lcWherePK = lcWherePK + "," + SqlCnv(EVALUATE(loGrid.cPrimaryKey),.T.)
			i = i + 1
			SKIP lnSkip
		ENDDO
		lcWherePK = lcWherePK + ")"
		IF Odbc()
			IF i > 0
				lcWhere = SqlWhere("", lcWherePK)
				lcWhere = SqlWhere(lcWhere, loGrid.cForClause)
				lcSource = SqlCursor("SELECT * FROM " + loGrid.cSource + lcWhere,,,,,,,.T.)
				SELECT (loGrid.RecordSource)
			ENDIF
		ELSE
			lcSource = loGrid.cSource
		ENDIF
		IF i > 0
			GO lnRecNo
			DELETE FOR EMPTY(lcSource) OR NOT USED(lcSource) OR NOT DLocate(lcSource, loGrid.cPrimaryKey + " = " + SqlCnv(EVALUATE(loGrid.cPrimaryKey))) ;
				WHILE &lcWherePK
			GO lnRecNo
			IF DELETED()
				SKIP lnSkip
			ENDIF
		
			IF lcSource <> loGrid.cSource
				DClose(lcSource)
			ENDIF
		ENDIF
		
		SELECT (lnArea)
		
		RETURN .T.
	ENDPROC

	PROCEDURE Destroy
		this.oGridReference = .NULL.
	ENDPROC

ENDDEFINE
