*--------------------------------------------------------------------------------------------------------------------------------------------------------
* (ES) AUTOGENERADO - ¡¡ATENCIÓN!! - ¡¡NO PENSADO PARA EJECUTAR!! USAR SOLAMENTE PARA INTEGRAR CAMBIOS Y ALMACENAR CON HERRAMIENTAS SCM!!
* (EN) AUTOGENERATED - ATTENTION!! - NOT INTENDED FOR EXECUTION!! USE ONLY FOR MERGING CHANGES AND STORING WITH SCM TOOLS!!
*--------------------------------------------------------------------------------------------------------------------------------------------------------
*< FOXBIN2PRG: Version="1.19" SourceFile="sfctrls.vcx" /> (Solo para binarios VFP 9 / Only for VFP 9 binaries)
*
*
DEFINE CLASS sfcollection AS collection 
 	*< CLASSDATA: Baseclass="collection" Timestamp="" Scale="Pixels" Uniqueid="" />

	#INCLUDE "sfctrls.h"
	*<DefinedPropArrayMethod>
		*m: about		&& Provides documentation for the class
		*m: additem		&& Adds an item (backward compatibility)
		*m: calledfromthisclass		&& Determines if the method that called this method was called from a method of this class or an ancestor
		*m: cleanup		&& Cleans up member references when the object is released or destroyed
		*m: clear		&& Clears the collection
		*m: fillarrayrow		&& Fills the specified row in the passed array with information about the current item
		*m: fillcollection		&& Loads the collection from persistent storage
		*m: getarray		&& Fills the passed array with information about objects in the collection
		*m: release		&& Releases the object
		*m: releasemembers		&& Abstract method to nuke member references
		*m: removeitem		&& Removes an item (backward compatibility)
		*m: savecollection		&& Saves the collection to persistent storage
		*m: saveitem		&& Saves the specified item to persistent storage
		*p: cerrormessage		&& The text of an error message
		*p: lerroroccurred		&& .T. if an error occurred
		*p: lfilloninit		&& .T. if we're supposed to fill the collection when it's instantiated
		*p: lrelease		&& .T. as the object is being released
		*p: oexception		&& A reference to an Exception object
		*p: _memberdata		&& XML Metadata for customizable properties
	*</DefinedPropArrayMethod>

	PROTECTED lrelease
	cerrormessage = 		&& The text of an error message
	Height = 23
	lerroroccurred = .F.		&& .T. if an error occurred
	lrelease = .F.		&& .T. as the object is being released
	Name = "sfcollection"
	oexception = .NULL.		&& A reference to an Exception object
	Width = 23
	_memberdata = <VFPData>
		<memberdata name="about" type="method" display="About"/>
		<memberdata name="clear" type="method" display="Clear"/>
		<memberdata name="fillarrayrow" type="method" display="FillArrayRow" favorites="True"/>
		<memberdata name="fillcollection" type="method" display="FillCollection"/>
		<memberdata name="getarray" type="method" display="GetArray"/>
		<memberdata name="lfilloninit" type="property" display="lFillOnInit" favorites="True"/>
		<memberdata name="oexception" type="property" display="oException"/>
		<memberdata name="release" type="method" display="Release"/>
		<memberdata name="savecollection" type="method" display="SaveCollection"/>
		<memberdata name="saveitem" type="method" display="SaveItem" favorites="True"/>
		<memberdata name="releasemembers" type="method" display="ReleaseMembers"/>
		<memberdata name="cerrormessage" type="property" display="cErrorMessage"/>
		<memberdata name="lerroroccurred" type="property" display="lErrorOccurred"/>
		<memberdata name="lrelease" type="property" display="lRelease"/>
		<memberdata name="cleanup" type="method" display="Cleanup"/>
		<memberdata name="calledfromthisclass" type="method" display="CalledFromThisClass"/>
		<memberdata name="additem" type="method" display="AddItem"/>
		<memberdata name="removeitem" type="method" display="RemoveItem"/>
		</VFPData>		&& XML Metadata for customizable properties
	
	PROCEDURE about		&& Provides documentation for the class
		*==============================================================================
		* Class:						SFCollection
		* Based On:						Collection
		* Purpose:						Base class for all Collection objects
		* Author:						Doug Hennig
		* Copyright:					(c) 2003-2008 Stonefield Systems Group Inc.
		* Last revision:				05/22/2008
		* Include file:					SFCTRLS.H
		*
		* Changes in "Based On" class properties:
		*	None
		*
		* Changes in "Based On" class methods:
		*	Add:						store upper-cased key so case-insensitive and
		*									ignore duplicate keys
		*	Destroy:					cleanup as the object is destroyed
		*	Error:						calls the parent Error method so error handling
		*								goes up the containership hierarchy
		*	GetKey:						handle case-insensitivity
		*	Init:						calls FillCollection if lFillOnInit is .T.
		*	Item:						return .NULL. if the item isn't found and
		*								handle case-insensitivity
		*	Remove:						handle case-insensitivity
		*
		* Custom public properties added:
		*	cErrorMessage:				the message of an error
		*	lErrorOccurred:				.T. if an error occurred
		*	lFillOnInit:				.T. if we're supposed to fill the collection
		*								when it's instantiated
		*	oException:					a reference to an Exception object
		*
		* Custom protected properties added:
		*	lRelease:					.T. as the object is being released
		*
		* Custom public methods added:
		*	About:						provides documentation for the class
		*	AddItem:					adds an item (backward compatibility)
		*	Clear:						clears the collection
		*	GetArray:					fills the passed array with information about
		*								objects in the collection
		*	FillCollection:				loads the collection from persistent storage
		*	Release:					releases the object
		*	ReleaseMembers:				abstract method to nuke member references
		*	RemoveItem:					removes an item (backward compatibility)
		*	SaveCollection:				saves the collection to persistent storage
		*	SaveItem:					saves the specified item to persistent storage
		*
		* Custom protected methods added:
		*	CalledFromThisClass:		returns .T. if a method was called from this
		*								class
		*	Cleanup:					cleans up member references when the object is
		*								released or destroyed
		*	FillArrayRow:				fills the specified row in the passed array
		*								with information about the current item
		*==============================================================================
		
	ENDPROC

	PROCEDURE Add
		lparameters tuItem, ;
			tcKey, ;
			tuBefore, ;
			tuAfter
		local lcKey
		do case
			case pcount() = 1
				dodefault(tuItem)
			case vartype(tcKey) = 'C'
				lcKey = upper(alltrim(tcKey))
				do case
					case This.GetKey(lcKey) > 0
					case pcount() = 2
						dodefault(tuItem, lcKey)
					case pcount() = 3
						dodefault(tuItem, lcKey, tuBefore)
					case pcount() = 4
						dodefault(tuItem, lcKey, tuBefore, tuAfter)
				endcase
			case pcount() = 3
				dodefault(tuItem, tcKey, tuBefore)
			case pcount() = 4
				dodefault(tuItem, tcKey, tuBefore, tuAfter)
		endcase
		nodefault
		
	ENDPROC

	PROCEDURE additem		&& Adds an item (backward compatibility)
		lparameters tuItem, ;
			tcKey, ;
			tuBefore, ;
			tuAfter
		local luReturn
		do case
			case pcount() = 1
				luReturn = This.Add(tuItem)
			case pcount() = 2
				luReturn = This.Add(tuItem, tcKey)
			case pcount() = 3
				luReturn = This.Add(tuItem, tcKey, tuBefore)
			case pcount() = 4
				luReturn = This.Add(tuItem, tcKey, tuBefore, tuAfter)
		endcase
		return luReturn
		
	ENDPROC

	PROTECTED PROCEDURE calledfromthisclass		&& Determines if the method that called this method was called from a method of this class or an ancestor
		*==============================================================================
		* Method:			CalledFromThisClass
		* Status:			Protected
		* Purpose:			Determines if the method that called this method was called
		*						from a method of this class or an ancestor
		* Author:			Doug Hennig
		* Copyright:		(c) 1998-2005 Stonefield Systems Group Inc.
		* Last Revision:	01/29/2005
		* Parameters:		none
		* Returns:			.T. if the method that called this method was called from a
		*						method of this class or an ancestor
		* Environment in:	none
		* Environment out:	none
		* Notes:			The reason we want to know if the method that called this
		*						method was called from a method of this class or not is
		*						to permit "read-only" properties to be changed only by
		*						methods of this class. This would typically be called
		*						from an Assign method, such as:
		*
		*					lparameters tuNewValue
		*					if This.CalledFromThisClass()
		*						This.<property> = tuNewValue
		*					else
		*						error 1743, '<property>'   && property is read-only
		*					endif This.CalledFromThisClass()
		*==============================================================================
		
		local lnLevel, ;
			lcProgram, ;
			lcObject, ;
			loParent, ;
			laClasses[1], ;
			lnClasses, ;
			lnI, ;
			llReturn, ;
			lcThisName
		
		* Get the name of the program that called us, and get the object name from it.
		* Set loParent to our parent if there is one.
		
		lnLevel   = program(-1)
		lcProgram = iif(lnLevel > 2, upper(program(lnLevel - 2)), '')
		lcObject  = left(lcProgram, rat('.', lcProgram) - 1)
		loParent  = iif(type('This.Parent') = 'O', This.Parent, .NULL.)
		
		* Check our class hierarchy to see if we were called from ourselves or an
		* ancester method.
		
		lnClasses = aclass(laClasses, This)
		for lnI = 1 to lnClasses
			if lcObject == upper(laClasses[lnI])
				llReturn = .T.
				exit
			endif lcObject == upper(laClasses[lnI])
		next lnI
		
		* If we didn't come from ourselves or an ancestor and we have a parent, our
		* name may not match our class, so check the containership hierarchy.
		
		if not llReturn and not isnull(loParent)
			lcThisName = This.Name
			do while vartype(loParent) = 'O'
				lcThisName = loParent.Name + '.' + lcThisName
				loParent   = iif(type('loParent.Parent') = 'O', loParent.Parent, ;
					.NULL.)
			enddo while vartype(loParent) = 'O'
			llReturn = upper(lcObject) == upper(lcThisName)
		endif not llReturn ...
		return llReturn
		
	ENDPROC

	PROCEDURE cleanup		&& Cleans up member references when the object is released or destroyed
		*==============================================================================
		* Method:			Cleanup
		* Status:			Protected
		* Purpose:			Nuke member objects
		* Author:			Doug Hennig
		* Copyright:		(c) 1998-2005 Stonefield Systems Group Inc.
		* Last Revision:	01/29/2005
		* Parameters:		none
		* Returns:			.T. if everything succeeded
		* Environment in:	This.lRelease is .T. if we're already in the process of
		*						releasing
		* Environment out:	This.lRelease is .T.
		*					This.ReleaseMembers() was called
		* Notes:			This methods avoids use of "with This" to prevent potential
		*						problems with dangling object references
		*==============================================================================
		
		if This.lRelease
			return .F.
		endif This.lRelease
		This.lRelease = .T.
		This.ReleaseMembers()
		
	ENDPROC

	PROCEDURE clear		&& Clears the collection
		This.Remove(-1)
		
	ENDPROC

	PROCEDURE Destroy
		* Cleanup as the object is destroyed.
		
		This.Cleanup()
		
	ENDPROC

	PROCEDURE Error
		*==============================================================================
		* Method:			Error
		* Status:			Public
		* Purpose:			Handles errors
		* Author:			Doug Hennig
		* Copyright:		(c) 1996-2005 Stonefield Systems Group Inc.
		* Last revision:	12/15/2005
		* Parameters:		tnError  - the error number
		*					tcMethod - the method that caused the error
		*					tnLine   - the line number of the command in error 
		* Returns:			may return an error resolution string (see SFERRORS.H for
		*						a list) or may RETURN, RETRY, or CANCEL
		* Environment in:	if a global error handler object exists, it's in the global
		*						variable oError
		*					a global ON ERROR routine may be in effect
		* Environment out:	depends on the error resolution chosen
		*==============================================================================
		
		lparameters tnError, ;
			tcMethod, ;
			tnLine
		local lnError, ;
			lcMethod, ;
			lnLine, ;
			lcSource, ;
			laError[1], ;
			lcName, ;
			lcOrigMethod, ;
			loParent, ;
			lcReturn, ;
			lcError, ;
			lcMessage, ;
			lnChoice
		
		* Use AERROR() to get information about the error. If we have an Exception
		* object in oException, get information about the error from it.
		
		lnError  = tnError
		lcMethod = tcMethod
		lnLine   = tnLine
		lcSource = message(1)
		aerror(laError)
		with This
			if vartype(.oException) = 'O'
				lnError  = .oException.ErrorNo
				lcMethod = .oException.Procedure
				lnLine   = .oException.LineNo
				lcSource = .oException.LineContents
				laError[cnAERR_NUMBER]  = .oException.ErrorNo
				laError[cnAERR_MESSAGE] = .oException.Message
				laError[cnAERR_OBJECT]  = .oException.Details
				.oException = .NULL.
			endif vartype(.oException) = 'O'
		endwith
		
		* Determine which method of which object the error occurred in. If the error
		* occurred in a child object, the method may already have our name on it, so
		* handle that.
		
		lcName   = upper(This.Name) + '.'
		lcMethod = upper(tcMethod)
		if lcMethod = lcName or '.' + lcName $ lcMethod
			lcOrigMethod = substr(tcMethod, rat('.', tcMethod) + 1)
		else
			lcOrigMethod = tcMethod
		endif lcMethod = lcName ...
		lcMethod = This.Name + '.' + lcOrigMethod
		
		* If we're sitting on a form and that form has a FindErrorHandler method, call
		* it to travel up the containership hierarchy until we find a parent that has
		* code in its Error method. Also, if it has a SetError method, call it now so
		* we don't lose the message information (which gets messed up by TYPE()).
		
		if type('Thisform') = 'O'
			loParent = iif(pemstatus(Thisform, 'FindErrorHandler', 5), ;
				Thisform.FindErrorHandler(This), .NULL.)
			if pemstatus(Thisform, 'SetError', 5)
				Thisform.SetError(lcMethod, lnLine, lcSource, @laError)
			endif pemstatus(Thisform, 'SetError', 5)
		else
			loParent = .NULL.
		endif type('Thisform') = 'O'
		do case
		
		* We have a parent that can handle the error.
		
			case not isnull(loParent)
				lcReturn = loParent.Error(lnError, lcMethod, lnLine)
		
		* We have an error handling object, so call its ErrorHandler() method.
		
			case type('oError.Name') = 'C' and pemstatus(oError, 'ErrorHandler', 5)
				if pemstatus(oError, 'SetError', 5)
					oError.SetError(lcMethod, lnLine, lcSource, @laError)
				endif pemstatus(oError, 'SetError', 5)
				lcReturn = oError.ErrorHandler(lnError, lcMethod, lnLine)
		
		* A global error handler is in effect, so let's pass the error on to it.
		* Replace certain parameters passed to the error handler (the name of the
		* program, the error number, the line number, the message, and SYS(2018)) with
		* the appropriate values.
		
			case not empty(on('ERROR'))
				lcError = upper(on('ERROR'))
				lcError = strtran(lcError, 'SYS(16)',   '"' + lcMethod + '"')
				lcError = strtran(lcError, 'PROGRAM()', '"' + lcMethod + '"')
				lcError = strtran(lcError, ',ERROR()',  ',lnError')
				lcError = strtran(lcError, ' ERROR()',  ' lnError')
				lcError = strtran(lcError, 'LINENO()',  'lnLine')
				lcError = strtran(lcError, 'MESSAGE()', 'laError[2]')
				lcError = strtran(lcError, 'SYS(2018)', 'laError[3]')
		
		* If the error handler is called with DO, macro expand it and assume the return
		* value is "CONTINUE". If the error handler is called as a function (such as an
		* object method), call it and grab the return value if there is one.
		
				if left(lcError, 3) = 'DO ' or '=' $ lcError
					&lcError
					lcReturn = ccMSG_CONTINUE
				else
					lcReturn = &lcError
				endif left(lcError, 3) = 'DO ' ...
		
		* Display a generic dialog box with an option to display the debugger (this
		* should only occur in a test environment).
		
			otherwise
				lcSource  = message(1)
				lcMessage = ccMSG_ERROR_NUM + ' ' + transform(lnError) + ccCR + ;
					ccMSG_MESSAGE + ' ' + laError[cnAERR_MESSAGE] + ccCR + ;
					iif(empty(lcSource), '', ccMSG_CODE + ' ' + lcSource + ;
					ccCR) + iif(lnLine = 0, '', ccMSG_LINE_NUM + ' ' + ;
					transform(lnLine) + ccCR) + ccMSG_METHOD + ' ' + lcMethod
				if version(2) = 0
					lnChoice = messagebox(lcMessage + ccCR + ccCR + ;
						'Choose OK to continue or Cancel to cancel execution', ;
						MB_OKCANCEL + MB_ICONSTOP, _VFP.Caption)
				else
					lnChoice = messagebox(lcMessage + ccCR + ccCR + ;
						'Choose Yes to display the debugger, No to continue ' + ;
						'without the debugger, or Cancel to cancel execution', ;
						MB_YESNOCANCEL + MB_ICONSTOP, _VFP.Caption)
				endif version(2) = 0
				do case
					case lnChoice = IDYES
						lcReturn = ccMSG_DEBUG
					case lnChoice = IDCANCEL
						lcReturn = ccMSG_CANCEL
				endcase
		endcase
		
		* Ensure the return message is acceptable. If not, assume "CONTINUE".
		
		lcReturn = iif(vartype(lcReturn) <> 'C' or empty(lcReturn) or ;
			not lcReturn $ ccMSG_CONTINUE + ccMSG_RETRY + ccMSG_CANCEL + ccMSG_DEBUG, ;
			ccMSG_CONTINUE, lcReturn)
		
		* Handle the return value.
		
		do case
		
		* It wasn't our error, so pass it back to the calling method.
		
			case '.' $ lcOrigMethod
				return lcReturn
		
		* Display the debugger.
		
			case lcReturn = ccMSG_DEBUG
				debug
				if wexist('Visual FoxPro Debugger')
					keyboard '{SHIFT+F7}' plain
				endif wexist('Visual FoxPro Debugger')
				suspend
		
		* Retry the command.
		
			case lcReturn = ccMSG_RETRY
				retry
		
		* Cancel execution.
		
			case lcReturn = ccMSG_CANCEL
				cancel
		
		* Go to the line of code following the error.
		
			otherwise
				return
		endcase
		
	ENDPROC

	PROTECTED PROCEDURE fillarrayrow		&& Fills the specified row in the passed array with information about the current item
		lparameters taArray, ;
			tnItem, ;
			toItem
		taArray[tnItem] = toItem.Name
		
	ENDPROC

	PROCEDURE fillcollection		&& Loads the collection from persistent storage
		* Abstract method
		
	ENDPROC

	PROCEDURE getarray		&& Fills the passed array with information about objects in the collection
		lparameters taArray
		local lnItem, ;
			loItem
		if This.Count > 0
			dimension taArray[This.Count]
		else
			dimension taArray[1]
		endif This.Count > 0
		lnItem = 0
		for each loItem in This foxobject
			lnItem = lnItem + 1
			This.FillArrayRow(@taArray, lnItem, loItem)
		next loItem
		return This.Count
		
	ENDPROC

	PROCEDURE GetKey
		lparameters tuIndex
		local lcIndex, ;
			luReturn
		if vartype(tuIndex) = 'C'
			lcIndex  = upper(alltrim(tuIndex))
			luReturn = dodefault(lcIndex)
		else
			luReturn = dodefault(tuIndex)
		endif vartype(tuIndex) = 'C'
		nodefault
		return luReturn
		
	ENDPROC

	PROCEDURE Init
		* Fill the collection if we're supposed to.
		
		with This
			if .lFillOnInit
				.FillCollection()
			endif .lFillOnInit
		endwith
		
	ENDPROC

	PROCEDURE Item
		lparameters tuIndex
		local luReturn, ;
			lcIndex
		luReturn = .NULL.
		if vartype(tuIndex) = 'C'
			lcIndex = upper(alltrim(tuIndex))
			if This.GetKey(lcIndex) > 0
				luReturn = dodefault(lcIndex)
			endif This.GetKey(lcIndex) > 0
		else
			try
				luReturn = dodefault(tuIndex)
			catch
			endtry
		endif vartype(tuIndex) = 'C'
		nodefault
		return luReturn
		
	ENDPROC

	PROCEDURE release		&& Releases the object
		* Release the object. Note the avoidance of "with This" in this code to prevent
		* potential problems with dangling object references.
		
		if This.lRelease
			nodefault
			return .F.
		endif This.lRelease
		This.Cleanup()
		release This
		
	ENDPROC

	PROCEDURE releasemembers		&& Abstract method to nuke member references
		* Abstract method
		
	ENDPROC

	PROCEDURE Remove
		lparameters tuIndex
		local lcIndex, ;
			luReturn
		if vartype(tuIndex) = 'C'
			lcIndex = upper(alltrim(tuIndex))
			if This.GetKey(lcIndex) > 0
				dodefault(lcIndex)
			endif This.GetKey(lcIndex) > 0
		else
			dodefault(tuIndex)
		endif vartype(tuIndex) = 'C'
		nodefault
		
	ENDPROC

	PROCEDURE removeitem		&& Removes an item (backward compatibility)
		lparameters tuIndex
		return This.Remove(tuIndex)
		
	ENDPROC

	PROCEDURE savecollection		&& Saves the collection to persistent storage
		local loItem
		for each loItem in This foxobject
			This.SaveItem(loItem)
		next loItem
		
	ENDPROC

	PROCEDURE saveitem		&& Saves the specified item to persistent storage
		lparameters toItem
		
		* Abstract method
		
	ENDPROC

ENDDEFINE

DEFINE CLASS sfcombobox AS combobox 		&& Base class for ComboBox objects
 	*< CLASSDATA: Baseclass="combobox" Timestamp="" Scale="Pixels" Uniqueid="" />

	#INCLUDE "sfctrls.h"
	*<DefinedPropArrayMethod>
		*m: about		&& Provides documentation for the class
		*m: anychange		&& Called from the InteractiveChange and ProgrammaticChange events to consolidate change code in one place
		*m: lsaveanchor_assign
		*m: onformchange		&& Fired when the lChanged property of the form changes if lNotifyOnFormChange is .T.
		*m: release		&& Releases the object
		*m: shortcutmenu		&& Populates the shortcut menu
		*m: showmenu		&& Display a shortcut menu
		*m: updatecontrolsource		&& Updates the control source
		*m: validation		&& An abstract method for custom validation code
		*p: builder		&& Tells BUILDER.APP the name of a specific builder to use for this class (specified as Library,Class)
		*p: ccollectionobjectproperty		&& The property of objects in the collection specified by oRowSourceCollection used to fill the combobox
		*p: lbindtoformanychange		&& .T. to bind this control's AnyChange event to its form's AnyChange method
		*p: lnotifyonformchange		&& .T. if the OnFormChanged method of this control is bound to the lChanged property of the form
		*p: lrequeryoninit		&& .T. to call Requery from Init
		*p: lsaveanchor		&& This allows a container to use SetAll('lSaveAnchor') to save/reset and then restore Anchor when the form's size is changed but controls shouldn't move
		*p: lskipvalidonformclose		&& .T. if we can skip validating this control when the form is closed
		*p: lupdatecontrolsource		&& .T. if UpdateControlSource should be called from InteractiveChange
		*p: luseformshortcutmenu		&& .T. if the form's shortcut menu items should be included with this object's
		*p: nsavedanchor		&& The anchor value saved in lSaveAnchor_Assign
		*p: oexception		&& A reference to an Exception object
		*p: ohook		&& A reference to a hooked object
		*p: omenu		&& A reference to an SFShortcutMenu object
		*p: orowsourcecollection		&& A reference to a Collection object that provides the row source elements
		*a: aitems[1,0]		&& An array that can hold the values used for the ComboBox when RowSourceType is 5
		*p: _memberdata		&& XML Metadata for customizable properties
	*</DefinedPropArrayMethod>

	PROTECTED nsavedanchor
	BoundTo = .T.
	builder = 		&& Tells BUILDER.APP the name of a specific builder to use for this class (specified as Library,Class)
	ccollectionobjectproperty = 		&& The property of objects in the collection specified by oRowSourceCollection used to fill the combobox
	FontName = "Tahoma"
	ItemTips = .T.
	lbindtoformanychange = .F.		&& .T. to bind this control's AnyChange event to its form's AnyChange method
	lnotifyonformchange = .F.		&& .T. if the OnFormChanged method of this control is bound to the lChanged property of the form
	lrequeryoninit = .T.		&& .T. to call Requery from Init
	lsaveanchor = .F.		&& This allows a container to use SetAll('lSaveAnchor') to save/reset and then restore Anchor when the form's size is changed but controls shouldn't move
	lskipvalidonformclose = .T.		&& .T. if we can skip validating this control when the form is closed
	lupdatecontrolsource = .F.		&& .T. if UpdateControlSource should be called from InteractiveChange
	luseformshortcutmenu = .F.		&& .T. if the form's shortcut menu items should be included with this object's
	Name = "sfcombobox"
	nsavedanchor = 0		&& The anchor value saved in lSaveAnchor_Assign
	oexception = .NULL.		&& A reference to an Exception object
	ohook = .NULL.		&& A reference to a hooked object
	omenu = .NULL.		&& A reference to an SFShortcutMenu object
	orowsourcecollection = .NULL.		&& A reference to a Collection object that provides the row source elements
	RowSource = "This.aItems"
	RowSourceType = 5
	SelectOnEntry = .T.
	Style = 2
	_memberdata = <VFPData>
		<memberdata name="about" type="method" display="About"/>
		<memberdata name="aitems" type="property" display="aItems"/>
		<memberdata name="anychange" type="method" display="AnyChange" favorites="True"/>
		<memberdata name="builder" type="property" display="Builder"/>
		<memberdata name="ccollectionobjectproperty" type="property" display="cCollectionObjectProperty" favorites="True"/>
		<memberdata name="lrequeryoninit" type="property" display="lRequeryOnInit" favorites="True"/>
		<memberdata name="lskipvalidonformclose" type="property" display="lSkipValidOnFormClose" favorites="True"/>
		<memberdata name="luseformshortcutmenu" type="property" display="lUseFormShortcutMenu" favorites="True"/>
		<memberdata name="oexception" type="property" display="oException"/>
		<memberdata name="ohook" type="property" display="oHook"/>
		<memberdata name="omenu" type="property" display="oMenu"/>
		<memberdata name="orowsourcecollection" type="property" display="oRowSourceCollection" favorites="True"/>
		<memberdata name="release" type="method" display="Release"/>
		<memberdata name="shortcutmenu" type="method" display="ShortcutMenu" favorites="True"/>
		<memberdata name="showmenu" type="method" display="ShowMenu"/>
		<memberdata name="validation" type="method" display="Validation" favorites="True"/>
		<memberdata name="lsaveanchor" type="property" display="lSaveAnchor"/>
		<memberdata name="lsaveanchor_assign" type="property" display="lSaveAnchor_Assign"/>
		<memberdata name="nsavedanchor" type="property" display="nSavedAnchor"/>
		<memberdata name="lbindtoformanychange" type="property" display="lBindToFormAnyChange"/>
		<memberdata name="onformchange" type="method" display="OnFormChange"/>
		<memberdata name="lnotifyonformchange" type="property" display="lNotifyOnFormChange"/>
		<memberdata name="updatecontrolsource" type="method" display="UpdateControlSource"/>
		<memberdata name="lupdatecontrolsource" type="property" display="lUpdateControlSource"/>
		</VFPData>		&& XML Metadata for customizable properties
	
	PROCEDURE about		&& Provides documentation for the class
		*==============================================================================
		* Class:						SFComboBox
		* Based On:						ComboBox
		* Purpose:						Base class for all ComboBox objects
		* Author:						Doug Hennig
		* Copyright:					(c) 1996-2008 Stonefield Systems Group Inc.
		* Last revision:				05/22/2008
		* Include file:					SFCTRLS.H
		*
		* Changes in "Based On" class properties:
		*	BoundTo:					.T.
		*	FontName:					Tahoma
		*	ItemTips:					.T.
		*	RowSource:					This.aItems (see below)
		*	RowSourceType:				5 (Array)
		*	SelectOnEntry:				.T.
		*	Style:						2 (Dropdown List) because this is what we
		*								usually use
		*
		* Changes in "Based On" class methods:
		*	Destroy:					nukes member objects
		*	DropDown:					set DisplayCount to an appropriate value based
		*								on how much room there is below the form
		*	Error:						calls the parent Error method so error handling
		*								goes up the containership hierarchy
		*	Init:						initialize This.aItems to blanks and call
		*								This.Requery if This.lRequeryOnInit is .T. Bind
		*								InteractiveChange to the form's AnyChange
		*								method and bind OnFormChange to the form's
		*								lChanged property if necessary. Change FontName
		*								to Segoe UI in Vista
		*	InteractiveChange:			calls UpdateControlSource and raises the
		*								AnyChange event
		*	KeyPress:					ignore Ctrl-0 and backspace at the start of the
		*								control
		*	ProgrammaticChange:			raises the AnyChange event
		*	Requery:					handle RowSourceType = 0-None or 1-Value when
		*								RowSource references an array containing the
		*								values or oRowSourceCollection references a
		*								collection with the values
		*	RightClick:					call This.ShowMenu
		*	Valid:						prevent validation code from executing if the
		*								user is cancelling, retain focus if a field
		*								rule failed, and call the custom Validation
		*								method
		*
		* Custom public properties added:
		*	aItems[1]:					an array that can hold the values used for the
		*								ComboBox when RowSourceType is 5
		*	Builder:					tells BUILDER.APP the name of a specific
		*								builder to use for this class (specified as
		*								Library,Class)
		*	cCollectionObjectProperty:	the property of objects in the collection
		*								specified by oRowSourceCollection used to fill
		*								the combobox
		*	lBindToFormAnyChange:		.T. to bind this control's AnyChange event to
		*								its form's AnyChange method
		*	lNotifyOnFormChange:		.T. if the OnFormChanged method of this control
		*								is bound to the lChanged property of the form
		*	lRequeryOnInit:				.T. to call Requery from Init
		*	lSaveAnchor:				this allows a container to use
		*								SetAll('lSaveAnchor') to save/reset and then
		*								restore Anchor when the form's size is changed
		*								but controls shouldn't move
		*	lSkipValidOnFormClose:		.T. if we can skip validating this control when
		*								the form is closed
		*	lUpdateControlSource:		.T. if UpdateControlSource should be called
		*								from InteractiveChange
		*	lUseFormShortcutMenu:		.T. if the form's shortcut menu items should be
		*								included with this object's
		*	oException:					a reference to an Exception object
		*	oHook:						a reference to a hooked object
		*	oMenu:						a reference to an SFShortcutMenu object
		*	oRowSourceCollection:		a reference to a Collection object that
		*								provides the row source elements
		*
		* Custom protected properties added:
		*	nSavedAnchor:				the anchor value saved in lSaveAnchor_Assign
		*
		* Custom public methods added:
		*	About:						provides documentation for the class
		*	AnyChange:					called from the InteractiveChange and
		*								ProgrammaticChange events to consolidate
		*								change code in one place
		*	OnFormChange:				fired when the lChanged property of the form
		*								changes if lNotifyOnFormChange is .T.
		*	Release:					releases the object
		*	ShortcutMenu:				populates the shortcut menu
		*	ShowMenu:					display a shortcut menu
		*	UpdateControlSource:		updates the control source
		*	Validation:					abstract method for custom validation code
		*
		* Custom protected methods added:
		*	None
		*==============================================================================
		
	ENDPROC

	PROCEDURE anychange		&& Called from the InteractiveChange and ProgrammaticChange events to consolidate change code in one place
		* Abstract method
		
	ENDPROC

	PROCEDURE Destroy
		* Nuke member objects.
		
		This.oHook = .NULL.
		This.oMenu = .NULL.
		This.oRowSourceCollection = .NULL.
		
	ENDPROC

	PROCEDURE DropDown
		* Set DisplayCount to an appropriate value based on how much room there is
		* below the form.
		
		local lnHeight
		lnHeight = iif(Thisform.ShowWindow = 2 or Thisform.Desktop, sysmetric(2), ;
			_vfp.Height)
		This.DisplayCount = max(ceiling((lnHeight - Thisform.Top - ;
			objtoclient(This, 1))/This.Height), 7)
		
	ENDPROC

	PROCEDURE Error
		*==============================================================================
		* Method:			Error
		* Status:			Public
		* Purpose:			Handles errors
		* Author:			Doug Hennig
		* Copyright:		(c) 1996-2005 Stonefield Systems Group Inc.
		* Last revision:	12/15/2005
		* Parameters:		tnError  - the error number
		*					tcMethod - the method that caused the error
		*					tnLine   - the line number of the command in error 
		* Returns:			may return an error resolution string (see SFERRORS.H for
		*						a list) or may RETURN, RETRY, or CANCEL
		* Environment in:	if a global error handler object exists, it's in the global
		*						variable oError
		*					a global ON ERROR routine may be in effect
		* Environment out:	depends on the error resolution chosen
		*==============================================================================
		
		lparameters tnError, ;
			tcMethod, ;
			tnLine
		local lnError, ;
			lcMethod, ;
			lnLine, ;
			lcSource, ;
			laError[1], ;
			lcName, ;
			lcOrigMethod, ;
			loParent, ;
			lcReturn, ;
			lcError, ;
			lcMessage, ;
			lnChoice
		
		* Use AERROR() to get information about the error. If we have an Exception
		* object in oException, get information about the error from it.
		
		lnError  = tnError
		lcMethod = tcMethod
		lnLine   = tnLine
		lcSource = message(1)
		aerror(laError)
		with This
			if vartype(.oException) = 'O'
				lnError  = .oException.ErrorNo
				lcMethod = .oException.Procedure
				lnLine   = .oException.LineNo
				lcSource = .oException.LineContents
				laError[cnAERR_NUMBER]  = .oException.ErrorNo
				laError[cnAERR_MESSAGE] = .oException.Message
				laError[cnAERR_OBJECT]  = .oException.Details
				.oException = .NULL.
			endif vartype(.oException) = 'O'
		endwith
		
		* Determine which method of which object the error occurred in. If the error
		* occurred in a child object, the method may already have our name on it, so
		* handle that.
		
		lcName   = upper(This.Name) + '.'
		lcMethod = upper(tcMethod)
		if lcMethod = lcName or '.' + lcName $ lcMethod
			lcOrigMethod = substr(tcMethod, rat('.', tcMethod) + 1)
		else
			lcOrigMethod = tcMethod
		endif lcMethod = lcName ...
		lcMethod = This.Name + '.' + lcOrigMethod
		
		* If we're sitting on a form and that form has a FindErrorHandler method, call
		* it to travel up the containership hierarchy until we find a parent that has
		* code in its Error method. Also, if it has a SetError method, call it now so
		* we don't lose the message information (which gets messed up by TYPE()).
		
		if type('Thisform') = 'O'
			loParent = iif(pemstatus(Thisform, 'FindErrorHandler', 5), ;
				Thisform.FindErrorHandler(This), .NULL.)
			if pemstatus(Thisform, 'SetError', 5)
				Thisform.SetError(lcMethod, lnLine, lcSource, @laError)
			endif pemstatus(Thisform, 'SetError', 5)
		else
			loParent = .NULL.
		endif type('Thisform') = 'O'
		do case
		
		* We have a parent that can handle the error.
		
			case not isnull(loParent)
				lcReturn = loParent.Error(lnError, lcMethod, lnLine)
		
		* We have an error handling object, so call its ErrorHandler() method.
		
			case type('oError.Name') = 'C' and pemstatus(oError, 'ErrorHandler', 5)
				if pemstatus(oError, 'SetError', 5)
					oError.SetError(lcMethod, lnLine, lcSource, @laError)
				endif pemstatus(oError, 'SetError', 5)
				lcReturn = oError.ErrorHandler(lnError, lcMethod, lnLine)
		
		* A global error handler is in effect, so let's pass the error on to it.
		* Replace certain parameters passed to the error handler (the name of the
		* program, the error number, the line number, the message, and SYS(2018)) with
		* the appropriate values.
		
			case not empty(on('ERROR'))
				lcError = upper(on('ERROR'))
				lcError = strtran(lcError, 'SYS(16)',   '"' + lcMethod + '"')
				lcError = strtran(lcError, 'PROGRAM()', '"' + lcMethod + '"')
				lcError = strtran(lcError, ',ERROR()',  ',lnError')
				lcError = strtran(lcError, ' ERROR()',  ' lnError')
				lcError = strtran(lcError, 'LINENO()',  'lnLine')
				lcError = strtran(lcError, 'MESSAGE()', 'laError[2]')
				lcError = strtran(lcError, 'SYS(2018)', 'laError[3]')
		
		* If the error handler is called with DO, macro expand it and assume the return
		* value is "CONTINUE". If the error handler is called as a function (such as an
		* object method), call it and grab the return value if there is one.
		
				if left(lcError, 3) = 'DO ' or '=' $ lcError
					&lcError
					lcReturn = ccMSG_CONTINUE
				else
					lcReturn = &lcError
				endif left(lcError, 3) = 'DO ' ...
		
		* Display a generic dialog box with an option to display the debugger (this
		* should only occur in a test environment).
		
			otherwise
				lcSource  = message(1)
				lcMessage = ccMSG_ERROR_NUM + ' ' + transform(lnError) + ccCR + ;
					ccMSG_MESSAGE + ' ' + laError[cnAERR_MESSAGE] + ccCR + ;
					iif(empty(lcSource), '', ccMSG_CODE + ' ' + lcSource + ;
					ccCR) + iif(lnLine = 0, '', ccMSG_LINE_NUM + ' ' + ;
					transform(lnLine) + ccCR) + ccMSG_METHOD + ' ' + lcMethod
				if version(2) = 0
					lnChoice = messagebox(lcMessage + ccCR + ccCR + ;
						'Choose OK to continue or Cancel to cancel execution', ;
						MB_OKCANCEL + MB_ICONSTOP, _VFP.Caption)
				else
					lnChoice = messagebox(lcMessage + ccCR + ccCR + ;
						'Choose Yes to display the debugger, No to continue ' + ;
						'without the debugger, or Cancel to cancel execution', ;
						MB_YESNOCANCEL + MB_ICONSTOP, _VFP.Caption)
				endif version(2) = 0
				do case
					case lnChoice = IDYES
						lcReturn = ccMSG_DEBUG
					case lnChoice = IDCANCEL
						lcReturn = ccMSG_CANCEL
				endcase
		endcase
		
		* Ensure the return message is acceptable. If not, assume "CONTINUE".
		
		lcReturn = iif(vartype(lcReturn) <> 'C' or empty(lcReturn) or ;
			not lcReturn $ ccMSG_CONTINUE + ccMSG_RETRY + ccMSG_CANCEL + ccMSG_DEBUG, ;
			ccMSG_CONTINUE, lcReturn)
		
		* Handle the return value.
		
		do case
		
		* It wasn't our error, so pass it back to the calling method.
		
			case '.' $ lcOrigMethod
				return lcReturn
		
		* Display the debugger.
		
			case lcReturn = ccMSG_DEBUG
				debug
				if wexist('Visual FoxPro Debugger')
					keyboard '{SHIFT+F7}' plain
				endif wexist('Visual FoxPro Debugger')
				suspend
		
		* Retry the command.
		
			case lcReturn = ccMSG_RETRY
				retry
		
		* Cancel execution.
		
			case lcReturn = ccMSG_CANCEL
				cancel
		
		* Go to the line of code following the error.
		
			otherwise
				return
		endcase
		
	ENDPROC

	PROCEDURE Init
		with This
		
		* Change the font to Segoe UI in Vista.
		
			if os(3) >= '6' and .FontName = 'Tahoma'
				.FontName = 'Segoe UI'
			endif os(3) >= '6' ...
		
		* Call Requery() if we're supposed to; otherwise, initialize aItems to a blank
		* string.
		
			if .lRequeryOnInit
				.Requery()
			else
				.aItems = ''
			endif .lRequeryOnInit
		
		* If we're supposed to bind our AnyChange event to our form's AnyChange method,
		* do so.
		
			if .lBindToFormAnyChange and vartype(Thisform) = 'O' and ;
				pemstatus(Thisform, 'AnyChange', 5)
				bindevent(This, 'InteractiveChange', Thisform, 'AnyChange')
			endif .lBindToFormAnyChange ...
		
		* If we're supposed to bind to the lChanged property of the form, do so.
		
			if .lNotifyOnFormChange and vartype(Thisform) = 'O' and ;
				pemstatus(Thisform, 'lChanged', 5)
				bindevent(Thisform, 'lChanged', This, 'OnFormChange', 1)
			endif .lNotifyOnFormChange ...
		endwith
		
	ENDPROC

	PROCEDURE InteractiveChange
		* Update the control source in case something binding to our AnyChange event
		* looks at it.
		
		if This.lUpdateControlSource
			This.UpdateControlSource()
		endif This.lUpdateControlSource
		
		* Call a common method for handling changes.
		
		raiseevent(This, 'AnyChange')
		
	ENDPROC

	PROCEDURE KeyPress
		* Prevent Ctrl-0 from inserting a null value.
		
		lparameters tnKeyCode, ;
			tnShiftAltCtrl
		if tnKeyCode = asc('0') and bittest(tnShiftAltCtrl, 1)
			nodefault
		endif tnKeyCode = asc('0') ...
		
		* Prevent backspace from leaving the control.
		
		if tnKeyCode = 127 and This.SelStart = 0 and This.SelLength = 0
		   nodefault
		endif tnKeyCode = 127 ...
		
	ENDPROC

	PROCEDURE lsaveanchor_assign
		lparameters tlSaveAnchor
		do case
			case tlSaveAnchor and This.nSavedAnchor > 0 and This.Anchor = 0
			case tlSaveAnchor
				This.nSavedAnchor = This.Anchor
				This.Anchor       = 0
			otherwise
				This.Anchor = This.nSavedAnchor
		endcase
		
	ENDPROC

	PROCEDURE onformchange		&& Fired when the lChanged property of the form changes if lNotifyOnFormChange is .T.
		* Refresh the control when something in the form changes.
		
		This.Refresh()
		
	ENDPROC

	PROCEDURE ProgrammaticChange
		* Call a common method for handling changes.
		
		raiseevent(This, 'AnyChange')
		
	ENDPROC

	PROCEDURE release		&& Releases the object
		* Release the object.
		
		release This
		
	ENDPROC

	PROCEDURE Requery
		* If RowSource is 0-None or 1-Value but an array specified in RowSource
		* contains values or oRowSourceCollection contains a collection, use AddItem
		* (in the case of 0-None) or set RowSource to a comma-delimited list of values
		* (in the case of 1-Value) from the array or the collection. This allows
		* disabled lines using a prompt of "\-".
		
		lparameters tlNoAction
		local lcRowSource, ;
			llArray, ;
			llColumn, ;
			lnRows, ;
			lnI, ;
			lcItem, ;
			luItem
		with This
			lcRowSource = .RowSource
			if empty(lcRowSource)
				lcRowSource = 'This.aItems'
			endif empty(lcRowSource)
			if not empty(lcRowSource)
				try
					llArray = type(lcRowSource, 1) = 'A'
				catch
				endtry
			endif not empty(lcRowSource)
			do case
		
		* If we're not supposed to do anything or we're not using 0-None or 1-Value, do
		* nothing.
		
				case tlNoAction or not inlist(.RowSourceType, 0, 1)
		
		* Handle items in an array referenced in RowSource. Note that we can't combine
		* the CASE and IF statements or we'll get an error.
		
				case not empty(lcRowSource) and llArray
					if type(lcRowSource + '[1]') = 'C' and ;
						(not empty(&lcRowSource.[1]) or alen(&lcRowSource., 1) > 1)
						if .RowSourceType <> 0
							.RowSource = ''
						endif .RowSourceType <> 0
						.Clear()
						llColumn = alen(&lcRowSource, 2) > 0
						lnRows   = alen(&lcRowSource, 1)
						for lnI = 1 to lnRows
							lcItem = iif(llColumn, &lcRowSource[lnI, 1], ;
								&lcRowSource[lnI])
							if .RowSourceType = 0
								.AddItem(lcItem)
							else
								.RowSource = .RowSource + iif(lnI = 1, '', ',') + ;
									lcItem
							endif .RowSourceType = 0
						next lnI
					endif type(lcRowSource + '[1]') = 'C' ...
		
		* Handle items in oRowSourceCollection.
		
				case vartype(.oRowSourceCollection) = 'O' and ;
					upper(.oRowSourceCollection.BaseClass) = 'COLLECTION' and ;
					.oRowSourceCollection.Count > 0
					if .RowSourceType <> 0
						.RowSource = ''
					endif .RowSourceType <> 0
					.Clear()
					for each luItem in .oRowSourceCollection foxobject
						if vartype(luItem) = 'O'
							lcItem = evaluate('luItem.' + .cCollectionObjectProperty)
						else
							lcItem = luItem
						endif vartype(luItem) = 'O'
						if .RowSourceType = 0
							.AddItem(lcItem)
						else
							.RowSource = .RowSource + ;
								iif(empty(.RowSource), '', ',') + lcItem
						endif .RowSourceType = 0
					next luItem
			endcase
		endwith
		
	ENDPROC

	PROCEDURE RightClick
		* Display a right-click menu.
		
		This.ShowMenu()
		
	ENDPROC

	PROCEDURE shortcutmenu		&& Populates the shortcut menu
		*==============================================================================
		* Method:			ShortcutMenu
		* Status:			Public
		* Purpose:			Populates the specified menu object
		* Author:			Doug Hennig
		* Copyright:		(c) 1996-2005 Stonefield Systems Group Inc.
		* Last revision:	08/24/2005
		* Parameters:		toMenu   - an object reference to a menu object
		*					tcObject - the name of the variable containing the object
		*						reference to this object
		* Returns:			.T.
		* Environment in:	oLocalizer may contain a reference to a localization object
		* Environment out:	additional items were added to the menu
		*==============================================================================
		
		lparameters toMenu, ;
			tcObject
		local lcCut, ;
			lcCopy, ;
			lcPaste, ;
			lcClear, ;
			lcSelect
		if This.Style = 0
			if type('oLocalizer.Name') = 'C'
				lcCut    = oLocalizer.GetLocalizedString('MENU_CUT')
				lcCopy   = oLocalizer.GetLocalizedString('MENU_COPY')
				lcPaste  = oLocalizer.GetLocalizedString('MENU_PASTE')
				lcClear  = oLocalizer.GetLocalizedString('MENU_CLEAR')
				lcSelect = oLocalizer.GetLocalizedString('MENU_SELECT_ALL')
			else
				lcCut    = 'Cu\<t'
				lcCopy   = '\<Copy'
				lcPaste  = '\<Paste'
				lcClear  = 'Cle\<ar'
				lcSelect = 'Se\<lect All'
			endif type('oLocalizer.Name') = 'C'
			with toMenu
				.AddMenuBar(lcCut,    "sys(1500, '_MED_CUT',   '_MEDIT')", , , , ;
					'not ' + tcObject + '.Enabled or ' + tcObject + '.ReadOnly', , ;
					'CutXPSmall.bmp', '_med_cut')
				.AddMenuBar(lcCopy,   "sys(1500, '_MED_COPY',  '_MEDIT')", , , , , , ;
					'CopyXPSmall.bmp', '_med_copy')
				.AddMenuBar(lcPaste,  "sys(1500, '_MED_PASTE', '_MEDIT')", , , , ;
					'not ' + tcObject + '.Enabled or ' + tcObject + '.ReadOnly', , ;
					'PasteXPSmall.bmp', '_med_paste')
				.AddMenuBar(lcClear,  "sys(1500, '_MED_CLEAR', '_MEDIT')", , , , ;
					'not ' + tcObject + '.Enabled or ' + tcObject + '.ReadOnly', , ;
					'_med_clear', '_med_clear')
				.AddMenuSeparator()
				.AddMenuBar(lcSelect, "sys(1500, '_MED_SLCTA', '_MEDIT')", , , , , , ;
					'_med_slcta', '_med_slcta')
			endwith
		endif This.Style = 0
		
	ENDPROC

	PROCEDURE showmenu		&& Display a shortcut menu
		*==============================================================================
		* Method:			ShowMenu
		* Status:			Public
		* Purpose:			Displays a shortcut menu
		* Author:			Doug Hennig
		* Copyright:		(c) 1996-2004 Stonefield Systems Group Inc.
		* Last revision:	07/20/2004
		* Parameters:		none
		* Returns:			.T.
		* Environment in:	SFMenu.VCX can be found
		* Environment out:	a menu may have been displayed
		*==============================================================================
		
		local lcLibrary
		private loObject, ;
			loHook, ;
			loForm
		with This
		
		* Define reference to objects we might have menu items from in case the action
		* for a bar is to call a method of an object, which can't be done using "This.
		* Method" since "This" isn't applicable in a menu.
		
			loObject = This
			loHook   = .oHook
			loForm   = Thisform
		
		* Define the menu if it hasn't already been defined.
		
			lcLibrary = 'SFMenu.vcx'
			if vartype(.oMenu) <> 'O' and file(lcLibrary)
				.oMenu = newobject('SFShortcutMenu', lcLibrary)
			endif vartype(.oMenu) <> 'O' ...
			if vartype(.oMenu) = 'O'
		
		* If there aren't any bars in the menu, have the ShortcutMenu method populate
		* it.
		
				if .oMenu.nBarCount = 0
					.ShortcutMenu(.oMenu, 'loObject')
		
		* Use the hook object (if there is one) to do any further population of the
		* menu.
		
					if vartype(loHook) = 'O' and pemstatus(loHook, 'ShortcutMenu', 5)
						loHook.ShortcutMenu(.oMenu, 'loHook')
					endif vartype(loHook) = 'O' ...
		
		* If desired, use the form's shortcut menu as well.
		
					if .lUseFormShortcutMenu and type('Thisform.Name') = 'C' and ;
						pemstatus(loForm, 'ShortcutMenu', 5)
						loForm.ShortcutMenu(.oMenu, 'loForm')
					endif .lUseFormShortcutMenu ...
				endif .oMenu.nBarCount = 0
		
		* Activate the menu if necessary.
		
				if .oMenu.nBarCount > 0
					.oMenu.ShowMenu()
				endif .oMenu.nBarCount > 0
			endif vartype(.oMenu) = 'O' ...
		endwith
		
	ENDPROC

	PROCEDURE updatecontrolsource		&& Updates the control source
		*==============================================================================
		* Method:			UpdateControlSource
		* Status:			Public
		* Purpose:			Updates the ControlSource with the new value
		* Author:			Doug Hennig
		* Copyright:		(c) 2001-2006 Stonefield Systems Group Inc.
		* Last revision:	02/27/2006
		* Parameters:		none
		* Returns:			.T.
		* Environment in:	none
		* Environment out:	the ControlSource may have been updated
		*==============================================================================
		
		local lnPos, ;
			lcAlias, ;
			lcField
		with This
			lnPos = at('.', .ControlSource)
			if lnPos > 0 and not .Value == evaluate(.ControlSource)
				lcAlias = left(.ControlSource, lnPos - 1)
				lcField = substr(.ControlSource, lnPos + 1)
				if used(lcAlias)
					replace (lcField) with .Value in (lcAlias)
				else
					store .Value to (.ControlSource)
				endif used(lcAlias)
			endif lnPos > 0 ...
		endwith
		
	ENDPROC

	PROCEDURE Valid
		*==============================================================================
		* Method:			Valid
		* Status:			Public
		* Purpose:			Validate the Value
		* Author:			Doug Hennig
		* Copyright:		(c) 1996-2002 Stonefield Systems Group Inc.
		* Last revision:	08/20/2002
		* Parameters:		none
		* Returns:			.T. if the validation succeeded or we're not doing the
		*						validation
		* Environment in:	none
		* Environment out:	none
		*==============================================================================
		
		* If the Valid method is fired because the user clicked on a button with the
		* Cancel property set to .T. or if the button has an lCancel property (which
		* is part of the SFCommandButton base class) and it's .T., or if we're closing
		* the form, don't bother doing the rest of the validation.
		
		local loObject
		loObject = sys(1270)
		if (type('loObject.Cancel') = 'L' and loObject.Cancel) or ;
			(type('loObject.lCancel') = 'L' and loObject.lCancel) or ;
			(This.lSkipValidOnFormClose and ;
			type('Thisform.ReleaseType') = 'N' and Thisform.ReleaseType > 0)
			return .T.
		endif (type('loObject.lCancel') = 'L' ...
		
		* If the user tries to leave this control but a field validation rule failed,
		* we'll prevent them from doing so.
		
		if type('Thisform.lFieldRuleFailed') = 'L' and Thisform.lFieldRuleFailed
			Thisform.lFieldRuleFailed = .F.
			return 0
		endif type('Thisform.lFieldRuleFailed') = 'L' ...
		
		* Do the custom validation (this allows the developer to put custom validation
		* code into the Validation method rather than having to use code like the
		* following in the Valid method:
		*
		* dodefault()
		* custom code here
		* nodefault
		
		return This.Validation()
		
	ENDPROC

	PROCEDURE validation		&& An abstract method for custom validation code
		* Abstract method
		
	ENDPROC

ENDDEFINE

DEFINE CLASS sfform AS form 		&& The base class for Form objects
 	*< CLASSDATA: Baseclass="form" Timestamp="" Scale="Pixels" Uniqueid="" />

	#INCLUDE "sfctrls.h"
	*<DefinedPropArrayMethod>
		*m: about		&& Provides documentation for the class
		*m: activateobjectpage		&& Ensures any page the specified object is sitting on is the active page
		*m: afterrefresh		&& An abstract method of code to execute after a form is refreshed
		*m: anychange		&& This method can be called when anything in the form changes
		*m: beforerefresh		&& An abstract method of code to execute before a form is refreshed
		*m: calledfromthisclass		&& Returns .T. if a method was called from this class
		*m: canreleaseform		&& Returns .T. if we can release the form
		*m: cleanup		&& Cleans up member references when the object is released or destroyed
		*m: findactivecontrol		&& Returns a reference to the active control (which may be in a container)
		*m: finderrorhandler		&& Find the first parent for a specified object that has code in its Error method
		*m: handleerror		&& Handles an error
		*m: refreshform		&& Refreshes the form
		*m: releasemembers		&& Abstract method to nuke member references
		*m: resetchangedstate		&& Resets the changed state
		*m: reseterror		&& Resets lErrorOccurred and aErrorInfo
		*m: seterror		&& Sets lErrorOccurred and aErrorInfo to information about the most recent error
		*m: setfocustofirstobject		&& Sets focus to the first object in the specified container
		*m: setfocustolastobject		&& Sets focus to the last object in the specified container
		*m: shortcutmenu		&& Populates the shortcut menu
		*m: showmenu		&& Display a shortcut menu
		*m: updatechanges		&& Adjusts the oChanges collection when a change is made
		*p: builder		&& Tells BUILDER.APP the name of a specific builder to use for this class (specified as Library,Class)
		*p: lchanged		&& .T. if something in the form has changed
		*p: lerrorinfosaved		&& .T. if the error information has been saved in aErrorInfo
		*p: lerroroccurred		&& .T. if an error occurred (set in SetError)
		*p: lrelease		&& .T. as the object is being released
		*p: lsetfocustofirstobject		&& .T. to set focus to the first object in Show
		*p: nborderstyle		&& The value to put into the BorderStyle property at runtime
		*p: ninitialheight		&& The initial height of the form
		*p: ninitialwidth		&& The initial width of the form
		*p: nlasterror		&& The index to the last error that occurred in aErrorInfo
		*p: ochanges		&& A reference to a collection of changes
		*p: oerror		&& A reference to an error handling object
		*p: oexception		&& A reference to an Exception object
		*p: ohook		&& A reference to a hooked object
		*p: omenu		&& An object reference to a shortcut menu object
		*p: omessage		&& A reference to an SFMessageMgr object
		*p: outility		&& A reference to an SFUtility object
		*a: aerrorinfo[1,0]		&& An array of error information
		*p: _memberdata		&& XML Metadata for customizable properties
	*</DefinedPropArrayMethod>

	PROTECTED lerrorinfosaved
	AllowOutput = .F.
	AutoCenter = .T.
	builder = 		&& Tells BUILDER.APP the name of a specific builder to use for this class (specified as Library,Class)
	Caption = "Form"
	Desktop = .T.
	DoCreate = .T.
	FontName = "Tahoma"
	KeyPreview = .T.
	lchanged = .F.		&& .T. if something in the form has changed
	lerrorinfosaved = .F.		&& .T. if the error information has been saved in aErrorInfo
	lerroroccurred = .F.		&& .T. if an error occurred (set in SetError)
	lrelease = .F.		&& .T. as the object is being released
	lsetfocustofirstobject = .T.		&& .T. to set focus to the first object in Show
	Name = "sfform"
	nborderstyle = 2		&& The value to put into the BorderStyle property at runtime
	ninitialheight = 0		&& The initial height of the form
	ninitialwidth = 0		&& The initial width of the form
	nlasterror = 0		&& The index to the last error that occurred in aErrorInfo
	ochanges = .NULL.		&& A reference to a collection of changes
	oerror = .NULL.		&& A reference to an error handling object
	oexception = .NULL.		&& A reference to an Exception object
	ohook = .NULL.		&& A reference to a hooked object
	omenu = .NULL.		&& An object reference to a shortcut menu object
	omessage = .NULL.		&& A reference to an SFMessageMgr object
	outility = .NULL.		&& A reference to an SFUtility object
	ShowTips = .T.
	ShowWindow = 1
	_memberdata = <VFPData>
		<memberdata name="about" type="method" display="About"/>
		<memberdata name="activateobjectpage" type="method" display="ActivateObjectPage"/>
		<memberdata name="aerrorinfo" type="property" display="aErrorInfo"/>
		<memberdata name="afterrefresh" type="method" display="AfterRefresh" favorites="True"/>
		<memberdata name="beforerefresh" type="method" display="BeforeRefresh" favorites="True"/>
		<memberdata name="builder" type="property" display="Builder"/>
		<memberdata name="calledfromthisclass" type="method" display="CalledFromThisClass"/>
		<memberdata name="cleanup" type="method" display="Cleanup"/>
		<memberdata name="findactivecontrol" type="method" display="FindActiveControl"/>
		<memberdata name="finderrorhandler" type="method" display="FindErrorHandler"/>
		<memberdata name="handleerror" type="method" display="HandleError"/>
		<memberdata name="lerrorinfosaved" type="property" display="lErrorInfoSaved"/>
		<memberdata name="lerroroccurred" type="property" display="lErrorOccurred"/>
		<memberdata name="lrelease" type="property" display="lRelease"/>
		<memberdata name="nborderstyle" type="property" display="nBorderStyle" favorites="True"/>
		<memberdata name="nlasterror" type="property" display="nLastError"/>
		<memberdata name="oerror" type="property" display="oError"/>
		<memberdata name="oexception" type="property" display="oException"/>
		<memberdata name="ohook" type="property" display="oHook"/>
		<memberdata name="omenu" type="property" display="oMenu"/>
		<memberdata name="omessage" type="property" display="oMessage"/>
		<memberdata name="outility" type="property" display="oUtility"/>
		<memberdata name="refreshform" type="method" display="RefreshForm"/>
		<memberdata name="releasemembers" type="method" display="ReleaseMembers" favorites="True"/>
		<memberdata name="reseterror" type="method" display="ResetError"/>
		<memberdata name="seterror" type="method" display="SetError"/>
		<memberdata name="setfocustofirstobject" type="method" display="SetFocusToFirstObject"/>
		<memberdata name="shortcutmenu" type="method" display="ShortcutMenu" favorites="True"/>
		<memberdata name="showmenu" type="method" display="ShowMenu"/>
		<memberdata name="ninitialwidth" type="property" display="nInitialWidth"/>
		<memberdata name="ninitialheight" type="property" display="nInitialHeight"/>
		<memberdata name="lchanged" type="property" display="lChanged"/>
		<memberdata name="ochanges" type="property" display="oChanges"/>
		<memberdata name="anychange" type="method" display="AnyChange"/>
		<memberdata name="resetchangedstate" type="method" display="ResetChangedState"/>
		<memberdata name="updatechanges" type="method" display="UpdateChanges"/>
		<memberdata name="setfocustolastobject" type="method" display="SetFocusToLastObject"/>
		<memberdata name="lsetfocustofirstobject" type="property" display="lSetFocusToFirstObject"/>
		<memberdata name="canreleaseform" type="method" display="CanReleaseForm"/>
		</VFPData>		&& XML Metadata for customizable properties
	
	PROCEDURE about		&& Provides documentation for the class
		*==============================================================================
		* Class:						SFForm
		* Based On:						Form
		* Purpose:						Base class for all Form objects
		* Author:						Doug Hennig
		* Copyright:					(c) 1996-2008 Stonefield Systems Group Inc.
		* Last revision:				05/22/2008
		* Include file:					SFCTRLS.H
		*
		* Changes in "Based On" class properties:
		*	AllowOutput:				.F.
		*	AutoCenter:					.T.
		*	Desktop:					.T. so windows use Aero Glass in Vista
		*	FontName:					Tahoma
		*	KeyPress:					.T.
		*	ShowTips:					.T.
		*	ShowWindow:					1 - In Top-level Form
		*
		* Changes in "Based On" class methods:
		*	Destroy:					hides the form so it disappears faster, and
		*								clean up other things
		*	Error:						calls This.SetError and This.HandleError
		*	GotFocus:					calls This.RefreshForm
		*	Init:						puts the value of the custom nBorderStyle
		*								property into the BorderStyle property.
		*								Instantiate SFUtility and SFMessageMgr objects
		*								if necessary. Instantiate a collection into
		*								This.oChanges. Change FontName to Segoe UI in
		*								Vista
		*	KeyPress:					call This.ShowMenu if Shift-F10 is pressed
		*	Load:						set up the environment the way we want
		*	QueryUnload:				call CanReleaseForm to see if the form can be
		*								released
		*	Release:					call This.Cleanup
		*	RightClick:					call This.ShowMenu
		*	Show:						call This.SetFocusToFirstObject so focus goes
		*								to the first object in the form
		*
		* Custom public properties added:
		*	aErrorInfo:					an array of error information
		*	Builder:					tells BUILDER.APP the name of a specific
		*								builder to use for this class (specified as
		*								Library,Class)
		*	lChanged:					.T. if something in the form has changed
		*	lErrorOccurred:				.T. if an error occurred (set in SetError)
		*	lRelease:					.T. as the object is being released
		*	lSetFocusToFirstObject   	.T. to set focus to the first object in Show
		*	nBorderStyle:				the value (default = 2, Fixed dialog) to put
		*								into the BorderStyle property at runtime
		*	nInitialHeight:				the initial height of the form
		*	nInitialWidth:				the initial width of the form
		*	nLastError:					the index to the last error that occurred in
		*								aErrorInfo
		*	oChanges:					a reference to a collection of changes
		*	oError:						a reference to an error handling object
		*	oHook:						a reference to a hooked object
		*	oMenu:						a reference to an SFShortcutMenu object
		*	oMessage:					a reference to an SFMessageMgr object
		*	oUtility:					a reference to an SFUtility object
		*
		* Custom protected properties added:
		*	lErrorInfoSaved:			.T. if the error information has been saved in
		*								aErrorInfo
		*
		* Custom public methods added:
		*	About:						provides documentation for the class
		*	ActivateObjectPage:			ensures any page the specified object is
		*								sitting on is the active page
		*	AfterRefresh:				an abstract method of code to execute after a
		*								form is refreshed
		*	AnyChange:					this method can be called when anything in the
		*								form changes
		*	BeforeRefresh:				an abstract method of code to execute before a
		*								form is refreshed
		*	CanReleaseForm:				returns .T. if we can release the form
		*	FindActiveControl:			returns a reference to the active control
		*								(which may be in a container)
		*	FindErrorHandler:			called by the Error method of contained objects
		*								to find a parent that has code in its Error
		*								method
		*	HandleError:				handles an error
		*	RefreshForm:				refreshes the form
		*	ReleaseMembers:				abstract method to nuke member references
		*	ResetChangedState:			resets the changed state
		*	ResetError:					resets lErrorOccurred, aErrorInfo, and
		*								nLastError
		*	SetError:					sets lErrorOccurred and aErrorInfo to
		*								information about the most recent error
		*	SetFocusToFirstObject:		sets focus to the first object in the specified
		*								container
		*	SetFocusToLastObject:		sets focus to the last object in the specified
		*								container
		*	ShortcutMenu:				populates the shortcut menu
		*	ShowMenu:					display a shortcut menu
		*	UpdateChanges:				adjusts the oChanges collection when a change
		*								is made
		*
		* Custom protected methods added:
		*	CalledFromThisClass:		returns .T. if a method was called from this
		*								class
		*	Cleanup:					cleans up member references when the object is
		*								released or destroyed
		*==============================================================================
		
	ENDPROC

	PROCEDURE activateobjectpage		&& Ensures any page the specified object is sitting on is the active page
		*==============================================================================
		* Method:			ActivateObjectPage
		* Status:			Public
		* Purpose:			Ensures any page the specified object is sitting on is the
		*						active page
		* Author:			Doug Hennig
		* Copyright:		(c) 1996 Stonefield Systems Group Inc.
		* Last revision:	12/04/98
		* Parameters:		toObject - an object reference to the desired object
		* Returns:			.T.
		* Environment in:	none
		* Environment out:	any page (even if the object is in a container on a
		*						pageframe on a pageframe) the specified object is
		*						sitting on is the active page
		*==============================================================================
		
		lparameters toObject
		local loParent, ;
			lnPage
		
		* Ensure the passed parameter is a contained object.
		
		if vartype(toObject) <> 'O' or type('toObject.Parent') <> 'O'
			error 'Parameter is not a contained object.'
			return .F.
		endif vartype(toObject) <> 'O' ...
		loParent = toObject.Parent
		lnPage   = 0
		
		* Drill up until we hit the form, activating pages as necessary.
		
		do while upper(loParent.BaseClass) <> 'FORM'
			do case
				case upper(loParent.BaseClass) == 'PAGE'
					lnPage = loParent.PageOrder
				case upper(loParent.BaseClass) == 'PAGEFRAME' and ;
					loParent.ActivePage <> lnPage
					loParent.ActivePage = lnPage
			endcase
			loParent = loParent.Parent
		enddo while upper(loParent.BaseClass) <> 'FORM'
		
	ENDPROC

	PROCEDURE afterrefresh		&& An abstract method of code to execute after a form is refreshed
		* Abstract method
		
	ENDPROC

	PROCEDURE anychange		&& This method can be called when anything in the form changes
		* Flag that something changed.
		
		This.lChanged = .T.
		
	ENDPROC

	PROCEDURE beforerefresh		&& An abstract method of code to execute before a form is refreshed
		* Abstract method
		
	ENDPROC

	PROTECTED PROCEDURE calledfromthisclass		&& Returns .T. if a method was called from this class
		*==============================================================================
		* Method:			CalledFromThisClass
		* Status:			Protected
		* Purpose:			Determines if the method that called this method was called
		*						from a method of this class or an ancestor
		* Author:			Doug Hennig
		* Copyright:		(c) 1998, 2000 Stonefield Systems Group Inc.
		* Last Revision:	08/22/2000
		* Parameters:		none
		* Returns:			.T. if the method that called this method was called from a
		*						method of this class or an ancestor
		* Environment in:	none
		* Environment out:	none
		* Notes:			The reason we want to know if the method that called this
		*						method was called from a method of this class or not is
		*						to permit "read-only" properties to be changed only by
		*						methods of this class. This would typically be called
		*						from an Assign method, such as:
		*
		*					lparameters tuNewValue
		*					if This.CalledFromThisClass()
		*						This.<property> = tuNewValue
		*					else
		*						error 1743, '<property>'   && property is read-only
		*					endif This.CalledFromThisClass()
		*==============================================================================
		
		local lnLevel, ;
			lcProgram, ;
			lcObject, ;
			laClasses[1], ;
			lnClasses, ;
			lnI, ;
			llReturn
		
		* Get the name of the program that called us, and get the object name from it.
		
		lnLevel   = program(-1)
		lcProgram = iif(lnLevel > 2, upper(program(lnLevel - 2)), '')
		lcObject  = left(lcProgram, rat('.', lcProgram) - 1)
		
		* Check our class hierarchy to see if we were called from ourselves or an
		* ancester method.
		
		lnClasses = aclass(laClasses, This)
		for lnI = 1 to lnClasses
			if lcObject == upper(laClasses[lnI])
				llReturn = .T.
				exit
			endif lcObject == upper(laClasses[lnI])
		next lnI
		return llReturn
		
	ENDPROC

	PROCEDURE canreleaseform		&& Returns .T. if we can release the form
		* Abstract method
		
	ENDPROC

	PROTECTED PROCEDURE cleanup		&& Cleans up member references when the object is released or destroyed
		*==============================================================================
		* Method:			Cleanup
		* Status:			Protected
		* Purpose:			Nuke member objects
		* Author:			Doug Hennig
		* Copyright:		(c) 1998 Stonefield Systems Group Inc.
		* Last Revision:	03/04/2000
		* Parameters:		none
		* Returns:			.T. if everything succeeded
		* Environment in:	This.lRelease is .T. if we're already in the process of
		*						releasing
		* Environment out:	This.lRelease is .T.
		*					This.oHook, oError, and oMenu are .NULL.
		*					This.ReleaseMembers() was called
		* Notes:			This methods avoids use of "with This" to prevent potential
		*						problems with dangling object references
		*==============================================================================
		
		if This.lRelease
			return .F.
		endif This.lRelease
		This.lRelease = .T.
		This.ReleaseMembers()
		This.oHook    = .NULL.
		This.oError   = .NULL.
		This.oMenu    = .NULL.
		This.oMessage = .NULL.
		This.oUtility = .NULL.
		
	ENDPROC

	PROCEDURE Destroy
		*==============================================================================
		* Method:			Destroy
		* Status:			Public
		* Purpose:			Called when the object is being destroyed
		* Author:			Doug Hennig
		* Copyright:		(c) 1996 Stonefield Systems Group Inc.
		* Last revision:	12/11/98
		* Parameters:		none
		* Returns:			.T.
		* Environment in:	none
		* Environment out:	the form and any member objects are destroyed
		*					if oApp exists, its CloseForm() method is called so it
		*						knows we're no longer around
		*==============================================================================
		
		with This
		
		* Hide the form so it appears to go away faster.
		
			.Hide()
		
		* Cleanup as the object is destroyed.
		
			.Cleanup()
		
		* Tell oApp we're closing.
		
			if type('oApp.Name') = 'C' and pemstatus(oApp, 'CloseForm', 5)
				oApp.CloseForm(.Name)
			endif type('oApp.Name') = 'C' ...
		endwith
		
	ENDPROC

	PROCEDURE Error
		*==============================================================================
		* Method:			Error
		* Status:			Public
		* Purpose:			Called when an error occurs in this object or a member
		*						object
		* Author:			Doug Hennig
		* Copyright:		(c) 1996-2003 Stonefield Systems Group Inc.
		* Last revision:	02/16/2003
		* Parameters:		tnError  - the error number
		*					tcMethod - the method that caused the error
		*					tnLine   - the line number where the error occurred
		* Returns:			varies
		* Environment in:	an error has occurred
		*					This.oException may contain an Exception object
		* Environment out:	control may be returned to the object/method that caused
		*						the error (either as RETURN or RETRY) or to the routine
		*						containing the READ EVENTS for the application
		*					the form may be released
		*					see This.SetError() and This.HandleError() for other
		*						environmental changes
		*==============================================================================
		
		lparameters tnError, ;
			tcMethod, ;
			tnLine
		local lcMethod, ;
			lnLine, ;
			lcSource, ;
			laError[1], ;
			lcReturn, ;
			lcReturnToOnCancel, ;
			lnPos, ;
			lcObject
		with This
		
		* Use AERROR() to get information about the error. If we have an Exception
		* object in oException, get information about the error from it.
		
			lcMethod = tcMethod
			lnLine   = tnLine
			lcSource = message(1)
			aerror(laError)
			if vartype(.oException) = 'O'
				lcMethod = .oException.Procedure
				lnLine   = .oException.LineNo
				lcSource = .oException.LineContents
				laError[cnAERR_NUMBER]  = .oException.ErrorNo
				laError[cnAERR_MESSAGE] = .oException.Message
				laError[cnAERR_OBJECT]  = .oException.Details
				.oException = .NULL.
			endif vartype(.oException) = 'O'
		
		* Use SetError() and HandleError() to gather error information and handle it.
		
			.SetError(lcMethod, lnLine, lcSource, @laError)
			.lErrorInfoSaved = .F.
			lcReturn = .HandleError()
		
		* Figure out where to go if the user chooses "Cancel".
		
			do case
				case left(sys(16, 1), at('.', sys(16, 1)) - 1) = 'PROCEDURE ' + ;
					upper(.Name)
					lcReturnToOnCancel = ''
				case type('.oError.cReturnToOnCancel') = 'C'
					lcReturnToOnCancel = .oError.cReturnToOnCancel
				case type('oError.cReturnToOnCancel') = 'C'
					lcReturnToOnCancel = oError.cReturnToOnCancel
				otherwise
					lcReturnToOnCancel = 'MASTER'
			endcase
		endwith
		
		* Handle the return value, depending on whether the error was "ours" or came
		* from a member.
		
		lnPos    = at('.', lcMethod)
		lcObject = iif(lnPos = 0, '', upper(left(lcMethod, lnPos - 1)))
		do case
		
		* We're supposed to close the form, so do so and return to the master program
		* (we'll just cancel if we *are* the master program).
		
			case lcReturn = ccMSG_CLOSEFORM
				This.Release()
				if empty(lcReturnToOnCancel)
					cancel
				else
					return to &lcReturnToOnCancel
				endif empty(lcReturnToOnCancel)
		
		* This wasn't our error, so return the error resolution string.
		
			case lnPos > 0 and not (lcObject == upper(This.Name) or ;
				'DATAENVIRONMENT' $ upper(lcMethod))
				return lcReturn
		
		* Display the debugger.
		
			case lcReturn = ccMSG_DEBUG
				debug
				if wexist('Visual FoxPro Debugger')
					keyboard '{SHIFT+F7}' plain
				endif wexist('Visual FoxPro Debugger')
				suspend
		
		* Retry.
		
			case lcReturn = ccMSG_RETRY
				retry
		
		* If Cancel was chosen but the master program is this form, we'll just cancel.
		
			case lcReturn = ccMSG_CANCEL and empty(lcReturnToOnCancel)
				cancel
		
		* Cancel was chosen, so return to the master program.
		
			case lcReturn = ccMSG_CANCEL
				return to &lcReturnToOnCancel
		
		* Return to the routine in error to continue on.
		
			otherwise
				return
		endcase
		
	ENDPROC

	PROCEDURE findactivecontrol		&& Returns a reference to the active control (which may be in a container)
		*==============================================================================
		* Method:			FindActiveControl
		* Status:			Public
		* Purpose:			Returns a reference to the active control (which may be in
		*						a container)
		* Author:			Doug Hennig
		* Copyright:		(c) 2002-2008 Stonefield Systems Group Inc.
		* Last revision:	05/22/2008
		* Parameters:		toContainer - the container to check (optional: if it isn't
		*						passed, the form is used)
		* Returns:			a reference to the active control if there is one or .NULL.
		*						if not
		* Environment in:	none
		* Environment out:	none
		*==============================================================================
		
		lparameters toContainer
		local loContainer, ;
			loObject, ;
			loControl
		
		* If the container wasn't specified, let's use the form.
		
		loContainer = iif(vartype(toContainer) = 'O', toContainer, This)
		
		* If we've found the active control, get a reference to it.
		
		loObject = .NULL.
		if type('loContainer.ActiveControl.Name') = 'C'
			loObject = loContainer.ActiveControl
		
		* We didn't find the active control, so check every member container by calling
		* ourselves recursively.
		
		else
			for each loControl in loContainer.Objects foxobject
				if pemstatus(loControl, 'ActiveControl', 5) or ;
					pemstatus(loControl, 'Objects', 5)
					This.FindActiveControl(loControl)
				endif pemstatus(loControl, 'ActiveControl', 5) ...
			next loControl
		endif type('loContainer.ActiveControl.Name') = 'C'
		return loObject
		
	ENDPROC

	PROCEDURE finderrorhandler		&& Find the first parent for a specified object that has code in its Error method
		*==============================================================================
		* Method:			FindErrorHandler
		* Status:			Public
		* Purpose:			Travel up the containership hierarchy until we find a
		*						parent for the specified object that has code in its
		*						Error method
		* Author:			Doug Hennig
		* Copyright:		(c) 1996-2002 Stonefield Systems Group Inc.
		* Last revision:	04/02/2002
		* Parameters:		toObject - an object reference to the desired object
		* Returns:			an object reference to the first parent of the specified
		*						object that has code in its Error method if one could
		*						be found, or .NULL. if not
		* Environment in:	none
		* Environment out:	none
		* Note:				This method prevents a problem with controls sitting on
		*						base class Page or Column objects -- no error trapping
		*						gets done if no custom code is directly entered into
		*						these objects
		*
		*					This mechanism only works in the VFP development
		*						environment or in an APP/EXE with debug info turned on
		*==============================================================================
		
		lparameters toObject
		local loParent
		loParent = toObject.Parent
		do while vartype(loParent) = 'O'
			do case
				case pemstatus(loParent, 'Error', 0)
					exit
				case type('loParent.Parent') = 'O'
					loParent = loParent.Parent
				otherwise
					loParent = .NULL.
			endcase
		enddo while vartype('loParent') = 'O'
		
		* If we couldn't find a valid parent object (likely because we're running in an
		* EXE with debug info turned off, let's return ourselves.
		
		if isnull(loParent)
			loParent = This
		endif isnull(loParent)
		return loParent
		
	ENDPROC

	PROCEDURE GotFocus
		*==============================================================================
		* Method:			GotFocus
		* Status:			Public
		* Purpose:			Called when the window receives focus
		* Author:			Doug Hennig
		* Copyright:		(c) 1996 Stonefield Systems Group Inc.
		* Last revision:	03/05/99
		* Parameters:		none
		* Returns:			.T.
		* Environment in:	none
		* Environment out:	This.RefreshForm() is called to ensure any BeforeRefresh
		*						and AfterRefresh behaviors are triggered
		*==============================================================================
		
		This.RefreshForm()
		
	ENDPROC

	PROCEDURE handleerror		&& Handles an error
		*==============================================================================
		* Method:			HandleError
		* Status:			Public
		* Purpose:			Handles an error
		* Author:			Doug Hennig
		* Copyright:		(c) 1996-2005 Stonefield Systems Group Inc.
		* Last revision:	12/14/2005
		* Parameters:		none
		* Returns:			a string indicating the error resolution; see SFERRORS.H
		*						for the possible values
		* Environment in:	This.nLastError points to the row in This.aErrorInfo that
		*						has information about the current error
		* Environment out:	an error message may have been displayed, or some other
		*						error resolution may have been taken
		* Notes:			if This.oError contains an error handling object, its
		*						ErrorHandler method is called
		*					if a global oError contains an error handling object, its
		*						ErrorHandler method is called
		*					if an ON ERROR routine is in effect, it's called
		*					if none of these is true, a generic error message is
		*						displayed
		*==============================================================================
		
		local lnError, ;
			lcMethod, ;
			lnLine, ;
			lcErrorMessage, ;
			lcErrorInfo, ;
			lcSource, ;
			loError, ;
			lcReturn, ;
			lcError, ;
			lcMessage, ;
			lnChoice
		with This
			lnError        = .aErrorInfo[.nLastError, cnAERR_NUMBER]
			lcMethod       = .Name + '.' + .aErrorInfo[.nLastError, cnAERR_METHOD]
			lnLine         = .aErrorInfo[.nLastError, cnAERR_LINE]
			lcErrorMessage = .aErrorInfo[.nLastError, cnAERR_MESSAGE]
			lcErrorInfo    = .aErrorInfo[.nLastError, cnAERR_OBJECT]
			lcSource       = .aErrorInfo[.nLastError, cnAERR_SOURCE]
		
		* Get a reference to our error handling object if there is one. It could either
		* be a member of the form or a global object.
		
			do case
				case vartype(.oError) = 'O'
					loError = .oError
				case type('oError.Name') = 'C'
					loError = oError
				otherwise
					loError = .NULL.
			endcase
			do case
		
		* If the error is "cannot set focus during valid" or "DataEnvironment already
		* unloaded", we'll let it go.
		
				case lnError = cnERR_CANT_SET_FOCUS or lnError = cnERR_DE_UNLOADED
					lcReturn = ccMSG_CONTINUE
		
		* We have an error handling object, so call its ErrorHandler() method.
		
				case not isnull(loError)
					lcReturn = loError.ErrorHandler(lnError, lcMethod, lnLine)
		
		* A global error handler is in effect, so let's pass the error on to it.
		* Replace certain parameters passed to the error handler (the name of the
		* program, the error number, the line number, the message, and SYS(2018)) with
		* the appropriate values.
		
				case not empty(on('ERROR'))
					lcError = upper(on('ERROR'))
					lcError = strtran(lcError, 'SYS(16)',   '"' + lcMethod + '"')
					lcError = strtran(lcError, 'PROGRAM()', '"' + lcMethod + '"')
					lcError = strtran(lcError, ',ERROR()',  ',lnError')
					lcError = strtran(lcError, ' ERROR()',  ' lnError')
					lcError = strtran(lcError, 'LINENO()',  'lnLine')
					lcError = strtran(lcError, 'MESSAGE()', 'lcErrorMessage')
					lcError = strtran(lcError, 'SYS(2018)', 'lcErrorInfo')
		
		* If the error handler is called with DO, macro expand it and assume the return
		* value is "CONTINUE". If the error handler is called as a function (such as an
		* object method), call it and grab the return value if there is one.
		
					if left(lcError, 3) = 'DO ' or '=' $ lcError
						&lcError
						lcReturn = ccMSG_CONTINUE
					else
						lcReturn = &lcError
					endif left(lcError, 3) = 'DO ' ...
		
		* We don't have an error handling object, so display a dialog box.
		
				otherwise
					lcMessage = ccMSG_ERROR_NUM + ' ' + transform(lnError) + ccCR + ;
						ccMSG_MESSAGE + ' ' + lcErrorMessage + ccCR + ;
						iif(empty(lcSource), '', ccMSG_CODE + ' ' + lcSource + ;
						ccCR) + iif(lnLine = 0, '', ccMSG_LINE_NUM + ' ' + ;
						transform(lnLine) + ccCR) + ccMSG_METHOD + ' ' + lcMethod
					if version(2) = 0
						lnChoice = messagebox(lcMessage + ccCR + ccCR + ;
							'Choose OK to continue or Cancel to cancel execution', ;
							MB_OKCANCEL + MB_ICONSTOP, _VFP.Caption)
					else
						lnChoice = messagebox(lcMessage + ccCR + ccCR + ;
							'Choose Yes to display the debugger, No to continue ' + ;
							'without the debugger, or Cancel to cancel execution', ;
							MB_YESNOCANCEL + MB_ICONSTOP, _VFP.Caption)
					endif version(2) = 0
					lcReturn = ccMSG_CONTINUE
					do case
						case lnChoice = IDYES
							lcReturn = ccMSG_DEBUG
						case lnChoice = IDCANCEL
							lcReturn = ccMSG_CANCEL
					endcase
			endcase
		endwith
		lcReturn = iif(vartype(lcReturn) <> 'C' or empty(lcReturn) or ;
			not upper(lcReturn) $ upper(ccMSG_CONTINUE + ccMSG_RETRY + ccMSG_CANCEL + ;
			ccMSG_CLOSEFORM + ccMSG_DEBUG), ccMSG_CONTINUE, lcReturn)
		return lcReturn
		
	ENDPROC

	PROCEDURE Init
		*==============================================================================
		* Method:			Init
		* Status:			Public
		* Purpose:			Initializes the object
		* Author:			Doug Hennig
		* Copyright:		(c) 1996-2008 Stonefield Systems Group Inc.
		* Last revision:	02/07/2008
		* Parameters:		none
		* Returns:			.T. if everything succeeded, or .F. if an error occurred
		* Environment in:	none
		* Environment out:	if This.Icon is empty, it's set to _screen.Icon
		*					This.BorderStyle is set to This.nBorderStyle
		*					This.oUtility may be set to an existing or may contain a
		*						new SFUtility object
		*					This.oMessage may be set to an existing or may contain a
		*						new SFMessage object
		*					This.oChanges contains a collection
		*==============================================================================
		
		local lcLibrary
		with This
		
		* Change the font to Segoe UI in Vista.
		
			if os(3) >= '6' and .FontName = 'Tahoma'
				.FontName = 'Segoe UI'
			endif os(3) >= '6' ...
		
		* If the Icon property is blank, grab the screen's or active form's.
		
			do case
				case not empty(.Icon)
				case _screen.Visible
					.Icon = _screen.Icon
				case type('_screen.ActiveForm.Name') = 'C'
					.Icon = _screen.ActiveForm.Icon
			endcase
		
		* If the icon is still empty, _screen may have been invisible, so we'll use its
		* icon anyway.
		
			if empty(.Icon)
				.Icon = _screen.Icon
			endif empty(.Icon)
		
		* Set the BorderStyle property as desired.
		
			.BorderStyle = .nBorderStyle
		
		* Get or create references to SFUtility and SFMessageMgr objects.
		
			lcLibrary = 'SFUtility.vcx'
			do case
				case type('.oUtility.Name') = 'C'
				case type('oUtility.Name') = 'C'
					.oUtility = oUtility
				case file(lcLibrary)
					.oUtility = newobject('SFUtility', lcLibrary)
			endcase
			lcLibrary = 'SFMessage.vcx'
			do case
				case type('.oMessage.Name') = 'C'
				case type('oMessage.Name') = 'C'
					.oMessage = oMessage
				case file(lcLibrary)
					.oMessage = newobject('SFMessageMgr', lcLibrary, '', .Caption)
			endcase
		
		* Create a collection of changes made to the values of controls.
		
			.oChanges = createobject('Collection')
		endwith
		return not This.lErrorOccurred
		
	ENDPROC

	PROCEDURE KeyPress
		lparameters tnKeyCode, ;
			tnShiftAltCtrl
		do case
		
		* Display the shortcut menu if Shift-F10 is pressed.
		
			case tnKeyCode = 93 and tnShiftAltCtrl = 1
				This.ShowMenu()
		
		* Prevent Ctrl-0 from inserting a null value.
		
			case tnKeyCode = asc('0') and bittest(tnShiftAltCtrl, 1)
				nodefault
		endcase
		
	ENDPROC

	PROCEDURE Load
		*==============================================================================
		* Method:			Load
		* Status:			Public
		* Purpose:			Sets up environmental things before the form instantiates
		* Author:			Doug Hennig
		* Copyright:		(c) 1996-2005 Stonefield Systems Group Inc.
		* Last revision:	04/25/2005
		* Parameters:		none
		* Returns:			.T.
		* Environment in:	none
		* Environment out:	the environment is set up the way we want
		*					the locations of tables in the DataEnvironment may have
		*						been changed
		*==============================================================================
		
		with This
		
		* Set some environmental things the way we want if we're in a private
		* datasession. These are in alphabetical order. Not all are datasession-
		* specific, but we'll set 'em anyway.
		
			if .DataSession = 2
				set ansi       off
				set bell       off			&& not datasession-specific
				set compatible off			&& not datasession-specific
				set cpdialog   off			&& not datasession-specific
				set deleted    on
				set exact      off
				set exclusive  off
				set fullpath   on			&& not datasession-specific
				set multilocks on
				set near       off
				set notify     off			&& not datasession-specific
				set nulldisplay to ''		&& not datasession-specific
				set safety     off
				set talk       off
				set unique     off
		
		* Set CENTURY after SYSFORMATS, since SYSFORMATS changes CENTURY.
		
				set sysformats on
				set century    on
			endif .DataSession = 2
		
		* If the tables haven't been opened yet, set the data directory for all
		* databases and free tables, then open the tables. If we don't have an
		* application object, just open the tables.
		
			do case
				case type('.DataEnvironment') <> 'O' or ;
					.DataEnvironment.AutoOpenTables
				case type('oApp.Name') = 'C' and pemstatus(oApp, 'SetDataDirectory', 5)
					oApp.SetDataDirectory(.DataEnvironment)
					.DataEnvironment.OpenTables()
				otherwise
					.DataEnvironment.OpenTables()
			endcase
		
		* Save the initial width and height values; we may need them later for resizing
		* purposes.
		
			.nInitialWidth  = .Width
			.nInitialHeight = .Height
		endwith
		
	ENDPROC

	PROCEDURE QueryUnload
		*==============================================================================
		* Method:			QueryUnload
		* Status:			Public
		* Purpose:			See if we can close the form and if not, use NODEFAULT to
		*						prevent it
		* Author:			Doug Hennig
		* Copyright:		(c) 1996-2008 Stonefield Systems Group Inc.
		* Last revision:	04/07/2008
		* Parameters:		none
		* Returns:			.T. if the form can be closed
		* Environment in:	none
		* Environment out:	see This.CanReleaseForm
		*==============================================================================
		
		local llReturn
		llReturn = This.CanReleaseForm()
		if not llReturn
			nodefault
		endif not llReturn
		return llReturn
		
	ENDPROC

	PROCEDURE refreshform		&& Refreshes the form
		*==============================================================================
		* Method:			RefreshForm
		* Status:			Public
		* Purpose:			Refreshes the form
		* Author:			Doug Hennig
		* Copyright:		(c) 1996-2006 Stonefield Systems Group Inc.
		* Last revision:	01/10/2006
		* Parameters:		none
		* Returns:			.T.
		* Environment in:	none
		* Environment out:	the form has been refreshed and any code in the
		*						BeforeRefresh and AfterRefresh methods has executed
		* Notes:			LockWindowUpdate was formerly used instead of
		*						This.LockScreen as a workaround for the problem of
		*						labels becoming bolder and bolder when this method is
		*						called (caused by a bug in how VFP works with ClearType
		*						displays) but that causes too much Windows Desktop
		*						refreshing, so we've reverted to LockScreen.
		*==============================================================================
		
		with This
			.LockScreen = .T.
			.BeforeRefresh()
			.Refresh()
			.AfterRefresh()
			.LockScreen = .F.
		endwith
		
	ENDPROC

	PROCEDURE Release
		* Release the object. Note the avoidance of "with This" in this code to prevent
		* potential problems with dangling object references.
		
		* Do nothing if we're already in the process of releasing or CanReleaseForm
		* says we can't release.
		
		if This.lRelease or not This.CanReleaseForm()
			nodefault
			return .F.
		endif This.lRelease ...
		
		* Do cleanup tasks.
		
		This.Cleanup()
		
	ENDPROC

	PROCEDURE releasemembers		&& Abstract method to nuke member references
		* Abstract method
		
	ENDPROC

	PROCEDURE resetchangedstate		&& Resets the changed state
		* Reset the changed state.
		
		This.lChanged = .F.
		This.oChanges.Remove(-1)
		
	ENDPROC

	PROCEDURE reseterror		&& Resets lErrorOccurred and aErrorInfo
		*==============================================================================
		* Method:			ResetError
		* Status:			Public
		* Purpose:			Reset lErrorOccurred and aErrorInfo
		* Author:			Doug Hennig
		* Copyright:		(c) 1996-2003 Stonefield Systems Group Inc.
		* Last revision:	01/26/2003
		* Parameters:		none
		* Returns:			.T.
		* Environment in:	none
		* Environment out:	This.lErrorOccurred is .F.
		*					This.nLastError is 1
		*					This.aErrorInfo is dimensioned to a single blank row
		*					This.oException is null
		*==============================================================================
		
		with This
			.lErrorOccurred = .F.
			dimension .aErrorInfo[1, cnAERR_MAX]
			.aErrorInfo = ''
			.nLastError = 1
			.oException = .NULL.
		endwith
		
	ENDPROC

	PROCEDURE RightClick
		*==============================================================================
		* Method:			RightClick
		* Status:			Public
		* Purpose:			Display a right-click menu
		* Author:			Doug Hennig
		* Copyright:		(c) 1996 Stonefield Systems Group Inc.
		* Last revision:	03/16/98
		* Parameters:		none
		* Returns:			.T.
		* Environment in:	none
		* Environment out:	a menu may have been displayed and action taken from the
		*						choice the user made
		*==============================================================================
		
		This.ShowMenu()
		
	ENDPROC

	PROCEDURE seterror		&& Sets lErrorOccurred and aErrorInfo to information about the most recent error
		*==============================================================================
		* Method:			SetError
		* Status:			Public
		* Purpose:			Handle errors
		* Author:			Doug Hennig
		* Copyright:		(c) 1996-2006 Stonefield Systems Group Inc.
		* Last revision:	04/26/2006
		* Parameters:		tcMethod - the method or function the error occurred in
		*					tnLine   - the line number within tcMethod
		*					tcSource - the code causing the error
		*					taError  - an array of error information
		* Returns:			.T.
		* Environment in:	This.aErrorInfo is dimensioned appropriately
		*					This.lErrorSet is .T. if this method has already been called
		*						for this error
		* Environment out:	This.lErrorOccurred is .T.
		*					This.lErrorSet is .T.
		*					This.nLastError points to the current row in This.aErrorInfo
		*					This.aErrorInfo is filled with error information as
		*						follows:
		*
		*					Column	Information
		*					------	-----------
		*					1 - 7	same as AERROR()
		*					8		method error occurred in
		*					9		line error occurred on
		*					10		code causing error
		*					11		date/time error occurred
		*					12		not used
		*					13		XML string of properties and their values for the
		*							object that caused the error (may be blank)
		*==============================================================================
		
		lparameters tcMethod, ;
			tnLine, ;
			tcSource, ;
			taError
		local lnRows, ;
			lnCols, ;
			lnLast, ;
			lnError, ;
			lnRow, ;
			lnI
		external array taError
		with This
		
		* If we've already been called, just update the method information.
		
			if .lErrorInfoSaved
				.aErrorInfo[.nLastError, cnAERR_METHOD] = tcMethod
			else
		
		* Flag that an error occurred.
		
				.lErrorOccurred  = .T.
				.lErrorInfoSaved = .T.
				lnRows = alen(taError, 1)
				lnCols = alen(taError, 2)
				lnLast = iif(empty(.aErrorInfo[1, 1]), 0, alen(.aErrorInfo, 1))
				dimension .aErrorInfo[lnLast + lnRows, cnAERR_MAX]
		
		* For each row in the error array, put each column into our array.
		
				for lnError = 1 to lnRows
					lnRow = lnLast + lnError
					for lnI = 1 to lnCols
						.aErrorInfo[lnRow, lnI] = taError[lnError, lnI]
					next lnI
		
		* Add some additional information to the current row in our array.
		
					.aErrorInfo[lnRow, cnAERR_METHOD]   = tcMethod
					.aErrorInfo[lnRow, cnAERR_LINE]     = tnLine
					.aErrorInfo[lnRow, cnAERR_SOURCE]   = ;
						iif(tcSource = .aErrorInfo[lnRow, cnAERR_MESSAGE], '', ;
						tcSource)
					.aErrorInfo[lnRow, cnAERR_DATETIME] = datetime()
				next lnError
				.nLastError = alen(.aErrorInfo, 1)
			endif not .lErrorInfoSaved
		endwith
		
	ENDPROC

	PROCEDURE setfocustofirstobject		&& Sets focus to the first object in the specified container
		*==============================================================================
		* Method:			SetFocusToFirstObject
		* Status:			Public
		* Purpose:			Sets focus to the first object in the specified container
		* Author:			Doug Hennig
		* Copyright:		(c) 1996-2005 Stonefield Systems Group Inc.
		* Last revision:	11/25/2005
		* Parameters:		toContainer       - the container to check (optional: if it
		*						isn't passed, the form is used)
		*					tlKeepCurrentPage - .T. to keep the current page in any
		*						PageFrame active
		* Returns:			.T. if it set focus to an object
		* Environment in:	none
		* Environment out:	if this method returns .T., focus has been set to an object
		*==============================================================================
		
		lparameters toContainer, ;
			tlKeepCurrentPage
		local loContainer, ;
			laObjects[1], ;
			lnObjects, ;
			lnIndex, ;
			loControl, ;
			llReturn, ;
			lnI, ;
			loObject, ;
			lcClass, ;
			lnPage, ;
			loPage
		
		* If the container wasn't specified, let's use the form.
		
		loContainer = iif(vartype(toContainer) = 'O', toContainer, This)
		
		* Get an array of all member objects of the specified container. Initialize
		* some variables.
		
		lnObjects = amembers(laObjects, loContainer, 2)
		lnIndex   = 99999
		loControl = .NULL.
		llReturn  = .F.
		
		* Check each of the member objects until we come across the one lowest in the
		* tab order.
		
		for lnI = 1 to lnObjects
			loObject = evaluate('loContainer.' + laObjects[lnI])
			lcClass  = upper(loObject.BaseClass)
			do case
		
		* If the object doesn't have a TabIndex property, is a label, is disabled, or
		* isn't visible, ignore it.
		
				case type('loObject.TabIndex') = 'U' or lcClass = 'LABEL' or ;
					(type('loObject.TabStop') = 'L' and not loObject.TabStop and ;
						upper(loObject.BaseClass) <> 'PAGEFRAME') or ;
					(type('loObject.Enabled') = 'L' and not loObject.Enabled) or ;
					(type('loObject.Visible') = 'L' and not loObject.Visible)
		
		* If this object is lower in tab order than any we've already seen, grab a
		* reference to it.
		
				case loObject.TabIndex < lnIndex
					loControl = loObject
					lnIndex   = loObject.TabIndex
			endcase
		next lnI
		
		* If we found an object, set focus to it. We may need to drill down into it if
		* it's a container.
		
		if vartype(loControl) = 'O'
			lcClass = upper(loControl.BaseClass)
			do case
		
		* If this is a pageframe, choose the first page, then call ourselves
		* recursively to find the first object inside it and set focus to it.
		
				case lcClass = 'PAGEFRAME'
					if tlKeepCurrentPage
						lnPage = loControl.ActivePage
					else
						lnIndex = 99999
						lnPage  = 0
						for lnI = 1 to loControl.PageCount
							loPage = loControl.Pages[lnI]
							if loPage.PageOrder < lnIndex
								lnPage  = lnI
								lnIndex = loPage.PageOrder
							endif loPage.PageOrder < lnIndex
						next lnI
					endif tlKeepCurrentPage
					if lnPage > 0
						if loControl.ActivePage <> lnPage
							loControl.ActivePage = lnPage
						endif loControl.ActivePage <> lnPage
						llReturn = This.SetFocusToFirstObject(loControl.Pages[lnPage])
					endif lnPage > 0
		
		* If this is another type of container, call ourselves recursively to find the
		* first object inside it and set focus to it.
		
				case lcClass $ 'COMMANDGROUP,OPTIONGROUP,CONTAINER'
					llReturn = This.SetFocusToFirstObject(loControl)
		
		* Set focus to the object.
		
				case pemstatus(loControl, 'SetFocus', 5)
					loControl.SetFocus()
					llReturn = .T.
			endcase
		endif vartype(loControl) = 'O' ...
		return llReturn
		
	ENDPROC

	PROCEDURE setfocustolastobject		&& Sets focus to the last object in the specified container
		*==============================================================================
		* Method:			SetFocusToLastObject
		* Status:			Public
		* Purpose:			Sets focus to the last object in the specified container
		* Author:			Doug Hennig
		* Copyright:		(c) 2008 Stonefield Systems Group Inc.
		* Last revision:	03/03/2008
		* Parameters:		toContainer       - the container to check (optional: if it
		*						isn't passed, the form is used)
		*					tlKeepCurrentPage - .T. to keep the current page in any
		*						PageFrame active
		* Returns:			.T. if it set focus to an object
		* Environment in:	none
		* Environment out:	if this method returns .T., focus has been set to an object
		*==============================================================================
		
		lparameters toContainer, ;
			tlKeepCurrentPage
		local loContainer, ;
			laObjects[1], ;
			lnObjects, ;
			lnIndex, ;
			loControl, ;
			llReturn, ;
			lnI, ;
			loObject, ;
			lcClass, ;
			lnPage, ;
			loPage
		
		* If the container wasn't specified, let's use the form.
		
		loContainer = iif(vartype(toContainer) = 'O', toContainer, This)
		
		* Get an array of all member objects of the specified container. Initialize
		* some variables.
		
		lnObjects = amembers(laObjects, loContainer, 2)
		lnIndex   = 0
		loControl = .NULL.
		llReturn  = .F.
		
		* Check each of the member objects until we come across the one lowest in the
		* tab order.
		
		for lnI = 1 to lnObjects
			loObject = evaluate('loContainer.' + laObjects[lnI])
			lcClass  = upper(loObject.BaseClass)
			do case
		
		* If the object doesn't have a TabIndex property, is a label, is disabled, or
		* isn't visible, ignore it.
		
				case type('loObject.TabIndex') = 'U' or lcClass = 'LABEL' or ;
					(type('loObject.TabStop') = 'L' and not loObject.TabStop and ;
						upper(loObject.BaseClass) <> 'PAGEFRAME') or ;
					(type('loObject.Enabled') = 'L' and not loObject.Enabled) or ;
					(type('loObject.Visible') = 'L' and not loObject.Visible)
		
		* If this object is greater in tab order than any we've already seen, grab a
		* reference to it.
		
				case loObject.TabIndex > lnIndex
					loControl = loObject
					lnIndex   = loObject.TabIndex
			endcase
		next lnI
		
		* If we found an object, set focus to it. We may need to drill down into it if
		* it's a container.
		
		if vartype(loControl) = 'O'
			lcClass = upper(loControl.BaseClass)
			do case
		
		* If this is a pageframe, choose the first page, then call ourselves
		* recursively to find the first object inside it and set focus to it.
		
				case lcClass = 'PAGEFRAME'
					if tlKeepCurrentPage
						lnPage = loControl.ActivePage
					else
						lnIndex = 99999
						lnPage  = 0
						for lnI = 1 to loControl.PageCount
							loPage = loControl.Pages[lnI]
							if loPage.PageOrder < lnIndex
								lnPage  = lnI
								lnIndex = loPage.PageOrder
							endif loPage.PageOrder < lnIndex
						next lnI
					endif tlKeepCurrentPage
					if lnPage > 0
						if loControl.ActivePage <> lnPage
							loControl.ActivePage = lnPage
						endif loControl.ActivePage <> lnPage
						llReturn = This.SetFocusToLastObject(loControl.Pages[lnPage])
					endif lnPage > 0
		
		* If this is another type of container, call ourselves recursively to find the
		* last object inside it and set focus to it.
		
				case lcClass $ 'COMMANDGROUP,OPTIONGROUP,CONTAINER'
					llReturn = This.SetFocusToLastObject(loControl)
		
		* Set focus to the object.
		
				case pemstatus(loControl, 'SetFocus', 5)
					loControl.SetFocus()
					llReturn = .T.
			endcase
		endif vartype(loControl) = 'O' ...
		return llReturn
		
	ENDPROC

	PROCEDURE shortcutmenu		&& Populates the shortcut menu
		*==============================================================================
		* Method:			ShortcutMenu
		* Status:			Public
		* Purpose:			Populates the specified menu object (abstract in this
		*						class)
		* Author:			Doug Hennig
		* Copyright:		(c) 1996 Stonefield Systems Group Inc.
		* Last revision:	12/11/98
		* Parameters:		toMenu   - an object reference to a menu object
		*					tcObject - the name of the variable containing the object
		*						reference to this object
		* Returns:			.T.
		* Environment in:	none
		* Environment out:	additional items may have been added to the menu in a
		*						subclass of this class
		*==============================================================================
		
		lparameters toMenu, ;
			tcObject
		
	ENDPROC

	PROCEDURE Show
		*==============================================================================
		* Method:			Show
		* Status:			Public
		* Purpose:			Display the form
		* Author:			Doug Hennig
		* Copyright:		(c) 1996-2008 Stonefield Systems Group Inc.
		* Last revision:	03/13/2008
		* Parameters:		tnStyle - the style for the window
		* Returns:			.T.
		* Environment in:	none
		* Environment out:	focus is set to the first object in the form
		*==============================================================================
		
		lparameters tnStyle
		local lcType
		lcType = vartype(tnStyle)
		if (pcount() = 0 or lcType = 'L' or (lcType = 'N' and tnStyle = ;
			This.WindowType)) and This.lSetFocusToFirstObject
			This.SetFocusToFirstObject(This)
		endif pcount() = 0 ...
		
	ENDPROC

	PROCEDURE showmenu		&& Display a shortcut menu
		*==============================================================================
		* Method:			ShowMenu
		* Status:			Public
		* Purpose:			Displays a shortcut menu
		* Author:			Doug Hennig
		* Copyright:		(c) 1996-2004 Stonefield Systems Group Inc.
		* Last revision:	07/20/2004
		* Parameters:		none
		* Returns:			.T.
		* Environment in:	SFMenu.VCX can be found
		* Environment out:	a menu may have been displayed
		*==============================================================================
		
		local lcLibrary
		private loObject, ;
			loHook
		with This
		
		* Define reference to objects we might have menu items from in case the action
		* for a bar is to call a method of an object, which can't be done using "This.
		* Method" since "This" isn't applicable in a menu.
		
			loObject = This
			loHook   = .oHook
		
		* Define the menu if it hasn't already been defined.
		
			lcLibrary = 'SFMenu.vcx'
			if vartype(.oMenu) <> 'O' and file(lcLibrary)
				.oMenu = newobject('SFShortcutMenu', lcLibrary)
			endif vartype(.oMenu) <> 'O' ...
			if vartype(.oMenu) = 'O'
		
		* If there aren't any bars in the menu, have the ShortcutMenu method populate
		* it.
		
				if .oMenu.nBarCount = 0
					.ShortcutMenu(.oMenu, 'loObject')
		
		* Use the hook object (if there is one) to do any further population of the
		* menu.
		
					if vartype(loHook) = 'O' and pemstatus(loHook, 'ShortcutMenu', 5)
						loHook.ShortcutMenu(.oMenu, 'loHook')
					endif vartype(loHook) = 'O' ...
				endif .oMenu.nBarCount = 0
		
		* Activate the menu if necessary.
		
				if .oMenu.nBarCount > 0
					.oMenu.ShowMenu()
				endif .oMenu.nBarCount > 0
			endif vartype(.oMenu) = 'O' ...
		endwith
		
	ENDPROC

	PROCEDURE updatechanges		&& Adjusts the oChanges collection when a change is made
		* Update the collection of changes. If the specified item isn't in the
		* collection, add it. If it was previously in the collection but has been
		* reverted, remove it. Return .T. if there are any items in the collection
		* (that is, there have been changes).
		
		lparameters tcItem, ;
			tlChanged
		local lnIndex, ;
			llReturn
		lnIndex = This.oChanges.GetKey(tcItem)
		do case
			case lnIndex = 0 and tlChanged
				This.oChanges.Add(.T., tcItem)
			case lnIndex > 0 and not tlChanged
				This.oChanges.Remove(tcItem)
		endcase
		llReturn = This.oChanges.Count > 0
		return llReturn
		
	ENDPROC

ENDDEFINE

DEFINE CLASS sfgrid AS grid 		&& The base class for Grid objects
 	*< CLASSDATA: Baseclass="grid" Timestamp="" Scale="Pixels" Uniqueid="" />

	#INCLUDE "sfctrls.h"
	*<DefinedPropArrayMethod>
		*m: about		&& Provides documentation for the class
		*m: enabled_assign		&& Makes the grid appear enabled or disabled
		*m: getcaption		&& Gets the caption for the specified field
		*m: lsaveanchor_assign
		*m: onformchange		&& Fired when the lChanged property of the form changes if lNotifyOnFormChange is .T.
		*m: release		&& Releases the object
		*m: setupcolumns		&& Sets up things we need about columns
		*m: shortcutmenu		&& Populates the shortcut menu
		*m: showmenu		&& Display a shortcut menu
		*p: builder		&& Tells BUILDER.APP the name of a specific builder to use for this class (specified as Library,Class)
		*p: lautofit		&& .T. to auto-fit the columns automatically
		*p: lautosetup		&& .T. to automatically call SetupColumns from Init
		*p: lnotifyonformchange		&& .T. if the OnFormChanged method of this control is bound to the lChanged property of the form
		*p: lsaveanchor		&& This allows a container to use SetAll('lSaveAnchor') to save/reset and then restore Anchor when the form's size is changed but controls shouldn't move
		*p: luseformshortcutmenu		&& .T. if the form's shortcut menu items should be included with this object's
		*p: nbackcolor		&& Our original BackColor
		*p: nsavedanchor		&& The anchor value saved in lSaveAnchor_Assign
		*p: oexception		&& A reference to an Exception object
		*p: ohook		&& A reference to a hooked object
		*p: omenu		&& A reference to an SFShortcutMenu object
		*p: _memberdata		&& XML Metadata for customizable properties
	*</DefinedPropArrayMethod>

	PROTECTED nbackcolor,nsavedanchor
	AllowHeaderSizing = .F.
	AllowRowSizing = .F.
	Anchor = 15
	builder = 		&& Tells BUILDER.APP the name of a specific builder to use for this class (specified as Library,Class)
	FontName = "Tahoma"
	lautofit = .F.		&& .T. to auto-fit the columns automatically
	lautosetup = .T.		&& .T. to automatically call SetupColumns from Init
	lnotifyonformchange = .F.		&& .T. if the OnFormChanged method of this control is bound to the lChanged property of the form
	lsaveanchor = .F.		&& This allows a container to use SetAll('lSaveAnchor') to save/reset and then restore Anchor when the form's size is changed but controls shouldn't move
	luseformshortcutmenu = .F.		&& .T. if the form's shortcut menu items should be included with this object's
	Name = "sfgrid"
	nbackcolor = 0		&& Our original BackColor
	nsavedanchor = 0		&& The anchor value saved in lSaveAnchor_Assign
	oexception = .NULL.		&& A reference to an Exception object
	ohook = .NULL.		&& A reference to a hooked object
	omenu = .NULL.		&& A reference to an SFShortcutMenu object
	SplitBar = .F.
	_memberdata = <VFPData>
		<memberdata name="about" type="method" display="About"/>
		<memberdata name="builder" type="property" display="Builder"/>
		<memberdata name="enabled_assign" type="method" display="Enabled_Assign"/>
		<memberdata name="getcaption" type="method" display="GetCaption"/>
		<memberdata name="lautofit" type="property" display="lAutoFit" favorites="True"/>
		<memberdata name="lautosetup" type="property" display="lAutoSetup" favorites="True"/>
		<memberdata name="luseformshortcutmenu" type="property" display="lUseFormShortcutMenu"/>
		<memberdata name="nbackcolor" type="property" display="nBackColor"/>
		<memberdata name="oexception" type="property" display="oException"/>
		<memberdata name="ohook" type="property" display="oHook"/>
		<memberdata name="omenu" type="property" display="oMenu"/>
		<memberdata name="release" type="method" display="Release"/>
		<memberdata name="setupcolumns" type="method" display="SetupColumns"/>
		<memberdata name="shortcutmenu" type="method" display="ShortcutMenu"/>
		<memberdata name="showmenu" type="method" display="ShowMenu"/>
		<memberdata name="lsaveanchor" type="property" display="lSaveAnchor"/>
		<memberdata name="lsaveanchor_assign" type="property" display="lSaveAnchor_Assign"/>
		<memberdata name="nsavedanchor" type="property" display="nSavedAnchor"/>
		<memberdata name="lnotifyonformchange" type="property" display="lNotifyOnFormChange"/>
		<memberdata name="onformchange" type="method" display="OnFormChange"/>
		</VFPData>		&& XML Metadata for customizable properties
	
	PROCEDURE about		&& Provides documentation for the class
		*==============================================================================
		* Class:						SFGrid
		* Based On:						Grid
		* Purpose:						Base class for all Grid objects
		* Author:						Doug Hennig
		* Copyright:					(c) 1996-2008 Stonefield Systems Group Inc.
		* Last revision:				05/22/2008
		* Include file:					SFCTRLS.H
		*
		* Changes in "Based On" class properties:
		*	AllowHeaderSizing:			.F.
		*	AllowRowSizing:				.F.
		*	Anchor:						15 (resize height and width)
		*	FontName:					Tahoma
		*	SplitBar:					.F.
		*
		* Changes in "Based On" class methods:
		*	Destroy:					nukes member objects
		*	Error:						calls the parent Error method so error handling
		*								goes up the containership hierarchy
		*	Init:						call This.SetupColumns and bind OnFormChange to
		*								the form's lChanged property if necessary.
		*								Change FontName to Segoe UI in Vista.
		*	Refresh:					refresh contained controls
		*	RightClick:					call This.ShowMenu
		*
		* Custom public properties added:
		*	Builder:					tells BUILDER.APP the name of a specific
		*								builder to use for this class (specified as
		*								Library,Class)
		*	lAutoFit:					.T. to auto-fit the columns automatically
		*	lAutoSetup:					.T. to automatically call SetupColumns from
		*								Init
		*	lNotifyOnFormChange:		.T. if the OnFormChanged method of this control
		*								is bound to the lChanged property of the form
		*	lSaveAnchor:				this allows a container to use
		*								SetAll('lSaveAnchor') to save/reset and then
		*								restore Anchor when the form's size is changed
		*								but controls shouldn't move
		*	lUseFormShortcutMenu:		.T. if the form's shortcut menu items should be
		*								included with this object's
		*	oException:					a reference to an Exception object
		*	oHook:						a reference to a hooked object
		*	oMenu:						a reference to an SFShortcutMenu object
		*
		* Custom protected properties added:
		*	nBackColor:					our original BackColor
		*	nSavedAnchor:				the anchor value saved in lSaveAnchor_Assign
		*
		* Custom public methods added:
		*	About:						provides documentation for the class
		*	Enabled_Assign:				makes the grid appear enabled or disabled
		*	GetCaption:					gets the caption for the specified field
		*	OnFormChange:				fired when the lChanged property of the form
		*								changes if lNotifyOnFormChange is .T.
		*	Release:					releases the object
		*	SetupColumns:				sets up things we need about columns
		*	ShortcutMenu:				populates the shortcut menu
		*	ShowMenu:					display a shortcut menu
		*
		* Custom protected methods added:
		*	None
		*==============================================================================
		
	ENDPROC

	PROCEDURE Destroy
		* Nuke member objects.
		
		This.oHook = .NULL.
		This.oMenu = .NULL.
		
	ENDPROC

	PROCEDURE enabled_assign		&& Makes the grid appear enabled or disabled
		* Make the grid appear to be disabled if necessary.
		
		lparameters tlEnabled
		with This
			do case
				case .Enabled = tlEnabled
				case tlEnabled
					.BackColor = iif(.nBackColor = 0, .BackColor, .nBackColor)
				otherwise
					.nBackColor = .BackColor
					.BackColor  = .Parent.BackColor
			endcase
			.Enabled = tlEnabled
		endwith
		
	ENDPROC

	PROCEDURE Error
		*==============================================================================
		* Method:			Error
		* Status:			Public
		* Purpose:			Handles errors
		* Author:			Doug Hennig
		* Copyright:		(c) 1996-2005 Stonefield Systems Group Inc.
		* Last revision:	12/15/2005
		* Parameters:		tnError  - the error number
		*					tcMethod - the method that caused the error
		*					tnLine   - the line number of the command in error 
		* Returns:			may return an error resolution string (see SFERRORS.H for
		*						a list) or may RETURN, RETRY, or CANCEL
		* Environment in:	if a global error handler object exists, it's in the global
		*						variable oError
		*					a global ON ERROR routine may be in effect
		* Environment out:	depends on the error resolution chosen
		*==============================================================================
		
		lparameters tnError, ;
			tcMethod, ;
			tnLine
		local lnError, ;
			lcMethod, ;
			lnLine, ;
			lcSource, ;
			laError[1], ;
			lcName, ;
			lcOrigMethod, ;
			loParent, ;
			lcReturn, ;
			lcError, ;
			lcMessage, ;
			lnChoice
		
		* Use AERROR() to get information about the error. If we have an Exception
		* object in oException, get information about the error from it.
		
		lnError  = tnError
		lcMethod = tcMethod
		lnLine   = tnLine
		lcSource = message(1)
		aerror(laError)
		with This
			if vartype(.oException) = 'O'
				lnError  = .oException.ErrorNo
				lcMethod = .oException.Procedure
				lnLine   = .oException.LineNo
				lcSource = .oException.LineContents
				laError[cnAERR_NUMBER]  = .oException.ErrorNo
				laError[cnAERR_MESSAGE] = .oException.Message
				laError[cnAERR_OBJECT]  = .oException.Details
				.oException = .NULL.
			endif vartype(.oException) = 'O'
		endwith
		
		* Determine which method of which object the error occurred in. If the error
		* occurred in a child object, the method may already have our name on it, so
		* handle that.
		
		lcName   = upper(This.Name) + '.'
		lcMethod = upper(tcMethod)
		if lcMethod = lcName or '.' + lcName $ lcMethod
			lcOrigMethod = substr(tcMethod, rat('.', tcMethod) + 1)
		else
			lcOrigMethod = tcMethod
		endif lcMethod = lcName ...
		lcMethod = This.Name + '.' + lcOrigMethod
		
		* If we're sitting on a form and that form has a FindErrorHandler method, call
		* it to travel up the containership hierarchy until we find a parent that has
		* code in its Error method. Also, if it has a SetError method, call it now so
		* we don't lose the message information (which gets messed up by TYPE()).
		
		if type('Thisform') = 'O'
			loParent = iif(pemstatus(Thisform, 'FindErrorHandler', 5), ;
				Thisform.FindErrorHandler(This), .NULL.)
			if pemstatus(Thisform, 'SetError', 5)
				Thisform.SetError(lcMethod, lnLine, lcSource, @laError)
			endif pemstatus(Thisform, 'SetError', 5)
		else
			loParent = .NULL.
		endif type('Thisform') = 'O'
		do case
		
		* We have a parent that can handle the error.
		
			case not isnull(loParent)
				lcReturn = loParent.Error(lnError, lcMethod, lnLine)
		
		* We have an error handling object, so call its ErrorHandler() method.
		
			case type('oError.Name') = 'C' and pemstatus(oError, 'ErrorHandler', 5)
				if pemstatus(oError, 'SetError', 5)
					oError.SetError(lcMethod, lnLine, lcSource, @laError)
				endif pemstatus(oError, 'SetError', 5)
				lcReturn = oError.ErrorHandler(lnError, lcMethod, lnLine)
		
		* A global error handler is in effect, so let's pass the error on to it.
		* Replace certain parameters passed to the error handler (the name of the
		* program, the error number, the line number, the message, and SYS(2018)) with
		* the appropriate values.
		
			case not empty(on('ERROR'))
				lcError = upper(on('ERROR'))
				lcError = strtran(lcError, 'SYS(16)',   '"' + lcMethod + '"')
				lcError = strtran(lcError, 'PROGRAM()', '"' + lcMethod + '"')
				lcError = strtran(lcError, ',ERROR()',  ',lnError')
				lcError = strtran(lcError, ' ERROR()',  ' lnError')
				lcError = strtran(lcError, 'LINENO()',  'lnLine')
				lcError = strtran(lcError, 'MESSAGE()', 'laError[2]')
				lcError = strtran(lcError, 'SYS(2018)', 'laError[3]')
		
		* If the error handler is called with DO, macro expand it and assume the return
		* value is "CONTINUE". If the error handler is called as a function (such as an
		* object method), call it and grab the return value if there is one.
		
				if left(lcError, 3) = 'DO ' or '=' $ lcError
					&lcError
					lcReturn = ccMSG_CONTINUE
				else
					lcReturn = &lcError
				endif left(lcError, 3) = 'DO ' ...
		
		* Display a generic dialog box with an option to display the debugger (this
		* should only occur in a test environment).
		
			otherwise
				lcSource  = message(1)
				lcMessage = ccMSG_ERROR_NUM + ' ' + transform(lnError) + ccCR + ;
					ccMSG_MESSAGE + ' ' + laError[cnAERR_MESSAGE] + ccCR + ;
					iif(empty(lcSource), '', ccMSG_CODE + ' ' + lcSource + ;
					ccCR) + iif(lnLine = 0, '', ccMSG_LINE_NUM + ' ' + ;
					transform(lnLine) + ccCR) + ccMSG_METHOD + ' ' + lcMethod
				if version(2) = 0
					lnChoice = messagebox(lcMessage + ccCR + ccCR + ;
						'Choose OK to continue or Cancel to cancel execution', ;
						MB_OKCANCEL + MB_ICONSTOP, _VFP.Caption)
				else
					lnChoice = messagebox(lcMessage + ccCR + ccCR + ;
						'Choose Yes to display the debugger, No to continue ' + ;
						'without the debugger, or Cancel to cancel execution', ;
						MB_YESNOCANCEL + MB_ICONSTOP, _VFP.Caption)
				endif version(2) = 0
				do case
					case lnChoice = IDYES
						lcReturn = ccMSG_DEBUG
					case lnChoice = IDCANCEL
						lcReturn = ccMSG_CANCEL
				endcase
		endcase
		
		* Ensure the return message is acceptable. If not, assume "CONTINUE".
		
		lcReturn = iif(vartype(lcReturn) <> 'C' or empty(lcReturn) or ;
			not lcReturn $ ccMSG_CONTINUE + ccMSG_RETRY + ccMSG_CANCEL + ccMSG_DEBUG, ;
			ccMSG_CONTINUE, lcReturn)
		
		* Handle the return value.
		
		do case
		
		* It wasn't our error, so pass it back to the calling method.
		
			case '.' $ lcOrigMethod
				return lcReturn
		
		* Display the debugger.
		
			case lcReturn = ccMSG_DEBUG
				debug
				if wexist('Visual FoxPro Debugger')
					keyboard '{SHIFT+F7}' plain
				endif wexist('Visual FoxPro Debugger')
				suspend
		
		* Retry the command.
		
			case lcReturn = ccMSG_RETRY
				retry
		
		* Cancel execution.
		
			case lcReturn = ccMSG_CANCEL
				cancel
		
		* Go to the line of code following the error.
		
			otherwise
				return
		endcase
		
	ENDPROC

	PROCEDURE getcaption		&& Gets the caption for the specified field
		*==============================================================================
		* Method:			GetCaption
		* Status:			Public
		* Purpose:			Get the caption for the specified field
		* Author:			Doug Hennig
		* Copyright:		(c) 1996-1998 Stonefield Systems Group Inc.
		* Last revision:	12/04/98
		* Parameters:		tcField - the field to get the caption for
		* Returns:			the caption for the field
		* Environment in:	if the field's table is in a DBC, that DBC is the current
		*						one
		*					oMeta may contain an object reference to DBCXMgr
		* Environment out:	none
		*==============================================================================
		
		lparameters tcField
		local lcField, ;
			lcCaption
		lcField = substr(tcField, at('.', tcField) + 1)
		do case
			case not empty(dbc()) and indbc(tcField, 'Field')
				lcCaption = dbgetprop(tcField, 'Field', 'Caption')
			case vartype('oMeta') = 'O'
				lcCaption = nvl(oMeta.DBCXGetProp(tcField, 'Field', 'Caption'), '')
			otherwise
				lcCaption = ''
		endcase
		lcCaption = iif(empty(lcCaption), proper(strtran(lcField, '_', ' ')), ;
			lcCaption)
		return lcCaption
		
	ENDPROC

	PROCEDURE Init
		local loParent
		with This
		
		* Change the font to Segoe UI in Vista.
		
			if os(3) >= '6' and .FontName = 'Tahoma'
				.FontName = 'Segoe UI'
			endif os(3) >= '6' ...
		
		* Call the SetupColumns method so we can handle highlighting the entire row if
		* necessary.
		
			if .lAutoSetup
				.SetupColumns()
			endif .lAutoSetup
		
		* If we're supposed to bind to the lChanged property of the form, do so.
		
			if .lNotifyOnFormChange and vartype(Thisform) = 'O' and ;
				pemstatus(Thisform, 'lChanged', 5)
				bindevent(Thisform, 'lChanged', This, 'OnFormChange', 1)
			endif .lNotifyOnFormChange ...
		endwith
		
	ENDPROC

	PROCEDURE lsaveanchor_assign
		lparameters tlSaveAnchor
		do case
			case tlSaveAnchor and This.nSavedAnchor > 0 and This.Anchor = 0
			case tlSaveAnchor
				This.nSavedAnchor = This.Anchor
				This.Anchor       = 0
			otherwise
				This.Anchor = This.nSavedAnchor
		endcase
		
	ENDPROC

	PROCEDURE onformchange		&& Fired when the lChanged property of the form changes if lNotifyOnFormChange is .T.
		* Refresh the control when something in the form changes.
		
		This.Refresh()
		
	ENDPROC

	PROCEDURE Refresh
		* Ensure all contained controls are refreshed.
		
		local loColumn, ;
			loControl
		with This
			for each loColumn in .Columns foxobject
				for each loControl in loColumn.Controls foxobject
					if pemstatus(loControl, 'Refresh', 5)
						loControl.Refresh()
					endif pemstatus(loControl, 'Refresh', 5)
				next loControl
			next loColumn
		endwith
		
	ENDPROC

	PROCEDURE release		&& Releases the object
		* Release the object.
		
		release This
		
	ENDPROC

	PROCEDURE RightClick
		* Display a right-click menu.
		
		This.ShowMenu()
		
	ENDPROC

	PROCEDURE setupcolumns		&& Sets up things we need about columns
		*==============================================================================
		* Method:			SetupColumns
		* Status:			Public
		* Purpose:			Sets up the columns
		* Author:			Doug Hennig
		* Copyright:		(c) 1996-2008 Stonefield Systems Group Inc.
		* Last revision:	05/22/2008
		* Parameters:		none
		* Returns:			.T.
		* Environment in:	none
		* Environment out:	if the table belongs to a database, that database is the
		*						current one
		*					headers with a default caption are changed to the caption
		*						for the field their column displays
		*					the FontName and FontSize for all headers is set to that of
		*						the grid
		*==============================================================================
		
		local lcDatabase, ;
			loColumn, ;
			lcCaption
		with This
		
		* If the grid is read-only, make all member objects read-only.
		
			if .ReadOnly
				.SetAll('ReadOnly', .T.)
			endif .ReadOnly
		
		* Ensure the database for the RecordSource (if there is one) is selected. This
		* is needed for the GetCaption method.
		
			if not empty(.RecordSource)
				lcDatabase = cursorgetprop('DATABASE', .RecordSource)
				if not set('DATABASE') == lcDatabase and not empty(lcDatabase)
					set database to (lcDatabase)
				endif not set('DATABASE') == lcDatabase ...
			endif not empty(.RecordSource)
		
		* Ensure each column has a valid header caption.
		
			for each loColumn in .Columns foxobject
				for each loObject in loColumn.Controls foxobject
					if upper(loObject.BaseClass) = 'HEADER'
						if loObject.Caption = 'Header1' and ;
							not empty(loColumn.ControlSource)
							lcCaption = .GetCaption(loColumn.ControlSource)
							loObject.Caption = lcCaption
						endif loObject.Caption = 'Header1' ...
						loObject.FontName = .FontName
						loObject.FontSize = .FontSize
						exit
					endif upper(loObject.BaseClass) = 'HEADER'
				next loObject
			next loColumn
		
		* If we're supposed to auto-fit the columns, do so.
		
			if .lAutoFit
				.AutoFit()
			endif .lAutoFit
		endwith
		
	ENDPROC

	PROCEDURE shortcutmenu		&& Populates the shortcut menu
		*==============================================================================
		* Method:			ShortcutMenu
		* Status:			Public
		* Purpose:			Populates the specified menu object
		* Author:			Doug Hennig
		* Copyright:		(c) 1996 Stonefield Systems Group Inc.
		* Last revision:	12/11/98
		* Parameters:		toMenu   - an object reference to a menu object
		*					tcObject - the name of the variable containing the object
		*						reference to this object
		* Returns:			.T.
		* Environment in:	none
		* Environment out:	additional items were added to the menu
		*==============================================================================
		
		lparameters toMenu, ;
			tcObject
		
	ENDPROC

	PROCEDURE showmenu		&& Display a shortcut menu
		*==============================================================================
		* Method:			ShowMenu
		* Status:			Public
		* Purpose:			Displays a shortcut menu
		* Author:			Doug Hennig
		* Copyright:		(c) 1996-2004 Stonefield Systems Group Inc.
		* Last revision:	07/20/2004
		* Parameters:		none
		* Returns:			.T.
		* Environment in:	SFMenu.VCX can be found
		* Environment out:	a menu may have been displayed
		*==============================================================================
		
		local lcLibrary
		private loObject, ;
			loHook, ;
			loForm
		with This
		
		* Define reference to objects we might have menu items from in case the action
		* for a bar is to call a method of an object, which can't be done using "This.
		* Method" since "This" isn't applicable in a menu.
		
			loObject = This
			loHook   = .oHook
			loForm   = Thisform
		
		* Define the menu if it hasn't already been defined.
		
			lcLibrary = 'SFMenu.vcx'
			if vartype(.oMenu) <> 'O' and file(lcLibrary)
				.oMenu = newobject('SFShortcutMenu', lcLibrary)
			endif vartype(.oMenu) <> 'O' ...
			if vartype(.oMenu) = 'O'
		
		* If there aren't any bars in the menu, have the ShortcutMenu method populate
		* it.
		
				if .oMenu.nBarCount = 0
					.ShortcutMenu(.oMenu, 'loObject')
		
		* Use the hook object (if there is one) to do any further population of the
		* menu.
		
					if vartype(loHook) = 'O' and pemstatus(loHook, 'ShortcutMenu', 5)
						loHook.ShortcutMenu(.oMenu, 'loHook')
					endif vartype(loHook) = 'O' ...
		
		* If desired, use the form's shortcut menu as well.
		
					if .lUseFormShortcutMenu and type('Thisform.Name') = 'C' and ;
						pemstatus(loForm, 'ShortcutMenu', 5)
						loForm.ShortcutMenu(.oMenu, 'loForm')
					endif .lUseFormShortcutMenu ...
				endif .oMenu.nBarCount = 0
		
		* Activate the menu if necessary.
		
				if .oMenu.nBarCount > 0
					.oMenu.ShowMenu()
				endif .oMenu.nBarCount > 0
			endif vartype(.oMenu) = 'O' ...
		endwith
		
	ENDPROC

ENDDEFINE

DEFINE CLASS sfpage AS page 
 	*< CLASSDATA: Baseclass="page" Timestamp="" Scale="Pixels" Uniqueid="" />

	#INCLUDE "sfctrls.h"
	*<DefinedPropArrayMethod>
		*m: about		&& Provides documentation for the class
		*m: enabled_assign		&& Sets the Enabled property of all member objects to the specified value so they appear to be enabled or disabled
		*m: release		&& Releases the object
		*m: shortcutmenu		&& Populates the shortcut menu
		*m: showmenu		&& Display a shortcut menu
		*p: builder		&& Tells BUILDER.APP the name of a specific builder to use for this class (specified as Library,Class)
		*p: cmemberclass		&& The class for a delayed instantiation member
		*p: cmemberlibrary		&& The library containing the class specified in cMemberClass
		*p: lsetfocustofirstobject		&& .T. to set focus to the first object on the page when the page is activated
		*p: oexception		&& A reference to an Exception object
		*p: ohook		&& A reference to a hooked object
		*p: omenu		&& A reference to an SFShortcutMenu object
		*p: _memberdata		&& XML Metadata for customizable properties
	*</DefinedPropArrayMethod>

	builder = 		&& Tells BUILDER.APP the name of a specific builder to use for this class (specified as Library,Class)
	Caption = "Page1"
	cmemberclass = 		&& The class for a delayed instantiation member
	cmemberlibrary = 		&& The library containing the class specified in cMemberClass
	FontName = "Tahoma"
	Height = 153
	lsetfocustofirstobject = .T.		&& .T. to set focus to the first object on the page when the page is activated
	Name = "sfpage"
	oexception = .NULL.		&& A reference to an Exception object
	ohook = .NULL.		&& A reference to a hooked object
	omenu = .NULL.		&& A reference to an SFShortcutMenu object
	Width = 153
	_memberdata = <VFPData>
		<memberdata name="about" type="method" display="About"/>
		<memberdata name="builder" type="property" display="Builder"/>
		<memberdata name="cmemberclass" type="property" display="cMemberClass" favorites="True"/>
		<memberdata name="cmemberlibrary" type="property" display="cMemberLibrary" favorites="True"/>
		<memberdata name="enabled_assign" type="method" display="Enabled_Assign"/>
		<memberdata name="oexception" type="property" display="oException"/>
		<memberdata name="ohook" type="property" display="oHook"/>
		<memberdata name="omenu" type="property" display="oMenu"/>
		<memberdata name="release" type="method" display="Release"/>
		<memberdata name="shortcutmenu" type="method" display="ShortcutMenu"/>
		<memberdata name="showmenu" type="method" display="ShowMenu"/>
		<memberdata name="lsetfocustofirstobject" type="property" display="lSetFocusToFirstObject"/>
		</VFPData>		&& XML Metadata for customizable properties
	
	PROCEDURE about		&& Provides documentation for the class
		*==============================================================================
		* Class:						SFPage
		* Based On:						Page
		* Purpose:						Base class for all Page objects
		* Author:						Doug Hennig
		* Copyright:					(c) 2003-2008 Stonefield Systems Group Inc.
		* Last revision:				03/03/2008
		* Include file:					SFCTRLS.H
		*
		* Changes in "Based On" class properties:
		*	FontName:					Tahoma
		*
		* Changes in "Based On" class methods:
		*	Activate:					refresh the controls on the page and
		*								instantiate a member object
		*	Destroy:					nuke member objects
		*	Error:						calls the parent Error method so error handling
		*								goes up the containership hierarchy
		*	Init:						change FontName to Segoe UI in Vista
		*	RightClick:					calls This.ShowMenu
		*
		* Custom public properties added:
		*	Builder:					tells BUILDER.APP the name of a specific
		*								builder to use for this class (specified as
		*								Library,Class)
		*	cMemberClass:				the class for a delayed instantiation member
		*	cMemberLibrary:				the library containing the class specified in
		*								cMemberClass
		*	lSetFocusToFirstObject:		.T. to set focus to the first object on the
		*								page when the page is activated
		*	oException:					a reference to an Exception object
		*	oHook:						a reference to a hooked object
		*	oMenu:						a reference to an SFShortcutMenu object
		*
		* Custom protected properties added:
		*	None
		*
		* Custom public methods added:
		*	About:						provides documentation for the class
		*	Release:					releases the object
		*	Enabled_Assign:				sets the Enabled property of all member objects
		*								to the specified value so they appear to be
		*								enabled or disabled
		*	ShortcutMenu:				populates the shortcut menu
		*	ShowMenu:					display a shortcut menu
		*
		* Custom protected methods added:
		*	None
		*==============================================================================
		
	ENDPROC

	PROCEDURE Activate
		local llLockScreen, ;
			llSave
		with This
		
		* Lock the screen for snappier refreshes.
		
			llLockScreen = Thisform.LockScreen
			if not llLockScreen
				Thisform.LockScreen = .T.
			endif not llLockScreen
		
		* If we're supposed to instantiate a member object and haven't yet done so, do
		* that now.
		
			if not empty(.cMemberClass) and type('.oMember.Name') <> 'C'
				if '\' + upper(.cMemberLibrary) $ set('CLASSLIB')
				 	.AddObject('oMember', .cMemberClass)
				else
				 	.NewObject('oMember', .cMemberClass, .cMemberLibrary)
				endif '\' ...
				llSave = pemstatus(.oMember, 'lSaveAnchor', 5)
				with .oMember
					if llSave
						.lSaveAnchor = .T.
					endif llSave
					.Top     = 10
					.Left    = 10
					.Width   = .Width  + This.Parent.Width  - ;
						Thisform.nInitialWidth
					.Height  = .Height + This.Parent.Height - ;
						Thisform.nInitialHeight
					.Visible = .T.
					if llSave
						.lSaveAnchor = .F.
					endif llSave
					.ZOrder(1)
				endwith
			endif not empty(.cMemberClass) ...
		
		* Refresh all controls.
		
			.Refresh()
		
		* Call Thisform.SetFocusToFirstObject to set focus to the first control on the
		* page if we're supposed to. We may not always want that behavior: the user may
		* select a page to merely view its content while leaving focus on another
		* object that's not in the pageframe. Also, don't do this if the mouse button
		* isn't down; in that case, we were activated from the keyboard.
		
			if .lSetFocusToFirstObject and mdown()
				Thisform.SetFocusToFirstObject(This)
			endif .lSetFocusToFirstObject ...
		
		* Restore the LockScreen setting.
		
			if not llLockScreen
				Thisform.LockScreen = .F.
			endif not llLockScreen
		endwith
		
	ENDPROC

	PROCEDURE Destroy
		* Nuke member objects.
		
		This.oHook = .NULL.
		This.oMenu = .NULL.
		
	ENDPROC

	PROCEDURE enabled_assign		&& Sets the Enabled property of all member objects to the specified value so they appear to be enabled or disabled
		* If the page is enabled or disabled, do the same for every control on the page
		* so they appear enabled or disabled.
		
		lparameters tlEnabled
		with This
			.SetAll('Enabled', tlEnabled)
			.Enabled = tlEnabled
		endwith
		
	ENDPROC

	PROCEDURE Error
		*==============================================================================
		* Method:			Error
		* Status:			Public
		* Purpose:			Handles errors
		* Author:			Doug Hennig
		* Copyright:		(c) 1996-2005 Stonefield Systems Group Inc.
		* Last revision:	12/15/2005
		* Parameters:		tnError  - the error number
		*					tcMethod - the method that caused the error
		*					tnLine   - the line number of the command in error 
		* Returns:			may return an error resolution string (see SFERRORS.H for
		*						a list) or may RETURN, RETRY, or CANCEL
		* Environment in:	if a global error handler object exists, it's in the global
		*						variable oError
		*					a global ON ERROR routine may be in effect
		* Environment out:	depends on the error resolution chosen
		*==============================================================================
		
		lparameters tnError, ;
			tcMethod, ;
			tnLine
		local lnError, ;
			lcMethod, ;
			lnLine, ;
			lcSource, ;
			laError[1], ;
			lcName, ;
			lcOrigMethod, ;
			loParent, ;
			lcReturn, ;
			lcError, ;
			lcMessage, ;
			lnChoice
		
		* Use AERROR() to get information about the error. If we have an Exception
		* object in oException, get information about the error from it.
		
		lnError  = tnError
		lcMethod = tcMethod
		lnLine   = tnLine
		lcSource = message(1)
		aerror(laError)
		with This
			if vartype(.oException) = 'O'
				lnError  = .oException.ErrorNo
				lcMethod = .oException.Procedure
				lnLine   = .oException.LineNo
				lcSource = .oException.LineContents
				laError[cnAERR_NUMBER]  = .oException.ErrorNo
				laError[cnAERR_MESSAGE] = .oException.Message
				laError[cnAERR_OBJECT]  = .oException.Details
				.oException = .NULL.
			endif vartype(.oException) = 'O'
		endwith
		
		* Determine which method of which object the error occurred in. If the error
		* occurred in a child object, the method may already have our name on it, so
		* handle that.
		
		lcName   = upper(This.Name) + '.'
		lcMethod = upper(tcMethod)
		if lcMethod = lcName or '.' + lcName $ lcMethod
			lcOrigMethod = substr(tcMethod, rat('.', tcMethod) + 1)
		else
			lcOrigMethod = tcMethod
		endif lcMethod = lcName ...
		lcMethod = This.Name + '.' + lcOrigMethod
		
		* If we're sitting on a form and that form has a FindErrorHandler method, call
		* it to travel up the containership hierarchy until we find a parent that has
		* code in its Error method. Also, if it has a SetError method, call it now so
		* we don't lose the message information (which gets messed up by TYPE()).
		
		if type('Thisform') = 'O'
			loParent = iif(pemstatus(Thisform, 'FindErrorHandler', 5), ;
				Thisform.FindErrorHandler(This), .NULL.)
			if pemstatus(Thisform, 'SetError', 5)
				Thisform.SetError(lcMethod, lnLine, lcSource, @laError)
			endif pemstatus(Thisform, 'SetError', 5)
		else
			loParent = .NULL.
		endif type('Thisform') = 'O'
		do case
		
		* We have a parent that can handle the error.
		
			case not isnull(loParent)
				lcReturn = loParent.Error(lnError, lcMethod, lnLine)
		
		* We have an error handling object, so call its ErrorHandler() method.
		
			case type('oError.Name') = 'C' and pemstatus(oError, 'ErrorHandler', 5)
				if pemstatus(oError, 'SetError', 5)
					oError.SetError(lcMethod, lnLine, lcSource, @laError)
				endif pemstatus(oError, 'SetError', 5)
				lcReturn = oError.ErrorHandler(lnError, lcMethod, lnLine)
		
		* A global error handler is in effect, so let's pass the error on to it.
		* Replace certain parameters passed to the error handler (the name of the
		* program, the error number, the line number, the message, and SYS(2018)) with
		* the appropriate values.
		
			case not empty(on('ERROR'))
				lcError = upper(on('ERROR'))
				lcError = strtran(lcError, 'SYS(16)',   '"' + lcMethod + '"')
				lcError = strtran(lcError, 'PROGRAM()', '"' + lcMethod + '"')
				lcError = strtran(lcError, ',ERROR()',  ',lnError')
				lcError = strtran(lcError, ' ERROR()',  ' lnError')
				lcError = strtran(lcError, 'LINENO()',  'lnLine')
				lcError = strtran(lcError, 'MESSAGE()', 'laError[2]')
				lcError = strtran(lcError, 'SYS(2018)', 'laError[3]')
		
		* If the error handler is called with DO, macro expand it and assume the return
		* value is "CONTINUE". If the error handler is called as a function (such as an
		* object method), call it and grab the return value if there is one.
		
				if left(lcError, 3) = 'DO ' or '=' $ lcError
					&lcError
					lcReturn = ccMSG_CONTINUE
				else
					lcReturn = &lcError
				endif left(lcError, 3) = 'DO ' ...
		
		* Display a generic dialog box with an option to display the debugger (this
		* should only occur in a test environment).
		
			otherwise
				lcSource  = message(1)
				lcMessage = ccMSG_ERROR_NUM + ' ' + transform(lnError) + ccCR + ;
					ccMSG_MESSAGE + ' ' + laError[cnAERR_MESSAGE] + ccCR + ;
					iif(empty(lcSource), '', ccMSG_CODE + ' ' + lcSource + ;
					ccCR) + iif(lnLine = 0, '', ccMSG_LINE_NUM + ' ' + ;
					transform(lnLine) + ccCR) + ccMSG_METHOD + ' ' + lcMethod
				if version(2) = 0
					lnChoice = messagebox(lcMessage + ccCR + ccCR + ;
						'Choose OK to continue or Cancel to cancel execution', ;
						MB_OKCANCEL + MB_ICONSTOP, _VFP.Caption)
				else
					lnChoice = messagebox(lcMessage + ccCR + ccCR + ;
						'Choose Yes to display the debugger, No to continue ' + ;
						'without the debugger, or Cancel to cancel execution', ;
						MB_YESNOCANCEL + MB_ICONSTOP, _VFP.Caption)
				endif version(2) = 0
				do case
					case lnChoice = IDYES
						lcReturn = ccMSG_DEBUG
					case lnChoice = IDCANCEL
						lcReturn = ccMSG_CANCEL
				endcase
		endcase
		
		* Ensure the return message is acceptable. If not, assume "CONTINUE".
		
		lcReturn = iif(vartype(lcReturn) <> 'C' or empty(lcReturn) or ;
			not lcReturn $ ccMSG_CONTINUE + ccMSG_RETRY + ccMSG_CANCEL + ccMSG_DEBUG, ;
			ccMSG_CONTINUE, lcReturn)
		
		* Handle the return value.
		
		do case
		
		* It wasn't our error, so pass it back to the calling method.
		
			case '.' $ lcOrigMethod
				return lcReturn
		
		* Display the debugger.
		
			case lcReturn = ccMSG_DEBUG
				debug
				if wexist('Visual FoxPro Debugger')
					keyboard '{SHIFT+F7}' plain
				endif wexist('Visual FoxPro Debugger')
				suspend
		
		* Retry the command.
		
			case lcReturn = ccMSG_RETRY
				retry
		
		* Cancel execution.
		
			case lcReturn = ccMSG_CANCEL
				cancel
		
		* Go to the line of code following the error.
		
			otherwise
				return
		endcase
		
	ENDPROC

	PROCEDURE Init
		with This
		
		* Change the font to Segoe UI in Vista.
		
			if os(3) >= '6' and .FontName = 'Tahoma'
				.FontName = 'Segoe UI'
			endif os(3) >= '6' ...
		endwith
		
	ENDPROC

	PROCEDURE release		&& Releases the object
		* Release the object.
		
		release This
		
	ENDPROC

	PROCEDURE RightClick
		* Display a right-click menu.
		
		This.ShowMenu()
		
	ENDPROC

	PROCEDURE shortcutmenu		&& Populates the shortcut menu
		*==============================================================================
		* Method:			ShortcutMenu
		* Status:			Public
		* Purpose:			Populates the specified menu object
		* Author:			Doug Hennig
		* Copyright:		(c) 1996-2003 Stonefield Systems Group Inc.
		* Last revision:	01/25/2003
		* Parameters:		toMenu   - an object reference to a menu object
		*					tcObject - the name of the variable containing the object
		*						reference to this object
		* Returns:			.T.
		* Environment in:	none
		* Environment out:	additional items may have been added to the menu (abstract
		*						in this class)
		*==============================================================================
		
		lparameters toMenu, ;
			tcObject
		
	ENDPROC

	PROCEDURE showmenu		&& Display a shortcut menu
		*==============================================================================
		* Method:			ShowMenu
		* Status:			Public
		* Purpose:			Displays a shortcut menu
		* Author:			Doug Hennig
		* Copyright:		(c) 1996-2004 Stonefield Systems Group Inc.
		* Last revision:	07/20/2004
		* Parameters:		none
		* Returns:			.T.
		* Environment in:	SFMenu.VCX can be found
		* Environment out:	a menu may have been displayed
		*==============================================================================
		
		local lcLibrary
		private loObject, ;
			loHook, ;
			loForm
		with This
		
		* Define reference to objects we might have menu items from in case the action
		* for a bar is to call a method of an object, which can't be done using "This.
		* Method" since "This" isn't applicable in a menu.
		
			loObject = This
			loHook   = .oHook
			loForm   = Thisform
		
		* Define the menu if it hasn't already been defined.
		
			lcLibrary = 'SFMenu.vcx'
			if vartype(.oMenu) <> 'O' and file(lcLibrary)
				.oMenu = newobject('SFShortcutMenu', lcLibrary)
			endif vartype(.oMenu) <> 'O' ...
			if vartype(.oMenu) = 'O'
		
		* If there aren't any bars in the menu, have the ShortcutMenu method populate
		* it.
		
				if .oMenu.nBarCount = 0
					.ShortcutMenu(.oMenu, 'loObject')
		
		* Use the hook object (if there is one) to do any further population of the
		* menu.
		
					if vartype(loHook) = 'O' and pemstatus(loHook, 'ShortcutMenu', 5)
						loHook.ShortcutMenu(.oMenu, 'loHook')
					endif vartype(loHook) = 'O' ...
		
		* If desired, use the form's shortcut menu as well.
		
					if .Parent.lUseFormShortcutMenu and ;
						type('Thisform.Name') = 'C' and ;
						pemstatus(loForm, 'ShortcutMenu', 5)
						loForm.ShortcutMenu(.oMenu, 'loForm')
					endif .Parent.lUseFormShortcutMenu ...
				endif .oMenu.nBarCount = 0
		
		* Activate the menu if necessary.
		
				if .oMenu.nBarCount > 0
					.oMenu.ShowMenu()
				endif .oMenu.nBarCount > 0
			endif vartype(.oMenu) = 'O' ...
		endwith
		
	ENDPROC

ENDDEFINE
