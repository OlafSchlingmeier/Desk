*--------------------------------------------------------------------------------------------------------------------------------------------------------
* (ES) AUTOGENERADO - ¡¡ATENCIÓN!! - ¡¡NO PENSADO PARA EJECUTAR!! USAR SOLAMENTE PARA INTEGRAR CAMBIOS Y ALMACENAR CON HERRAMIENTAS SCM!!
* (EN) AUTOGENERATED - ATTENTION!! - NOT INTENDED FOR EXECUTION!! USE ONLY FOR MERGING CHANGES AND STORING WITH SCM TOOLS!!
*--------------------------------------------------------------------------------------------------------------------------------------------------------
*< FOXBIN2PRG: Version="1.19" SourceFile="_movers.vcx" /> (Solo para binarios VFP 9 / Only for VFP 9 binaries)
*
*
DEFINE CLASS _fieldmover AS _supermover OF "_movers.vcx" 
 	*< CLASSDATA: Baseclass="container" Timestamp="" Scale="Pixels" Uniqueid="" />

	#INCLUDE "_movers.h"
	*<DefinedPropArrayMethod>
		*m: acolscan		&& Scans specific column in array.
		*m: addtoarray		&& Adds item to array.
		*m: alert		&& Displays a messagebox dialog.
		*m: fieldchange		&& Triggered when fields selected changes.
		*m: gettabledata		&& Retrieves fields from table.
		*m: initdata		&& Initializes data.
		*m: initvars		&& Initializes variables used by movers.
		*m: juststem		&& Retrieves filename stem.
		*m: setdataprops		&& Sets data properties.
		*m: updatestatusbar		&& Updates status bar.
		*p: allowreadonly		&& Allows for read-only datasource.
		*p: autoinit		&& Automatically run on load.
		*p: currentalias		&& Current alias determined by ALIAS().
		*p: currentdbc		&& Current database file.
		*p: cursortype		&& Type of cursor. 1-local view, 2-remote view, 3-table.
		*p: dbctable		&& Name of table in DBC.
		*p: multitable		&& Whether to support multiple tables.
		*p: refreshfields
		*p: savemessage
		*p: setfields
		*p: setfieldsglobal
		*p: skiperror
		*p: skipgeneral		&& Do not include General fields in list.
		*p: skipmemo		&& Do not include Memo fields in list.
		*p: tabletype		&& Returns table type - SYS(2029).
	*</DefinedPropArrayMethod>

	allowreadonly = (.F.)		&& Allows for read-only datasource.
	autoinit = (.T.)		&& Automatically run on load.
	currentalias = ("")		&& Current alias determined by ALIAS().
	currentdbc = ("")		&& Current database file.
	cursortype = (3)		&& Type of cursor. 1-local view, 2-remote view, 3-table.
	dbctable = ("")		&& Name of table in DBC.
	Height = 111
	Name = "_fieldmover"
	refreshfields = (.T.)
	setfields = (.F.)
	setfieldsglobal = (.F.)
	skiperror = (.F.)
	skipgeneral = (.F.)		&& Do not include General fields in list.
	skipmemo = (.F.)		&& Do not include Memo fields in list.
	SpecialEffect = 0
	TabIndex = 1
	tabletype = (0)		&& Returns table type - SYS(2029).
	updated = (.F.)
	Width = 264
	cmdadd.Caption = ""
	cmdadd.Enabled = .F.
	cmdadd.Height = 21
	cmdadd.Left = 120
	cmdadd.Name = "cmdadd"
	cmdadd.TabIndex = 2
	cmdadd.Top = 19
	cmdadd.Width = 23
	cmdaddall.Caption = ""
	cmdaddall.Enabled = .F.
	cmdaddall.Height = 21
	cmdaddall.Left = 120
	cmdaddall.Name = "cmdaddall"
	cmdaddall.TabIndex = 3
	cmdaddall.Top = 42
	cmdaddall.Width = 23
	cmdremove.Caption = ""
	cmdremove.Height = 21
	cmdremove.Left = 120
	cmdremove.Name = "cmdremove"
	cmdremove.TabIndex = 4
	cmdremove.Top = 65
	cmdremove.Width = 23
	cmdremoveall.Caption = ""
	cmdremoveall.Height = 21
	cmdremoveall.Left = 120
	cmdremoveall.Name = "cmdremoveall"
	cmdremoveall.TabIndex = 5
	cmdremoveall.Top = 88
	cmdremoveall.Width = 23
	label1.Caption = "\<Available Fields:"
	label1.Height = 14
	label1.Left = 0
	label1.Name = "label1"
	label1.Top = 2
	label1.Width = 124
	label2.Caption = "\<Selected Fields:"
	label2.Height = 14
	label2.Left = 156
	label2.Name = "label2"
	label2.Top = 2
	label2.Width = 124
	lstleft.Height = 95
	lstleft.Left = 0
	lstleft.Name = "lstleft"
	lstleft.TabIndex = 1
	lstleft.Top = 16
	lstleft.Width = 109
	lstright.Height = 95
	lstright.Left = 156
	lstright.Name = "lstright"
	lstright.TabIndex = 6
	lstright.Top = 16
	lstright.Width = 109
	
	PROCEDURE acolscan		&& Scans specific column in array.
		* This function does an ASCAN for a specific row where
		* wztarr - array to scan
		* wztexpr - expression to scan
		* wztcol - column to scan
		
		LPARAMETER wztarr,wztexpr,wztcol
		PRIVATE apos
		IF TYPE('wztcol')#'N'
			wztcol =1
		ENDIF
		m.apos = 1
		DO WHILE .T.
			m.apos = ASCAN(wztarr,m.wztexpr,m.apos)
			DO CASE
			CASE m.apos=0	&&did not find match
				EXIT
			CASE ASUBSCRIPT(wztarr,m.apos,2)=m.wztcol
				EXIT
			OTHERWISE
				m.apos=m.apos+1
			ENDCASE
		ENDDO
		RETURN m.apos
		
	ENDPROC

	PROCEDURE addtoarray		&& Adds item to array.
		* Inserts an array element into an array.
		* For 1-D array
		LPARAMETER aAddToArray,sContents,iRow
		IF ALEN(aAddToArray) = 1 AND EMPTY(aAddToArray[1])
		  aAddToArray[1]=m.sContents
		ELSE
		  DIMENSION aAddToArray[ALEN(aAddToArray)+1,1]
		  IF PARAM()=2
		    aAddToArray[ALEN(aAddToArray)]=m.sContents
		  ELSE
		    =AINS(aAddToArray,iRow+1)
			aAddToArray[m.iRow+1]=m.sContents
		  ENDIF	
		ENDIF
		RETURN
		
	ENDPROC

	PROCEDURE alert		&& Displays a messagebox dialog.
		LPARAMETER pMessage
		LOCAL oldLockScrn
		m.oldLockScrn = THISFORM.LOCKSCREEN
		THISFORM.LOCKSCREEN = .F.
		=MESSAGEBOX(m.pMessage)
		THISFORM.LOCKSCREEN = m.oldLockScrn
		
	ENDPROC

	PROCEDURE Destroy
		IF EMPTY(THIS.SaveMessage)
			SET MESSAGE TO
		ELSE
			SET MESSAGE TO THIS.SaveMessage
		ENDIF
	ENDPROC

	PROCEDURE Error
		LPARAMETERs nError, cMethod, nLine
		
		*- Trap for error opening file
		IF THIS.SKIPERROR
			THIS.ALERT(MESSAGE())
			RETURN
		ENDIF
		
		*- Error
		local cMessage
		m.cMessage = message()
		=MessageBox(ERRORMESSAGE_LOC, MB_ICONEXCLAMATION + MB_OK, ERRORTITLE_LOC)
		
		RETURN TO MASTER
		
	ENDPROC

	PROCEDURE fieldchange		&& Triggered when fields selected changes.
		LPARAMETER nButton
	ENDPROC

	PROCEDURE gettabledata		&& Retrieves fields from table.
		* This routine also assumes that the parent
		* database is already selected upon being called.
		
		LOCAL i,ntmplen,atmpflds,ctmpfld,lSetFields,lSetGlobal
		LOCAL cCalcName,cCalcExpr,lSkipMemo,lSkipGen
		LOCAL aWizFList,aCalcFields,aPickFields, lnNumFields
		
		DIMENSION aWizFList[1]
		DIMENSION aCalcFields[1,2]
		DIMENSION aPickFields[1,1]
		
		STORE "" TO aWizFList
		STORE "" TO aCalcFields
		STORE "" TO aPickFields
		
		m.lSetFields = IIF(TYPE("THIS.SETFIELDS")="L",THIS.SETFIELDS,.F.)
		m.lSetGlobal = IIF(TYPE("THIS.SETFIELDSGLOBAL")="L",THIS.SETFIELDSGLOBAL,.F.)
		m.lSkipMemo = IIF(TYPE("THIS.SKIPMEMO")="L",THIS.SKIPMEMO,.F.)
		m.lSkipGen = IIF(TYPE("THIS.SKIPGENERAL")="L",THIS.SKIPGENERAL,.F.)
		
		THIS.SetDataProps()
		
		* Don't refresh fields
		IF TYPE("THIS.RefreshFields")= "L" AND !THIS.RefreshFields
			RETURN
		ENDIF
		
		* Clear controls if needed
		IF EMPTY(THIS.CurrentAlias)
			THIS.LstLeft.Clear
			THIS.LstLeft.Enabled = .F.
			THIS.cmdAdd.Enabled = .F.
			THIS.cmdAddAll.Enabled = .F.
			IF !THIS.MultiTable
				THIS.LstRight.Clear
				THIS.LstRight.Enabled = .F.
				THIS.cmdRemove.Enabled = .F.
				THIS.cmdRemoveAll.Enabled = .F.
			ENDIF
			RETURN
		ENDIF
		
		
		* Check if SET FIELDS ON originally. Note: this
		* should be OFF during duration of wizard.
		
		DO CASE
		CASE m.lSetFields
			SET FIELDS ON
			* check if they opened a new database with SET FIELDS ON
			IF EMPTY(FLDLIST())
				SET FIELDS OFF
			ENDIF
		CASE SET("FIELDS") = "ON"
			SET FIELDS OFF
		ENDCASE
		
		=AFIELDS(aWizFList)
		
		* Check for Calculated fields
		* Note: SET FIELDS GLOBAL must be on initially.
		IF m.lSetGlobal AND m.lSetFields
			SET FIELDS GLOBAL
			=AFIELDS(aTmpFlds)
			m.i = 1
			DO WHILE !EMPTY(FLDLIST(m.i))
				m.ctmpfld  = FLDLIST(m.i)
				m.cCalcName = ALLTRIM(LEFT(m.ctmpfld ,AT('=',m.ctmpfld )-1))
				m.cCalcExpr = SUBST(m.ctmpfld ,AT('=',m.ctmpfld )+1)
				IF AT('=',m.ctmpfld )#0		&&we have a calculated field
					m.ntmplen=ALEN(aWizFList)
					lnNumFields = ALEN(aWizFList, 2)
					DIMENSION aWizFList[ALEN(aWizFList,1)+1, lnNumFields ]
					=ACOPY(atmpflds,aWizFList, (m.i-1) * lnNumFields+1, lnNumFields, m.ntmplen+1)
					IF !EMPTY(aCalcFields[1,1])
						DIMENSION aCalcFields[ALEN(aCalcFields,1)+1,2]
					ENDIF
					aCalcFields[ALEN(aCalcFields,1),1]=UPPER(m.cCalcName)
					aCalcFields[ALEN(aCalcFields,1),2]=m.cCalcExpr
					m.cCalcExpr=STRTRAN(m.cCalcExpr,'"',"'")
				ENDIF
				m.i = m.i + 1
			ENDDO
			SET FIELDS LOCAL
			SET FIELDS OFF
		ENDIF
		
		* Optimize here if all fields can be used
		IF !_DOS AND !m.lSkipGen AND !m.lSkipMemo
			DIMENSION aPickFields[FCOUNT(),1]
			FOR m.i=1 TO FCOUNT()
				IF LEN(FIELD(m.i)) = LENC(FIELD(m.i))
					aPickFields[m.i,1] = PROPER(FIELD[m.i])
				ELSE
					aPickFields[m.i,1] = FIELD[m.i]
				ENDIF
			ENDFOR
		ELSE
		  FOR m.i=1 TO ALEN(aWizFList,1)
			* Get fields array -- exclude General fields
			* or Memo fields based on property settings.
			DO CASE
			CASE aWizFList[m.i,2]=DT_GENERAL AND (_DOS OR m.lSkipGen)
				LOOP
			CASE aWizFList[m.i,2]=DT_MEMO AND m.lSkipMemo
				LOOP
			ENDCASE
			THIS.AddToArray(@aPickFields,PROPER(aWizFList[m.i,1]))
		  ENDFOR
		ENDIF
		
		THIS.LstLeft.Clear
		IF !THIS.MultiTable
			THIS.LstRight.Clear
		ELSE
			* Check for which fields are already selected
			FOR i = ALEN(aPickFields) TO 1 STEP - 1
				IF ASCAN(THIS.aSelections,ALIAS()+"."+aPickFields[m.i], 1, 3)#0
					IF ALEN(aPickFields) = 1
						aPickFields[1] = ""
					ELSE
						=ADEL(aPickFields,m.i)
						DIMENSION aPickFields[ALEN(aPickFields)-1]
					ENDIF
					IF EMPTY(aPickFields[1])
						THIS.LstLeft.Clear
						THIS.Refresh()
						EXIT
					ENDIF
				ENDIF
			ENDFOR
		ENDIF
		
		IF !EMPTY(aPickFields[1])
			THIS.initChoices(@aPickFields)
			THIS.lstLeft.Value = THIS.lstLeft.List[1]
		ENDIF
		
	ENDPROC

	PROCEDURE Init
		DODEFAULT()
		THIS.SaveMessage = SET("MESSAGE",1)
		IF TYPE("THIS.AUTOINIT") = "L" AND !THIS.AUTOINIT
			THIS.InitVars()
		ELSE
			THIS.InitData()
		ENDIF
		
	ENDPROC

	PROCEDURE initdata		&& Initializes data.
		* This is a stub. Use with subclassed TblMover.
		THIS.InitVars()
		IF EMPTY(ALIAS())
			THIS.SetDataProps()
		ELSE
			THIS.GetTableData()
		ENDIF
		
	ENDPROC

	PROCEDURE initvars		&& Initializes variables used by movers.
		* Initialize instance variables to proper data types
		
		THIS.UPDATED = IIF(TYPE("THIS.UPDATED")="L",THIS.UPDATED ,.F.)
		THIS.ALLOWREADONLY = IIF(TYPE("THIS.ALLOWREADONLY")="L",THIS.ALLOWREADONLY,.F.)
		THIS.SETFIELDS = IIF(TYPE("THIS.SETFIELDS")="L",THIS.SETFIELDS,.F.)
		THIS.SETFIELDSGLOBAL = IIF(TYPE("THIS.SETFIELDSGLOBAL")="L",THIS.SETFIELDSGLOBAL,.F.)
		THIS.SKIPMEMO = IIF(TYPE("THIS.SKIPMEMO")="L",THIS.SKIPMEMO,.F.)
		THIS.SKIPGENERAL = IIF(TYPE("THIS.SKIPGENERAL")="L",THIS.SKIPGENERAL,.F.)
		THIS.SKIPERROR = IIF(TYPE("THIS.SKIPERROR")="L",THIS.SKIPERROR,.F.)
		
		DIMENSION THIS.aSelections[1,2]
		
	ENDPROC

	PROCEDURE juststem		&& Retrieves filename stem.
		* Return just the stem name from "filname"
		LPARAMETERS m.filname
		IF RATC('\',m.filname) > 0
		   m.filname = SUBSTR(m.filname,RATC('\',m.filname)+1,255)
		ENDIF
		IF RATC(':',m.filname) > 0
		   m.filname = SUBSTR(m.filname,RATC(':',m.filname)+1,255)
		ENDIF
		IF AT('.',m.filname) > 0
		   m.filname = SUBSTR(m.filname,1,AT('.',m.filname)-1)
		ENDIF
		RETURN ALLTRIM(UPPER(m.filname))
		
		
	ENDPROC

	PROCEDURE setdataprops		&& Sets data properties.
		* SetDataProps set various data properties
		
		THIS.CurrentAlias = ALIAS()
		THIS.CurrentDBC = IIF(EMPTY(ALIAS()),"",CURSORGETPROP("Database"))
		
		DO CASE
		CASE !EMPTY(THIS.CurrentAlias) AND !EMPTY(THIS.CurrentDBC)
			THIS.DbcTable = UPPER(CURSORGETPROP("SourceName"))	&&name as stored in DBC
			THIS.CursorType = CURSORGETPROP("SourceType")		&&1-local,2-remote,3-table
			THIS.TableType = SYS(2029)							&&3.0 table = 48
		CASE !EMPTY(THIS.CurrentAlias)	&&free table
			THIS.DbcTable = ""
			THIS.CursorType = 3 								&&table
			THIS.TableType = SYS(2029)							&&3.0 table
		OTHERWISE												&&nothing opened
			THIS.DbcTable = ""
			THIS.CursorType = 0
			THIS.TableType = 0
		ENDCASE
		
	ENDPROC

	PROCEDURE updatestatusbar		&& Updates status bar.
		LPARAMETER cArrItem
		LOCAL cTmpAlias,cDBC,cDBCAlias,cSource,aDBC,nPos
		IF THIS.MultiTable AND SET("STATUS BAR") = "ON" AND TYPE("m.cArrItem") = "C"
			cTmpAlias = LEFT(m.cArrItem,AT(".",m.cArrItem)-1)
			IF EMPTY(m.cTmpAlias)
				cTmpAlias = ALIAS()
			ENDIF
			cSource = CURSORGETPROP("sourcename",m.cTmpAlias)
			cDBC = CURSORGETPROP("database",m.cTmpAlias)
			IF !EMPTY(m.cDBC)
				DIMENSION aDBC[1]
				=ADATABASES(aDBC)
				nPos = ASCAN(aDBC,m.cDBC, 1, 3)
				IF nPos # 0
					cDBCAlias = aDBC(m.nPos-1)
				ELSE
					cDBCAlias = ""	
				ENDIF
			ENDIF
			SET MESSAGE TO IIF(EMPTY(m.cDBCAlias),"",PROPER(m.cDBCAlias)+"!") + PROPER(m.cSource)
		ENDIF
	ENDPROC

	PROCEDURE validitem
		LOCAL nGetIdx,nPos
		IF !THIS.MultiTable
			RETURN .T.
		ENDIF
		
		nGetIdx =  THIS.lstright.ItemIdToIndex(THIS.lstRight.ListItemId)
		
		* We must locate correct array element to check
		nPos = ASCAN(THIS.aSelections,THIS.lstRight.ListItemId)
		IF m.nPos = 0
			nPos = m.nGetIdx
		ELSE
			nPos = ASUBSCRIPT(THIS.aSelections,m.nPos,1)
		ENDIF
		
		RETURN ATC(ALIAS()+".",THIS.aSelections[m.nPos,1])#0
	ENDPROC

	PROCEDURE cmdadd.Click
		IF This.Parent.lstLeft.ListIndex = 0 OR EMPTY(THIS.Parent.lstLeft.Value)
			RETURN
		ENDIF
		_SUPERMOVER.cmdAdd::Click()
		
		* Update selected fields array with DBC and Table alias
		IF THIS.Parent.MultiTable
			THIS.Parent.aSelections[ALEN(THIS.Parent.aSelections,1),1] = ;
			ALIAS() + "." + THIS.Parent.aSelections[ALEN(THIS.Parent.aSelections,1),1]
		ENDIF
		
		THIS.Parent.FieldChange(1)
	ENDPROC

	PROCEDURE cmdaddall.Click
		LOCAL nArrLen,i
		nArrLen = IIF(EMPTY(THIS.Parent.aSelections[1]),1,ALEN(THIS.Parent.aSelections,1)+1)
		_SUPERMOVER.cmdAddAll::Click()
		
		* Update for multi fields
		IF THIS.Parent.MultiTable
			FOR i = ALEN(THIS.Parent.aSelections,1) TO m.nArrLen STEP -1
				THIS.Parent.aSelections[m.i,1] = ALIAS() + "." + THIS.Parent.aSelections[m.i,1]
			ENDFOR
		ENDIF
		
		THIS.Parent.FieldChange(2)
	ENDPROC

	PROCEDURE cmdremove.Click
		IF This.Parent.lstRight.ListIndex = 0 OR EMPTY(THIS.Parent.lstRight.Value)
			RETURN
		ENDIF
		_SUPERMOVER.cmdRemove::Click()
		THIS.Parent.FieldChange(3)
	ENDPROC

	PROCEDURE cmdremoveall.Click
		* Remove fields which do not belong to current table first!
		LOCAL i,cValue,lFoundFld
		
		cValue = this.Parent.lstRight.Value
		IF THIS.Parent.MultiTable AND !EMPTY(THIS.Parent.aSelections[1])
			FOR i = ALEN(THIS.Parent.aSelections,1) TO 1 STEP -1
				IF ATC(ALIAS()+".",THIS.Parent.aSelections[m.i,1])=0
					THIS.Parent.lstRight.RemoveItem(m.i)
					IF ALEN(THIS.Parent.aSelections,1) = 1
						THIS.Parent.aSelections[1] = ""
						EXIT
					ELSE
						=ADEL(THIS.Parent.aSelections,m.i)
						DIMENSION THIS.Parent.aSelections[ALEN(THIS.Parent.aSelections,1)-1,2]
					ENDIF
				ENDIF	
			ENDFOR
		ENDIF
		
		_SUPERMOVER.cmdRemoveAll::Click()
		
		* if current value is not a from the current table,
		* default to first item in list
		lFoundFld=.F.
		FOR i = 1 TO this.Parent.lstLeft.ListCount
			IF this.Parent.lstLeft.List[m.i] = m.cValue
				this.Parent.lstLeft.Value = this.Parent.lstLeft.List[m.i]
				this.Parent.lstLeft.listindex = m.i
				lFoundFld=.T.
				EXIT
			ENDIF
		ENDFOR
		IF !m.lFoundFld OR EMPTY(m.cValue)
			this.Parent.lstLeft.Value = this.Parent.lstLeft.List[1]
			this.Parent.lstLeft.listindex = 1
		ENDIF
		
		THIS.Parent.FieldChange(4)
		THIS.Parent.Refresh()
	ENDPROC

	PROCEDURE lstleft.DblClick
		THIS.Parent.cmdAdd.Click()
		
	ENDPROC

	PROCEDURE lstright.DblClick
		THIS.Parent.cmdRemove.Click()
		
	ENDPROC

	PROCEDURE lstright.When
		LOCAL nGetIdx,nPos
		
		IF !THIS.Parent.MultiTable OR THIS.ListItemId = 0
			RETURN
		ENDIF
		
		nGetIdx =  THIS.ItemIdToIndex(THIS.ListItemId)
		
		* We must locate correct array element to check
		nPos = ASCAN(THIS.Parent.aSelections,THIS.ListItemId)
		nPos = IIF(m.nPos = 0,m.nGetIdx,ASUBSCRIPT(THIS.Parent.aSelections,m.nPos,1))
		THIS.Parent.UpdateStatusBar(THIS.Parent.aSelections[m.nPos,1])
	ENDPROC

ENDDEFINE

DEFINE CLASS _mover AS _container OF "_base.vcx" 
 	*< CLASSDATA: Baseclass="container" Timestamp="" Scale="Pixels" Uniqueid="" />

	*-- OBJECTDATA items order determines ZOrder / El orden de los items OBJECTDATA determina el ZOrder 
	*< OBJECTDATA: ObjPath="lstLeft" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="cmdAdd" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="cmdRemove" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="lstRight" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Label1" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Label2" UniqueID="" Timestamp="" />

	#INCLUDE "_movers.h"
	*<DefinedPropArrayMethod>
		*m: getselections		&& Retrieves the selected items.
		*m: initchoices		&& Initialize the choices array.
		*m: initselections		&& Initialize the selections array.
		*m: poplist		&& Routine to populate listboxes.
		*m: sizetocontainer
		*m: validitem
		*p: oldlselecteditem
		*p: oldrselecteditem
		*p: sortleft
		*p: updated
		*p: usearrays		&& Whether to use arrays for listboxes.
		*a: achoices[1,0]		&& Array of available choices in left listbox.
		*a: aselections[1,0]		&& Array of selected items in right listbox.
	*</DefinedPropArrayMethod>

	BackStyle = 0
	BorderWidth = 0
	Height = 108
	Name = "_mover"
	sortleft = .F.
	TabIndex = 1
	updated = .F.
	usearrays = .T.		&& Whether to use arrays for listboxes.
	Width = 377

	ADD OBJECT 'cmdAdd' AS _commandbutton WITH ;
		Caption = "Add >", ;
		Height = 20, ;
		Left = 160, ;
		Name = "cmdAdd", ;
		TabIndex = 2, ;
		Top = 33, ;
		Width = 75
		*< END OBJECT: ClassLib="_base.vcx" BaseClass="commandbutton" />

	ADD OBJECT 'cmdRemove' AS _commandbutton WITH ;
		Caption = "< Remove", ;
		Enabled = .F., ;
		Height = 20, ;
		Left = 160, ;
		Name = "cmdRemove", ;
		TabIndex = 3, ;
		Top = 58, ;
		Width = 75
		*< END OBJECT: ClassLib="_base.vcx" BaseClass="commandbutton" />

	ADD OBJECT 'Label1' AS _label WITH ;
		BackStyle = 0, ;
		Caption = "", ;
		Height = 15, ;
		Left = 0, ;
		Name = "Label1", ;
		Top = 0, ;
		Width = 124
		*< END OBJECT: ClassLib="_base.vcx" BaseClass="label" />

	ADD OBJECT 'Label2' AS _label WITH ;
		BackStyle = 0, ;
		Caption = "", ;
		Height = 15, ;
		Left = 251, ;
		Name = "Label2", ;
		Top = 0, ;
		Width = 124
		*< END OBJECT: ClassLib="_base.vcx" BaseClass="label" />

	ADD OBJECT 'lstLeft' AS _listbox WITH ;
		Height = 92, ;
		Left = 0, ;
		Name = "lstLeft", ;
		Sorted = .T., ;
		TabIndex = 1, ;
		Top = 15, ;
		Width = 143
		*< END OBJECT: ClassLib="_base.vcx" BaseClass="listbox" />

	ADD OBJECT 'lstRight' AS _listbox WITH ;
		Height = 92, ;
		Left = 256, ;
		MoverBars = .T., ;
		Name = "lstRight", ;
		TabIndex = 4, ;
		Top = 15, ;
		Width = 121
		*< END OBJECT: ClassLib="_base.vcx" BaseClass="listbox" />
	
	PROCEDURE getselections		&& Retrieves the selected items.
		parameters aSelections
		private i
		if this.lstRight.ListCount > 0
			dimension aSelections[this.lstRight.ListCount,1]
			for m.i = 1 to alen(aSelections,1)
				aSelections[m.i,1] = this.lstRight.List[m.i]
			endfor
		endif
		return this.lstRight.ListCount
		
	ENDPROC

	PROCEDURE Init
		DIMENSION THIS.aSelections[1,2]
		DIMENSION THIS.aChoices[1]
		
	ENDPROC

	PROCEDURE initchoices		&& Initialize the choices array.
		lparameters aChoices
		
		LOCAL lSorted
		lSorted = IIF(TYPE("this.sortleft")="L",this.sortleft,.T.)
		
		IF THIS.UseArrays	&&using arrays
			DIMENSION THIS.aChoices[1,1]
			=ACOPY(aChoices,THIS.aChoices)
			IF m.lSorted
				=ASORT(THIS.aChoices)
			ENDIF
			this.lstLeft.rowsourcetype = 5						&&array
			this.lstLeft.rowsource = "THIS.Parent.aChoices"		&&array
		ELSE
			this.lstLeft.sorted = .F.
			THIS.POPLIST(@aChoices,this.lstLeft)
			IF m.lSorted
				this.lstLeft.sorted = .T.
			ENDIF
		ENDIF
		
		this.lstLeft.ListItemID = this.lstLeft.IndexToItemID[1]
		this.Refresh()
	ENDPROC

	PROCEDURE initselections		&& Initialize the selections array.
		LPARAMETERS aSelections
		LOCAL i
		THIS.POPLIST(@aSelections,this.lstRight)
		this.lstRight.ListItemID = this.lstLeft.IndexToItemID[1]
		
		DIMENSION this.aSelections[ALEN(aSelections),2]
		FOR i = 1 TO ALEN(aSelections)
			this.aSelections[m.i,1] = aSelections[m.i]
			this.aSelections[m.i,2] = m.i
		ENDFOR
		THIS.Refresh()
	ENDPROC

	PROCEDURE poplist		&& Routine to populate listboxes.
		* this routine is used to expedite the process of
		* populating a Listbox using the AddItem method
		* for RowSourceType = 0.
		LPARAMETER aListArray,oLstRef
		EXTERNAL ARRAY aListArray
		
		Local nStep, cTmpListStr, i
		private cTmpListStr,i,m.nStep
		m.cTmpListStr = ""
		m.i = 0
		
		*--v-darylm modified 9/8/99
		*--added support for singly dimensioned arrays
		m.nStep = alen(aListArray,2)
		for m.i= 1 to alen(aListArray) step Iif(m.nStep==0,1,m.nStep)
			m.oLstRef.AddItem(aListArray[m.i])
		endfor
		
		*!*		for m.i=1 to alen(aListArray,1)
		*!*			m.oLstRef.AddItem(aListArray[m.i,1])
		*!*		endfor
		
	ENDPROC

	PROCEDURE Refresh
		if type("this.oldLSelectedItem")='L'
			this.oldLSelectedItem=0
		endif
		if type("this.oldRSelectedItem")='L'
			this.oldRSelectedItem=0
		endif
		
		if this.lstLeft.ListCount = 0 AND this.lstRight.ListCount = 0
			this.lstLeft.Enabled = .F.
			this.lstRight.Enabled = .F.
		else
			this.lstLeft.Enabled = .T.
			this.lstRight.Enabled = .T.
		endif
		
		if this.lstLeft.ListCount = 0
			this.cmdAdd.Enabled = .f.
		else
			this.cmdAdd.Enabled = .t.
			if this.oldLSelectedItem>0
				this.lstLeft.ListIndex=this.oldLSelectedItem
				if this.lstLeft.ListIndex=0
					this.lstLeft.ListIndex=this.oldLSelectedItem-1
					if this.lstLeft.ListIndex=0
						this.lstLeft.ListIndex=1
					endif
				endif
			endif
		endif
		
		if this.lstRight.ListCount = 0
			this.cmdRemove.Enabled = .f.
		else
			this.cmdRemove.Enabled = .t.
			if this.oldRSelectedItem>0
				this.lstRight.ListIndex=this.oldRSelectedItem
				if this.lstRight.ListIndex=0
					this.lstRight.ListIndex=this.oldRSelectedItem-1
					if this.lstRight.ListIndex=0
						this.lstRight.ListIndex=1
					endif
				endif
			endif
		endif
		this.oldLSelectedItem=0
		this.oldRSelectedItem=0
		
	ENDPROC

	PROCEDURE sizetocontainer
		private m.iScaleMode
		m.iScaleMode = thisform.ScaleMode
		thisform.ScaleMode = 3 && Pixels
		
		if empty(this.Label1.Caption)
			this.Label1.Height = 0
		endif
		this.Label2.Height = this.Label1.Height
		this.Label1.Top = 0
		this.Label2.Top = 0
		
		this.lstLeft.Top = this.Label1.Height
		this.lstRight.Top = this.lstLeft.Top
		this.lstLeft.Height = this.Height - this.Label1.Height
		this.lstRight.Height = this.lstLeft.Height
		this.lstLeft.Width = int((this.Width - this.cmdAdd.Width - 36) / 2)
		this.lstRight.Width = this.lstLeft.Width
		this.lstLeft.Left = 0
		this.lstRight.Left = this.Width - this.lstRight.Width
		this.Label2.Left = this.lstRight.Left
		
		this.Label1.Width = this.lstLeft.Width
		this.Label2.Width = this.Label1.Width
		
		this.cmdAdd.Left = int((this.Width - this.cmdAdd.Width) / 2)
		this.cmdRemove.Left = this.cmdAdd.Left
		this.cmdRemove.Height = this.cmdAdd.Height
		this.cmdRemove.Width = this.cmdAdd.Width
		this.cmdAdd.Top = this.Label1.Height + ;
			int((this.lstLeft.Height - ((this.cmdAdd.Height * 2) + 6)) / 2)
		this.cmdRemove.Top = this.cmdAdd.Top + this.cmdAdd.Height + 6
		
		thisform.ScaleMode = m.iScaleMode
		
	ENDPROC

	PROCEDURE validitem
		* Stub here, but is used by TBLMOVER under certain conditions
		* to prevent item from being added back to left list. For example,
		* where the item is a field which is not part of the current table.
		
		RETURN .T.
	ENDPROC

	PROCEDURE cmdAdd.Click
		LOCAL cLstIdx
		IF EMPTY(this.Parent.lstLeft.value) OR this.Parent.lstLeft.Listindex = 0
			RETURN
		ENDIF
		
		this.Parent.Updated = .t.
		
		cLstIdx = this.Parent.lstLeft.ListIndex
		
		* Add item to Selections listbox
		this.Parent.lstRight.AddItem(this.Parent.lstLeft.List[m.cLstIdx])
		
		* Add Item to aSelections array
		IF !EMPTY(this.parent.aSelections[1])
			DIMENSION this.parent.aSelections[ALEN(this.parent.aSelections,1)+1,2]
		ENDIF
		this.parent.aSelections[ALEN(this.parent.aSelections,1),1] = this.Parent.lstLeft.List[m.cLstIdx]
		this.parent.aSelections[ALEN(this.parent.aSelections,1),2] = ;
			this.Parent.lstRight.IndexToItemID[this.Parent.lstRight.ListCount]
		
		* Set hilited item to last item in list
		this.Parent.lstRight.ListItemID = ;
			this.Parent.lstRight.IndexToItemID[this.Parent.lstRight.ListCount]
		this.parent.oldLSelectedItem = m.cLstIdx
		
		* Remove item from Choices listbox
		IF THIS.Parent.UseArrays	&&using arrays
			IF ALEN(this.parent.aChoices)=1
				this.Parent.lstLeft.clear()
			ELSE
				=ADEL(this.parent.aChoices,m.cLstIdx)
				DIMENSION this.parent.aChoices[ALEN(this.parent.aChoices)-1]
				this.Parent.lstLeft.rowsource = "this.parent.aChoices"
			ENDIF
		ELSE
			this.Parent.lstLeft.RemoveItem(m.cLstIdx)
		ENDIF
		
		this.Parent.Refresh()
		
	ENDPROC

	PROCEDURE cmdRemove.Click
		PARAMETER nPosition
		
		LOCAL cLstIdx,nLstPos, nPos
		cLstIdx = this.Parent.lstRight.ListIndex
		
		nLstPos = IIF(PCOUNT()#0 AND TYPE("m.nPosition")="N",nPosition,0)
		
		IF EMPTY(this.Parent.lstRight.value) OR this.Parent.lstRight.listindex = 0
			RETURN
		ENDIF
		
		this.Parent.Updated = .t.
		
		* Add item to left list
		IF THIS.Parent.ValidItem()		&& but allows one to bypass adding item back
		  IF THIS.Parent.UseArrays	&&using array
			IF !EMPTY(this.parent.aChoices)
				DIMENSION this.parent.aChoices[ALEN(this.parent.aChoices)+1]
			ENDIF
			this.parent.aChoices[ALEN(this.parent.aChoices)] = this.Parent.lstRight.List[m.cLstIdx]
		*!*		IF this.parent.lstLeft.sorted
			IF this.parent.sortLeft
				=ASORT(this.parent.aChoices)
			ENDIF
			this.Parent.lstLeft.rowsourcetype = 5
			this.Parent.lstLeft.rowsource = "this.parent.aChoices"
		  ELSE
		    IF nLstPos = 0
				this.Parent.lstLeft.AddListItem(this.Parent.lstRight.List[m.cLstIdx])
				this.Parent.lstLeft.ListItemID = ;
				this.Parent.lstLeft.IndexToItemID[this.Parent.lstLeft.ListCount]
			ELSE
				this.Parent.lstLeft.AddItem(this.Parent.lstRight.List[m.cLstIdx],m.nLstPos)
				this.Parent.lstLeft.ListItemID = ;
				this.Parent.lstLeft.IndexToItemID[1]
			ENDIF
		  ENDIF
		  this.Parent.lstLeft.Value = this.Parent.lstRight.List[m.cLstIdx]
		ENDIF
		
		* Reset selections array
		IF ALEN(this.parent.aSelections,1) = 1
			this.parent.aSelections[1,1] = ""
		ELSE
			* We must find the right one
			nPos = ASCAN(this.parent.aSelections,this.Parent.lstRight.ListItemId)
			IF m.nPos # 0
				nPos = ASUBSCRIPT(this.parent.aSelections,m.nPos,1)
			ELSE
				nPos = this.Parent.lstRight.ListItemId
			ENDIF
			=ADEL(this.parent.aSelections,m.nPos)
			DIMENSION this.parent.aSelections[ALEN(this.parent.aSelections,1)-1,2]
		ENDIF
		
		* Remove item from list on right
		this.parent.oldRSelectedItem = this.Parent.lstRight.ListIndex
		this.Parent.lstRight.RemoveItem(m.cLstIdx)
		
		this.Parent.Refresh
		
	ENDPROC

	PROCEDURE lstLeft.Clear
		DIMENSION this.parent.aChoices[1]
		this.parent.aChoices[1] = ""
		this.rowsourcetype = 0
		this.value = ""
		
	ENDPROC

	PROCEDURE lstLeft.DblClick
		this.Parent.cmdAdd.Click
		
	ENDPROC

	PROCEDURE lstLeft.Init
		this.value=""
		
	ENDPROC

	PROCEDURE lstLeft.InteractiveChange
		IF EMPTY(THIS.VALUE)
			THIS.VALUE = THIS.LIST[1]
		ENDIF
		
	ENDPROC

	PROCEDURE lstLeft.OLEDragDrop
		LPARAMETERS oDataObject, nEffect, nButton, nShift, nXCoord, nYCoord
		LOCAL oFoxControl
		IF oDataObject.GetFormat("VFP Source Object")
			oFoxControl = oDataObject.GetData("VFP Source Object")
			IF UPPER(oFoxControl.Name) = "LSTRIGHT"
				this.Parent.cmdRemove.Click()
			ENDIF
		ENDIF	
		
	ENDPROC

	PROCEDURE lstRight.Clear
		DIMENSION this.parent.aSelections[1,2]
		this.parent.aSelections[1] = ""
		
	ENDPROC

	PROCEDURE lstRight.DblClick
		this.Parent.cmdRemove.Click
		
	ENDPROC

	PROCEDURE lstRight.Init
		this.value=""
	ENDPROC

	PROCEDURE lstRight.InteractiveChange
		IF EMPTY(THIS.VALUE)
			THIS.VALUE = THIS.LIST[1]
		ENDIF
	ENDPROC

	PROCEDURE lstRight.OLEDragDrop
		LPARAMETERS oDataObject, nEffect, nButton, nShift, nXCoord, nYCoord
		LOCAL oFoxControl
		IF oDataObject.GetFormat("VFP Source Object")
			oFoxControl = oDataObject.GetData("VFP Source Object")
			IF UPPER(oFoxControl.Name) = "LSTLEFT"
				this.Parent.cmdAdd.Click()
			ENDIF
		ENDIF	
		
	ENDPROC

ENDDEFINE

DEFINE CLASS _sortmover AS _mover OF "_movers.vcx" 
 	*< CLASSDATA: Baseclass="container" Timestamp="" Scale="Pixels" Uniqueid="" />

	*-- OBJECTDATA items order determines ZOrder / El orden de los items OBJECTDATA determina el ZOrder 
	*< OBJECTDATA: ObjPath="Optiongroup1" UniqueID="" Timestamp="" />

	#INCLUDE "_movers.h"
	*<DefinedPropArrayMethod>
		*m: updatemover
		*p: currentalias		&& Current alias for field choices.
		*p: currentdbc		&& Current database for field choices.
		*p: maxfields		&& Maximum number of fields allowed.
		*p: showtags		&& Whether to show existing index tags in addition to fields.
		*p: tagname
		*a: atags[1,1]
	*</DefinedPropArrayMethod>

	currentalias = ("")		&& Current alias for field choices.
	currentdbc = ("")		&& Current database for field choices.
	Height = 138
	maxfields = (3)		&& Maximum number of fields allowed.
	Name = "_sortmover"
	TabIndex = 1
	tagname = ("")
	Width = 466
	cmdAdd.Caption = "A\<dd >"
	cmdAdd.Enabled = .F.
	cmdAdd.Height = 22
	cmdAdd.Left = 195
	cmdAdd.Name = "cmdAdd"
	cmdAdd.TabIndex = 3
	cmdAdd.Top = 31
	cmdAdd.Width = 73
	cmdRemove.Caption = "< \<Remove"
	cmdRemove.Height = 22
	cmdRemove.Left = 195
	cmdRemove.Name = "cmdRemove"
	cmdRemove.TabIndex = 4
	cmdRemove.Top = 60
	cmdRemove.Width = 73
	Label1.Caption = "\<Available fields or index tag:"
	Label1.Height = 15
	Label1.Left = 0
	Label1.Name = "Label1"
	Label1.TabIndex = 1
	Label1.Top = 0
	Label1.Width = 157
	Label2.Caption = "\<Selected fields:"
	Label2.Height = 15
	Label2.Left = 291
	Label2.Name = "Label2"
	Label2.TabIndex = 6
	Label2.Top = 0
	Label2.Width = 124
	lstLeft.Height = 123
	lstLeft.ItemTips = .T.
	lstLeft.Left = 0
	lstLeft.Name = "lstLeft"
	lstLeft.TabIndex = 2
	lstLeft.Top = 15
	lstLeft.Width = 175
	lstRight.Height = 123
	lstRight.ItemTips = .T.
	lstRight.Left = 291
	lstRight.Name = "lstRight"
	lstRight.TabIndex = 7
	lstRight.Top = 15
	lstRight.Width = 175

	ADD OBJECT 'Optiongroup1' AS _optiongroup WITH ;
		BackStyle = 0, ;
		ButtonCount = 2, ;
		Height = 36, ;
		Left = 190, ;
		Name = "Optiongroup1", ;
		TabIndex = 5, ;
		Top = 88, ;
		Width = 89, ;
		Option1.Caption = "As\<cending", ;
		Option1.Height = 19, ;
		Option1.Left = 0, ;
		Option1.Name = "Option1", ;
		Option1.TabIndex = 1, ;
		Option1.Top = 0, ;
		Option1.Value = 0, ;
		Option1.Width = 86, ;
		Option2.Caption = "D\<escending", ;
		Option2.Height = 19, ;
		Option2.Left = 0, ;
		Option2.Name = "Option2", ;
		Option2.TabIndex = 2, ;
		Option2.Top = 18, ;
		Option2.Value = 0, ;
		Option2.Width = 94
		*< END OBJECT: ClassLib="_base.vcx" BaseClass="optiongroup" />
	
	PROCEDURE Refresh
		DODEFAULT()
		LOCAL nPos
		* don't re-enable it if already disabled.
		IF THIS.cmdAdd.Enabled
			If ATC(TAGDELIM,THIS.lstRight.Value)#0 AND ;
				This.ShowTags AND THIS.lstRight.ListCount > 0
				* check if we have a tag selected
				nPos = ASCAN(THIS.aTags,THIS.lstRight.Value)
				IF m.nPos # 0
					THIS.cmdAdd.Enabled = .F.
					THIS.TagName = THIS.aTags[m.nPos+1]
				ENDIF
			ENDIF
			IF THIS.cmdAdd.Enabled
				THIS.cmdAdd.Enabled = (THIS.lstRight.ListCount<THIS.MAXFIELDS)
			ENDIF
		ENDIF
		
		THIS.OptionGroup1.Enabled = !EMPTY(THIS.lstLeft.ListCount) OR !EMPTY(THIS.lstRight.ListCount)
		
	ENDPROC

	PROCEDURE updatemover
		* Use this routine if you want to show tags and fields in the Sort Mover.
		* The routine assumes that you have set the CurrentAlias property.
		
		LOCAL aTagList,nTotalTags,i,nSaveAlias
		LOCAL aFlds,olstref
		IF EMPTY(ALIAS()) OR EMPTY(THIS.CurrentAlias)
			RETURN
		ENDIF
		
		nSaveAlias = ALIAS()
		IF ALIAS() # UPPER(THIS.CurrentAlias)
			SELECT (This.CurrentAlias)
		ENDIF
		
		THIS.ShowTags = .T.
		THIS.UseArrays = .F.
		THIS.TagName = ""
		
		This.lstRight.CLEAR()
		
		m.oLstRef = This.lstLeft
		m.oLstRef.Clear()
		m.oLstRef.Sorted = .F.
		m.oLstRef.Value = ""
		
		* Add index tags if available
		DIMENSION aTagList[1]
		aTagList[1] = ""
		nTotalTags = TAGCOUNT('')
		DIMENSION aFlds[1]
		=AFIELDS(aFlds)
		DIMENSION THIS.aTags[1]
		THIS.aTags[1] = ""
		
		* Add regular fields checking to see if first in taglist
		FOR i = 1 TO ALEN(aFlds,1)
			IF INLIST(aFlds[m.i,2],"M","G")
				* skip memo and general fields
				LOOP
			ELSE
				m.oLstRef.AddItem(PROPER(aFlds[m.i,1]))
			ENDIF
		ENDFOR
		
		* Add index tags
		IF m.nTotalTags  > 0
			DIMENSION aTagList[m.nTotalTags]
			DIMENSION THIS.aTags[m.nTotalTags,2]
			IF m.oLstRef.Listcount>0
				m.oLstRef.AddItem("\-")
			ENDIF
			FOR i = 1 TO m.nTotalTags
				aTagList[m.i] = KEY(m.i)
				THIS.aTags[m.i,1] = LOWER(KEY(m.i))+TAGDELIM
				THIS.aTags[m.i,2] = LOWER(TAG(m.i))
				m.oLstRef.AddItem(LOWER(KEY(m.i))+TAGDELIM)
			ENDFOR
		ENDIF
		
		IF m.oLstRef.ListCount > 0
			m.oLstRef.ListIndex = 1
		ENDIF
		
		THIS.Refresh()
		
		SELECT (m.nSaveAlias)
	ENDPROC

	PROCEDURE cmdAdd.Click
		
		IF TYPE('THIS.PARENT.MAXFIELDS') # 'N'
			THIS.PARENT.MAXFIELDS = 0	&&unlimited field default
		ENDIF
		
		* Check if they exceeded max fields.
		IF THIS.PARENT.MAXFIELDS # 0 AND;
		   THIS.PARENT.lstRight.ListCount=THIS.PARENT.MAXFIELDS
			=MESSAGEBOX(C_MAXFIELDS_LOC+ALLTRIM(STR(THIS.PARENT.MAXFIELDS)))
			RETURN
		ENDIF
		
		* Check if user wants to combine fields and tags
		IF THIS.PARENT.ShowTags AND THIS.PARENT.lstRight.ListCount>0 AND ;
			ATCC(TAGDELIM,THIS.PARENT.lstLeft.Value)#0
			IF ASCAN(THIS.PARENT.aTags,THIS.PARENT.lstLeft.Value)#0 OR;
					ASCAN(THIS.PARENT.aTags,THIS.PARENT.lstRight.List[1])#0
				=MESSAGEBOX(C_NOTAG_LOC)
				RETURN
			ENDIF
		ENDIF
		
		_MOVER.cmdAdd::Click
		
	ENDPROC

	PROCEDURE cmdRemove.Click
		IF This.Parent.ShowTags
			THIS.Parent.TagName = ""
			IF ASCAN(THIS.Parent.aTags,THIS.Parent.lstRight.Value)=0
				_MOVER.cmdRemove::Click(1)
				RETURN		
			ENDIF
		ENDIF
		_MOVER.cmdRemove::Click
	ENDPROC

ENDDEFINE

DEFINE CLASS _supermover AS _mover OF "_movers.vcx" 
 	*< CLASSDATA: Baseclass="container" Timestamp="" Scale="Pixels" Uniqueid="" />

	*-- OBJECTDATA items order determines ZOrder / El orden de los items OBJECTDATA determina el ZOrder 
	*< OBJECTDATA: ObjPath="cmdAddAll" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="cmdRemoveAll" UniqueID="" Timestamp="" />

	#INCLUDE "_movers.h"
	*<DefinedPropArrayMethod>
		*p: maxitems		&& Maximum number of items that can be selected.
		*p: maxmessage		&& Message to display if maximum items reached.
	*</DefinedPropArrayMethod>

	Height = 108
	maxitems = 0		&& Maximum number of items that can be selected.
	maxmessage = ("")		&& Message to display if maximum items reached.
	Name = "_supermover"
	Width = 371
	cmdadd.Caption = ""
	cmdadd.Height = 21
	cmdadd.Left = 179
	cmdadd.Name = "cmdadd"
	cmdadd.Picture = graphics\add.bmp
	cmdadd.TabIndex = 3
	cmdadd.Top = 16
	cmdadd.Width = 23
	cmdremove.Caption = ""
	cmdremove.Height = 21
	cmdremove.Left = 179
	cmdremove.Name = "cmdremove"
	cmdremove.Picture = graphics\remove.bmp
	cmdremove.TabIndex = 5
	cmdremove.Top = 63
	cmdremove.Width = 23
	label1.Left = 0
	label1.Name = "label1"
	label1.TabIndex = 1
	label1.Top = 0
	label2.Left = 251
	label2.Name = "label2"
	label2.TabIndex = 7
	label2.Top = 0
	lstleft.Left = 0
	lstleft.Name = "lstleft"
	lstleft.TabIndex = 2
	lstleft.Top = 15
	lstright.Left = 251
	lstright.Name = "lstright"
	lstright.TabIndex = 8
	lstright.Top = 15

	ADD OBJECT 'cmdAddAll' AS _commandbutton WITH ;
		Caption = "", ;
		Height = 21, ;
		Left = 179, ;
		Name = "cmdAddAll", ;
		Picture = graphics\addall.bmp, ;
		TabIndex = 4, ;
		Top = 38, ;
		Width = 23
		*< END OBJECT: ClassLib="_base.vcx" BaseClass="commandbutton" />

	ADD OBJECT 'cmdRemoveAll' AS _commandbutton WITH ;
		Caption = "", ;
		Enabled = .F., ;
		Height = 21, ;
		Left = 179, ;
		Name = "cmdRemoveAll", ;
		Picture = graphics\remall.bmp, ;
		TabIndex = 6, ;
		Top = 85, ;
		Width = 23
		*< END OBJECT: ClassLib="_base.vcx" BaseClass="commandbutton" />
	
	PROCEDURE Init
		#DEFINE C_MAXREC1_LOC	"You cannot select more than "
		#DEFINE C_MAXREC2_LOC	" items."
		
		IF TYPE("THIS.MaxItems")#"N" OR THIS.MaxItems<0
			THIS.MaxItems=0
		ENDIF
		IF TYPE("THIS.MaxMessage")#"C" OR EMPTY(THIS.MaxMessage)
			THIS.MaxMessage = C_MAXREC1_LOC+ALLTRIM(STR(THIS.MaxItems))+C_MAXREC2_LOC
		ENDIF
		
		DODEFAULT()
	ENDPROC

	PROCEDURE Refresh
		DODEFAULT()
		if this.lstLeft.ListCount = 0
			this.cmdAddAll.Enabled = .f.
			this.cmdAddAll.default = .f.
		else
			this.cmdAddAll.Enabled = .t.
		endif
		
		if this.lstRight.ListCount = 0
			this.cmdRemoveAll.Enabled = .f.
			this.cmdRemoveAll.default = .f.
		else
			this.cmdRemoveAll.Enabled = .t.
		endif
	ENDPROC

	PROCEDURE sizetocontainer
		private iScaleMode
		
		m.iScaleMode = thisform.ScaleMode
		thisform.ScaleMode = 3 && Pixels
		
		* If the labels are unused, set the Height to 0
		if empty(this.Label1.Caption)
			this.Label1.Height = 0
		endif
		this.Label2.Height = this.Label1.Height
		this.Label1.Top = 0
		this.Label2.Top = 0
		
		this.lstLeft.Top = this.Label1.Height
		this.lstRight.Top = this.lstLeft.Top
		this.lstLeft.Height = this.Height - this.Label1.Height
		this.lstRight.Height = this.lstLeft.Height
		this.lstLeft.Width = int((this.Width - this.cmdAdd.Width - 36) / 2)
		this.lstRight.Width = this.lstLeft.Width
		this.lstLeft.Left = 0
		this.lstRight.Left = this.Width - this.lstRight.Width
		this.Label2.Left = this.lstRight.Left
		
		this.Label1.Width = this.lstLeft.Width
		this.Label2.Width = this.Label1.Width
		
		this.cmdAdd.Left = int((this.Width - this.cmdAdd.Width) / 2)
		this.cmdAddAll.Left = this.cmdAdd.Left
		this.cmdRemove.Left = this.cmdAdd.Left
		this.cmdRemoveAll.Left = this.cmdAdd.Left
		
		this.cmdAddAll.Height = this.cmdAdd.Height
		this.cmdRemove.Height = this.cmdAdd.Height
		this.cmdRemoveAll.Height = this.cmdAdd.Height
		this.cmdAddAll.Width = this.cmdAdd.Width
		this.cmdRemove.Width = this.cmdAdd.Width
		this.cmdRemoveAll.Width = this.cmdAdd.Width
		
		
		this.cmdAdd.Top = this.Label1.Height + ;
			int((this.lstLeft.Height - ((this.cmdAdd.Height * 4) + 3)) / 2)
		this.cmdAddAll.Top = this.cmdAdd.Top + this.cmdAdd.Height + 1
		this.cmdRemove.Top = this.cmdAddAll.Top + this.cmdAddAll.Height + 1
		this.cmdRemoveAll.Top = this.cmdRemove.Top + this.cmdRemove.Height + 1
		
		thisform.ScaleMode = m.iScaleMode
		
		
		
	ENDPROC

	PROCEDURE cmdadd.Click
		* Check for maxitems
		IF this.Parent.MaxItems>0 AND;
		 (THIS.Parent.lstRight.ListCount+1)>this.Parent.MaxItems
			IF !EMPTY(THIS.Parent.MaxMessage) AND TYPE("THIS.Parent.MaxMessage")="C"
				MESSAGEBOX(THIS.Parent.MaxMessage)
			ENDIF
			RETURN
		ENDIF
		DODEFAULT()
	ENDPROC

	PROCEDURE cmdAddAll.Click
		LOCAL aListItems,lSorted,nTmpLen,nTmpLen2,cValue,i
		IF this.Parent.lstLeft.ListCount = 0
			RETURN
		ENDIF
		
		* Check for maxitems
		IF this.Parent.MaxItems>0 AND;
		 (THIS.Parent.lstLeft.ListCount+THIS.Parent.lstRight.ListCount) > this.Parent.MaxItems
			IF !EMPTY(THIS.Parent.MaxMessage) AND TYPE("THIS.Parent.MaxMessage")="C"
				MESSAGEBOX(THIS.Parent.MaxMessage)
			ENDIF
			RETURN
		ENDIF
		
		THISFORM.LOCKSCREEN = .T.
		
		lSorted = this.Parent.lstRight.Sorted
		this.Parent.lstRight.Sorted = .F.
		cValue = this.Parent.lstLeft.Value
		
		IF THIS.Parent.UseArrays
			DIMENSION aListItems[ALEN(THIS.Parent.aChoices,1),1]
			=ACOPY(THIS.Parent.aChoices,aListItems)
		ELSE
			DIMENSION aListItems[this.Parent.lstLeft.ListCount,1]
			FOR m.i = 1 to this.Parent.lstLeft.ListCount
				aListItems[m.i,1] = this.Parent.lstLeft.List[m.i]
			ENDFOR
		ENDIF
		
		this.Parent.lstLeft.clear()
		THIS.Parent.POPLIST(@aListItems,this.Parent.lstRight)
		this.Parent.Updated = .t.
		
		* Test for valid setting
		IF this.Parent.lstRight.listitemid = 0
			this.Parent.lstRight.listitemid = 1
		ENDIF
		
		IF this.Parent.lstRight.ListCount = 0 OR EMPTY(THIS.Parent.aSelections[1])
			DIMENSION THIS.Parent.aSelections[ALEN(aListItems,1),2]
			FOR i = 1 TO ALEN(aListItems,1)
				THIS.Parent.aSelections[m.i,1] = aListItems[m.i]
				THIS.Parent.aSelections[m.i,2] = m.i	&& this assumes that Sorted is set off
			ENDFOR
		ELSE
			nTmpLen = ALEN(THIS.Parent.aSelections,1)+1
			nTmpLen2 = ALEN(THIS.Parent.aSelections,1) + ALEN(aListItems,1)
		
			DIMENSION THIS.Parent.aSelections[m.nTmpLen2,2]
			FOR i = m.nTmpLen TO m.nTmpLen2
				THIS.Parent.aSelections[m.i,1] = aListItems[m.i+1-m.nTmpLen]
				THIS.Parent.aSelections[m.i,2] = THIS.Parent.LstRight.IndexToItemId(m.i)
			ENDFOR
		ENDIF
		
		IF m.lSorted
			this.Parent.lstRight.Sorted = .T.
		ENDIF
		
		this.Parent.lstRight.Value = m.cValue
		
		this.Parent.Refresh
		THISFORM.LOCKSCREEN = .F.
		
	ENDPROC

	PROCEDURE cmdRemoveAll.Click
		LOCAL aListItems,lSorted,nArrLen,cValue,i
		IF this.Parent.lstRight.ListCount = 0
			RETURN
		ENDIF
		THISFORM.LOCKSCREEN = .T.
		lSorted = this.parent.sortLeft
		*v-darylm: lSorted = this.Parent.lstLeft.Sorted
		cValue = this.Parent.lstRight.Value
		
		DIMENSION aListItems[this.Parent.lstRight.ListCount,1]
		for m.i = 1 to this.Parent.lstRight.ListCount
			aListItems[m.i,1] = this.Parent.lstRight.List[m.i]
		endfor
		
		IF This.Parent.UseArrays
			IF this.Parent.lstLeft.ListCount = 0
				DIMENSION THIS.Parent.aChoices[1]
				=ACOPY(aListItems,THIS.Parent.aChoices)
			ELSE
				nArrLen = ALEN(THIS.Parent.aChoices,1)+1
				DIMENSION THIS.Parent.aChoices[ALEN(THIS.Parent.aChoices,1)+ALEN(aListItems,1)]
				=ACOPY(aListItems,THIS.Parent.aChoices,1,-1,m.nArrLen)
			ENDIF
			IF m.lSorted
				=ASORT(THIS.Parent.aChoices)
			ENDIF
			this.Parent.lstLeft.RowSourceType = 5
			this.Parent.lstLeft.RowSource = "THIS.Parent.aChoices"
		ELSE
			this.Parent.lstLeft.Sorted = .F.			&& performance is better with Sorted off
			this.Parent.POPLIST(@aListItems,this.Parent.lstLeft)
			IF m.lSorted
				this.Parent.lstLeft.Sorted = .T.
			ENDIF
		ENDIF
		
		this.Parent.lstRight.Clear
		this.Parent.Updated = .t.
		this.parent.lstleft.value = m.cValue
		
		* Test for valid setting
		IF this.Parent.lstleft.listitemid = 0
			this.Parent.lstleft.listitemid = 1
		ENDIF
		
		
		this.Parent.Refresh
		THISFORM.LOCKSCREEN = .F.
		
	ENDPROC

ENDDEFINE

DEFINE CLASS _tablemover AS _fieldmover OF "_movers.vcx" 
 	*< CLASSDATA: Baseclass="container" Timestamp="" Scale="Pixels" Uniqueid="" />

	*-- OBJECTDATA items order determines ZOrder / El orden de los items OBJECTDATA determina el ZOrder 
	*< OBJECTDATA: ObjPath="cboData" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="lstTables" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Label3" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="cmdOpen" UniqueID="" Timestamp="" />

	#INCLUDE "_movers.h"
	*<DefinedPropArrayMethod>
		*m: getdbcalias		&& Retrieves DBC alias.
		*m: getdbcdata		&& Retrieves DBC table fields.
		*m: getdbcname		&& Retrieves DBC name.
		*m: getdbctable		&& Retrieves DBC table.
		*m: getfreedata		&& Retrieves free table fields.
		*m: moverrefresh		&& Refreshes movers.
		*m: opentable		&& Routine opens datasource.
		*m: tablechange
		*m: usetable		&& Handles USEing datasource.
		*p: allowquery		&& Whether to allow queries.
		*p: allowviews		&& Whether to allow views.
		*p: excldbf		&& Name of table to exclude from list.
		*p: exclusiveset
		*p: lpublicsinuse
		*p: refreshcurrent
		*p: viewnodata		&& Whether to show view information without retreiving data.
	*</DefinedPropArrayMethod>

	allowquery = (.F.)		&& Whether to allow queries.
	allowviews = (.T.)		&& Whether to allow views.
	dbctable = ("")
	excldbf = ("")		&& Name of table to exclude from list.
	exclusiveset = 0
	Height = 140
	Name = "_tablemover"
	refreshcurrent = (.T.)
	refreshfields = (.T.)
	SpecialEffect = 2
	viewnodata = (.T.)		&& Whether to show view information without retreiving data.
	Width = 466
	cmdadd.Left = 298
	cmdadd.Name = "cmdadd"
	cmdadd.TabIndex = 7
	cmdadd.Top = 34
	cmdadd.Width = 22
	cmdaddall.Left = 298
	cmdaddall.Name = "cmdaddall"
	cmdaddall.TabIndex = 8
	cmdaddall.Top = 57
	cmdaddall.Width = 22
	cmdremove.Left = 298
	cmdremove.Name = "cmdremove"
	cmdremove.TabIndex = 9
	cmdremove.Top = 80
	cmdremove.Width = 22
	cmdremoveall.Left = 298
	cmdremoveall.Name = "cmdremoveall"
	cmdremoveall.TabIndex = 10
	cmdremoveall.Top = 103
	cmdremoveall.Width = 22
	label1.Caption = "\<Available fields:"
	label1.Height = 14
	label1.Left = 152
	label1.Name = "label1"
	label1.TabIndex = 5
	label1.Top = 2
	label1.Width = 106
	label2.Caption = "\<Selected fields:"
	label2.Height = 14
	label2.Left = 332
	label2.Name = "label2"
	label2.TabIndex = 11
	label2.Top = 2
	label2.Width = 106
	lstleft.Height = 123
	lstleft.ItemTips = .T.
	lstleft.Left = 152
	lstleft.Name = "lstleft"
	lstleft.TabIndex = 6
	lstleft.Top = 16
	lstleft.Width = 133
	lstright.Height = 123
	lstright.ItemTips = .T.
	lstright.Left = 332
	lstright.Name = "lstright"
	lstright.TabIndex = 12
	lstright.Top = 16
	lstright.Width = 133

	ADD OBJECT 'cboData' AS _combobox WITH ;
		Height = 25, ;
		Left = 0, ;
		Name = "cboData", ;
		Style = 2, ;
		TabIndex = 2, ;
		Top = 16, ;
		Width = 114
		*< END OBJECT: ClassLib="_base.vcx" BaseClass="combobox" />

	ADD OBJECT 'cmdOpen' AS _commandbutton WITH ;
		Caption = "...", ;
		Height = 23, ;
		Left = 121, ;
		Name = "cmdOpen", ;
		TabIndex = 3, ;
		Top = 17, ;
		Width = 22
		*< END OBJECT: ClassLib="_base.vcx" BaseClass="commandbutton" />

	ADD OBJECT 'Label3' AS _label WITH ;
		BackStyle = 0, ;
		Caption = "\<Databases and tables:", ;
		Height = 13, ;
		Left = 0, ;
		Name = "Label3", ;
		TabIndex = 1, ;
		Top = 1, ;
		Width = 133
		*< END OBJECT: ClassLib="_base.vcx" BaseClass="label" />

	ADD OBJECT 'lstTables' AS _listbox WITH ;
		Height = 92, ;
		ItemTips = .T., ;
		Left = 0, ;
		Name = "lstTables", ;
		TabIndex = 4, ;
		Top = 47, ;
		Width = 143
		*< END OBJECT: ClassLib="_base.vcx" BaseClass="listbox" />
	
	PROCEDURE Destroy
		DODEFAULT()
		IF !THIS.lPublicsInUse
			RELEASE aDBFList,aDBCList,aSkipTables
		ENDIF
	ENDPROC

	PROCEDURE Error
		Parameters nError, cMethod, nLine
		
		*- handle conversion of old DBC files containing 2.5 tables
		IF THIS.SKIPERROR
			IF nError = 1977
				USE (m.cGetDBF) EXCLUSIVE
				RETURN
			ENDIF
		ENDIF
		
		* Otherwise pass things along
		DODEFAULT(nError, cMethod, nLine)
		
	ENDPROC

	PROCEDURE getdbcalias		&& Retrieves DBC alias.
		* Takes the current DBC and gets its alias name
		* cDBC - DBC name passed if not current DBC()
		
		LPARAMETER cDBC
		
		LOCAL aDBCtmp,cGetDBC,nPos
		
		IF TYPE("m.cDBC") # "C"
			m.cDBC  =""
		ENDIF
		
		IF EMPTY(m.cDBC) AND EMPTY(DBC())
			RETURN ""
		ENDIF
		
		m.cGetDBC = IIF(EMPTY(m.cDBC),DBC(),UPPER(m.cDBC))
		
		DIMENSION aDBCtmp[1,2]
		=ADATA(aDBCtmp)
		m.nPos = ASCAN(aDBCtmp,m.cGetDBC)
		
		RETURN IIF(m.nPos = 0,"",aDBCtmp[m.nPos-1])
		
	ENDPROC

	PROCEDURE getdbcdata		&& Retrieves DBC table fields.
		* Parameter is short name passed -- not DBC()
		* DBC() should already be open so just select it. Since Wizards are modal,
		* we can prevent user from manually closing a DBC.
		
		LPARAMETERS cDBCName
		
		LOCAL nDBCCount,i,cTmpListStr,nScanPos,cTmpAlias,nViewCount
		LOCAL aTmpArr,aTmpArr2,aDBCTables,nTblCount,cTmpView,cOldExcl 
		DIMENSION aTmpArr[1]
		DIMENSION aTmpArr2[1]
		DIMENSION aDBCTables[1]
		m.cTmpAlias = ""
		m.cTmpListStr = ""
		
		m.cDBCName = ALLTRIM(m.cDBCName)
		
		IF EMPTY(m.cDBCName)
			RETURN
		ENDIF
		
		SET DATABASE TO (m.cDBCName)
		
		*- Quick Check to make sure DBC open and selected
		IF EMPTY(DBC())  			&& Should never happen unless somehow closed while in moverlist.
			* Try to open it
			cOldExcl = SET("EXCL")
			DO CASE 
			CASE TYPE("THIS.ExclusiveSet")#"N"
			CASE THIS.ExclusiveSet = 1
				SET EXCLUSIVE OFF
			CASE THIS.ExclusiveSet = 2
				SET EXCLUSIVE ON
			ENDCASE	
			OPEN DATA (m.cDBCName)	&& note -- we don't keep track of DBC paths so we can only go by what's in list
			SET EXCLUSIVE &cOldExcl
			IF EMPTY(DBC())  		&& had an error
				RETURN
			ENDIF
		ENDIF
		
		THIS.CurrentDBC = DBC()		&& set current DBC property
		
		*- Update Dropdown list only if necessary
		IF THIS.cboData.ListCount=0  && no free table entry in list
			THIS.cboData.AddItem(C_FREETABLE_LOC)
		ENDIF
		IF THIS.cboData.ListCount=1  && new database
			THIS.cboData.AddItem("\-")
		ENDIF
		FOR i = 1 TO THIS.cboData.ListCount
			IF ALLTRIM(THIS.cboData.listitem[m.i]) = m.cDBCName
				EXIT
			ENDIF
		ENDFOR
		IF ALLTRIM(THIS.cboData.listitem[m.i]) # m.cDBCName
			THIS.cboData.AddItem(m.cDBCName)
		ENDIF
		
		THIS.cboData.VALUE = m.cDBCName
		
		*- Update listboxes
		m.nDBCCount = ADBOBJ(aTmpArr,"TABLE")		&& get tables
		m.nViewCount = ADBOBJ(aTmpArr2,"VIEW")		&& get views
		
		* Skip for views
		IF !THIS.AllowViews
			 m.nViewCount = 0
		ENDIF
		
		IF m.nViewCount > 1
			* sort by view type
			FOR i = m.nViewCount TO 1 STEP -1
				IF DBGETPROP(aTmpArr2[m.i],"view","sourcetype") = 2  && remote view
					m.cTmpView = aTmpArr2[m.i]
					=ADEL(aTmpArr2,m.i)
					aTmpArr2[m.nViewCount] = m.cTmpView			
				ENDIF
			ENDFOR
		ENDIF
		
		IF m.nDBCCount+m.nViewCount = 0  && no tables in DBC
			SELECT 0
		ELSE
			DIMENSION aDBCTables[m.nDBCCount+m.nViewCount,2]
			FOR i = 1 TO m.nDBCCount
				aDBCTables[m.i,1] = aTmpArr[m.i]				&& name
				aDBCTables[m.i,2] = FULL(DBGETPROP(aTmpArr[m.i],'TABLE','path'),DBC())
			ENDFOR
			FOR i = 1 TO m.nViewCount
				aDBCTables[m.i+m.nDBCCount,1] = aTmpArr2[m.i]
				aDBCTables[m.i+m.nDBCCount,2] = aTmpArr2[m.i]	&& name
			ENDFOR
		ENDIF
		
		* Reset controls
		THIS.lstTables.CLEAR()
		IF THIS.RefreshFields
			THIS.lstLeft.CLEAR()
			THIS.cmdAdd.Enabled = .F.
			THIS.cmdAddAll.Enabled = .F.
			IF !THIS.MultiTable
				THIS.lstRight.CLEAR()
				THIS.cmdRemove.Enabled = .F.
				THIS.cmdRemoveAll.Enabled = .F.
			ENDIF
		ENDIF
		
		IF m.nDBCCount > 0
			* Update Tables List with ADBOBJ contents
			* Exclude aSkipTables items
			FOR i = 1 TO m.nDBCCount
				IF ASCAN(aSkipTables,aDBCTables[m.i,2])#0 OR;
					aDBCTables[m.i,2]==UPPER(THIS.ExclDBF)
					LOOP
				ENDIF
					this.lstTables.AddItem(UPPER(aDBCTables[m.i,1]))
			ENDFOR
		
			* Add Tables list BMPS
			THIS.lstTables.Picture[0] = BMP_TABLE
		ENDIF
		
		m.nTblCount = THIS.lstTables.ListCount
		
		IF m.nViewCount > 0
			* Update Tables List with ADBOBJ contents
			* Exclude aSkipTables items
			m.cTmpListStr = ""
			FOR i = 1 TO m.nViewCount
				IF UPPER(aTmpArr2[m.i])==UPPER(THIS.ExclDBF)
					LOOP
				ENDIF
					this.lstTables.AddItem(UPPER(aTmpArr2[m.i]))
			ENDFOR
		
			FOR i = (m.nTblCount+1) TO THIS.lstTables.ListCount
				IF DBGETPROP(ALLTRIM(THIS.lstTables.List[m.i]),"view","sourcetype") = 1  &&local view
					THIS.lstTables.Picture[m.i] = BMP_LOCAL
				ELSE
					THIS.lstTables.Picture[m.i] = BMP_REMOTE
				ENDIF
			ENDFOR
		ENDIF
		
		* Test if selected DBF is in DBC or excluded
		IF !EMPTY(ALIAS())
			IF THIS.GetDBCName() == DBC() AND;
				ASCAN(aSkipTables,DBF()) = 0 AND;
				UPPER(THIS.ExclDBF) # DBF()
		
				DO CASE
				CASE CURSORGETPROP("SourceType") = 3		&& normal table
					m.nScanPos = ASCAN(aDBCTables,DBF())
					IF m.nScanPos # 0
						THIS.DBCTable = aDBCTables[m.nScanPos-1]
						THIS.lstTables.Value = THIS.DBCTable
					ELSE
						SELECT 0	&& we have unknown reference to alias which could not be resolved
					ENDIF
				OTHERWISE
					* Have a view here
					m.nScanPos = ASCAN(aTmpArr2,ALIAS())
					IF !THIS.AllowViews OR m.nScanPos = 0
						SELECT 0
					ELSE
						THIS.DBCTable = ALIAS()
						THIS.lstTables.Value = THIS.DBCTable
					ENDIF
				ENDCASE
			ELSE
				SELECT 0  && in case we fail -- for next step
			ENDIF
		ENDIF
		
		* Now try to select/open a table in ADBOBJ array
		IF EMPTY(ALIAS())
			FOR i = 1 TO (m.nDBCCount+m.nViewCount)
				IF ASCAN(aSkipTables,aDBCTables[m.i,2]) # 0 OR;
					 UPPER(THIS.ExclDBF)==aDBCTables[m.i,2]
					LOOP
				ENDIF
				THIS.GetDBCTable(aDBCTables[m.i,1])
				IF !EMPTY(ALIAS())
					THIS.DBCTable = aDBCTables[m.i,1]
					THIS.lstTables.Value = THIS.DBCTable
					EXIT
				ENDIF
			ENDFOR
		ENDIF
		
		IF !EMPTY(ALIAS())
			THIS.GetTableData()	&& populate field listboxes
		ENDIF
		
		THIS.lstTables.Enabled = (THIS.lstTables.ListCount#0)
		
		* Quick check
		IF THIS.lstTables.ListCount#0 AND THIS.lstTables.ListIndex=0
			THIS.lstTables.ListIndex = 1
		ENDIF
	ENDPROC

	PROCEDURE getdbcname		&& Retrieves DBC name.
		lparameters xx
		LOCAL m.Retval
		
		IF TYPE("m.XX") = 'L'
			xx = select()
		ENDIF
		
		m.retval = CursorGetProp("database",m.xx)
		IF !EMPTY(m.retval)	AND !EMPTY(DBC()) && could be a repackaged cursor: check if in dbc()
			IF CursorGetProp("sourcetype",m.xx) = 3 AND !INDBC(CursorGetProp("sourcename",m.xx),"table")  OR ;
				CursorGetprop("sourcetype",m.xx) # 3 AND !INDBC(CursorGetProp("sourcename",m.xx),"view")
				m.retval=""
			ENDIF
		ENDIF
		
		RETURN m.retval
		
	ENDPROC

	PROCEDURE getdbctable		&& Retrieves DBC table.
		LPARAMETER cDBCTable		&&this is shortname of table
		
		LOCAL cDBFName,aTmpArr,m.i
		
		DIMENSION aTmpArr[1]
		m.cDBFName = ""
		
		DO CASE
		CASE aDBOBJ(aTmpArr,"table")>0 AND ASCAN(aTmpArr,UPPER(m.cDBCTable), 1, 3)#0
			m.cDBFName = FULL(DBGETPROP(m.cDBCTable,'TABLE','path'),DBC())
			FOR m.i = 1 TO ALEN(aDBCList,1)
				IF !EMPTY(aDBCList[m.i,1]) AND CursorGetProp("sourcetype",aDBCList[m.i,2]) = 3 AND ;
						m.cDBFName == aDBCList[m.i,1]
					SELECT (aDBCList[m.i,2])
					RETURN
				ENDIF
			ENDFOR
		CASE aDBOBJ(aTmpArr,"view")>0 AND ASCAN(aTmpArr,UPPER(m.cDBCTable), 1, 3)#0
			m.cDBFName = UPPER(m.cDBCTable)
			FOR m.i = 1 TO ALEN(aDBCList,1)
				IF !EMPTY(aDBCList[m.i,1]) AND CursorGetProp("sourcetype",aDBCList[m.i,2]) # 3 AND ;
						 m.cDBFName == aDBCList[m.i,1]		&& it's a view 
					SELECT (aDBCList[m.i,2])
					RETURN
				ENDIF
			ENDFOR
		OTHERWISE
			RETURN
		ENDCASE
		
		* Try to open file
		THIS.USETABLE(m.cDBFName)
		
		* Quick test to see if we have a valid DBF (i.e., Backlink)
		IF !EMPTY(ALIAS()) AND EMPTY(THIS.GetDBCName())
			THIS.ALERT(E_BADDBCTABLE_LOC)
		ENDIF
	ENDPROC

	PROCEDURE getfreedata		&& Retrieves free table fields.
		LOCAL cCurrData,nCount
		cCurrData = SET("DATABASE")
		SET DATABASE TO
		
		IF THIS.cboData.ListCount=0  &&no free table entry in list
			THIS.cboData.AddItem(C_FREETABLE_LOC)
		ENDIF
		THIS.cboData.Value=C_FREETABLE_LOC
		THIS.lstTables.Clear()
		THIS.lstTables.Picture[0] = ""		&&no bmp for tables
		
		IF !EMPTY(aDBFList[1])
			IF UPPER(THIS.ExclDBF)==DBF()
				SELECT 0
			ENDIF
			FOR nCount =  1 TO ALEN(aDBFList,1)
				IF UPPER(THIS.ExclDBF)==UPPER(aDBFList[m.nCount,1])
					LOOP
				ENDIF
				THIS.lstTables.AddItem(aDBFList[m.nCount,2])
				IF EMPTY(ALIAS())
					IF USED(aDBFList[m.nCount,2])
						SELECT (aDBFList[m.nCount,2])
					ENDIF
				ENDIF
			ENDFOR
			THIS.lstTables.Value = ALIAS()
		ELSE
			SELECT 0
		ENDIF
		
		* Populate fields list
		THIS.GetTableData()
		
		* Quick check
		IF THIS.lstTables.ListCount#0 AND THIS.lstTables.ListIndex=0
			THIS.lstTables.ListIndex = 1
		ENDIF
		
		IF !THIS.lstTables.ENABLED AND !EMPTY(ALIAS())
			THIS.lstTables.ENABLED = .T.
		ENDIF
		
	ENDPROC

	PROCEDURE Init
		IF TYPE("aSkipTables")#"U"
			THIS.lPublicsInUse = .T.	
		ENDIF
		DoDefault()
	ENDPROC

	PROCEDURE initdata
		LOCAL nTotWorkAreas,nCount,i,cCurrDBC,aDBC,nWorkArea
		LOCAL cOldExact,nTotTables,lIsInDBC,aWorkAreas
		
		* Setup custom properties and arrays
		THIS.INITVARS
		THIS.ADDTOARRAY(@aSkipTables,"FORMSTYLES")
		DIMENSION aDBFList[1,2]
		DIMENSION aDBCList[1,2]
		DIMENSION aWorkAreas[1]
		DIMENSION aDBC[1]
		STORE "" TO aDBFList,aDBCList,aDBC,aWorkAreas
		cOldExact = SET("EXACT")
		SET EXACT ON
		m.lIsInDBC = .F.
		
		* Need to transform aSkipTables from Aliases to DBFs for DBC tables
		FOR i = 1 TO ALEN(aSkipTables,1)
			IF !EMPTY(aSkipTables[m.i,1]) AND USED(aSkipTables[m.i,1])
				aSkipTables[m.i] = DBF(aSkipTables[m.i,1])
			ENDIF
		ENDFOR
		
		* Add Free Table DBC popup items
		THIS.cboData.AddItem(C_FREETABLE_LOC)
		THIS.cboData.Value = C_FREETABLE_LOC
		m.nDBCCount=ADATABASES(aDBC)
		FOR i = 1 TO m.nDBCCount
			* Add bar for popup
			IF m.i = 1
				THIS.cboData.AddItem("\-")
			ENDIF
			THIS.cboData.AddItem(aDBC[m.i,1])
		ENDFOR
		
		* Go thru workareas and see which tables open
		m.nTotWorkAreas = AUSED(aWorkAreas)
		FOR m.nCount = 1 TO m.nTotWorkAreas
			m.nWorkArea = aWorkAreas[m.nCount,2]
		
			* Avoid specific tables used by wizard and not in a DBC
			DO CASE
			CASE ASCAN(aSkipTables,DBF(m.nWorkArea))#0
				LOOP
			CASE ISREADONLY(m.nWorkArea) AND !THIS.AllowReadOnly
				* skip for read-only tables and queries
				LOOP
			CASE EMPTY(THIS.GetDBCName(m.nWorkArea))
				* Add to free tables list
				IF ATC(".TMP",DBF(m.nWorkArea))#0 AND !THIS.AllowQuery
					LOOP
				ENDIF
				IF !EMPTY(aDBFList[1])
					DIMENSION aDBFList[ALEN(aDBFList,1)+1,2]
				ENDIF
				aDBFList[ALEN(aDBFList,1),1] = DBF(m.nWorkArea)
				aDBFList[ALEN(aDBFList,1),2] = ALIAS(m.nWorkArea)
			OTHERWISE
				* Need to determine if its a Table, Local View or Remote View
				* Add to DBC tables list
				IF !THIS.AllowViews AND CURSORGETPROP("sourcetype",m.nWorkArea)#3
					LOOP
				ENDIF
				IF !EMPTY(aDBCList[1])
					DIMENSION aDBCList[ALEN(aDBCList,1)+1,2]
				ENDIF
				IF CURSORGETPROP("sourcetype",m.nWorkArea)#3	&&handle view here
					aDBCList[ALEN(aDBCList,1),1] = UPPER(CURSORGETPROP("sourcename",m.nWorkArea))
				ELSE
					aDBCList[ALEN(aDBCList,1),1] = DBF(m.nWorkArea)
				ENDIF
				aDBCList[ALEN(aDBCList,1),2] = ALIAS(m.nWorkArea)
			ENDCASE
		ENDFOR
		
		=ASORT(aDBFList,1)
		
		*- Now try to select a specific table
		*- Default order for choosing:
		*- 1. Open in current workarea
		*- 2. Selected DBC()
		*- 3. First free table
		*- 4. First DBC
		
		*- Get Selected Table, Database info
		THIS.CurrentDBC = DBC()
		m.cCurrDBC = ""		&& DBCAlias of selected ALIAS() -- not necessarily same as current DBC
		
		* See if we need to skip selected alias
		IF !EMPTY(ALIAS())
			DO CASE
			CASE  ASCAN(aSkipTables,DBF())# 0
				* Check if table selected in aSkipTables array
				SELECT 0
			CASE !THIS.AllowReadOnly AND ISREADONLY()
				* Skip if read-only file
				SELECT 0
			CASE EMPTY(THIS.GetDBCName()) AND !THIS.AllowQuery AND ATC(".TMP",DBF()) # 0
				* Skip for FoxPro 2.6 Cursors
				SELECT 0
			CASE !THIS.AllowViews AND CURSORGETPROP("sourcetype")#3
				* Skip if a view
				SELECT 0
			ENDCASE
		ENDIF
		
		
		* Try to select a table
		DO CASE
		CASE !EMPTY(ALIAS())	&& use alias already selected
			m.cCurrDBC = THIS.GetDBCName()  && returns DBC
			m.lIsInDBC = !EMPTY(m.cCurrDBC)
			IF m.lIsInDBC AND DBC()#m.cCurrDBC	 	&& make sure we have right DBC selected
				SET DATABASE TO (m.cCurrDBC)
			ENDIF
		CASE !EMPTY(DBC())							&& use current DBC
			m.lIsInDBC = .T.
		CASE !EMPTY(aDBFList[1])					&& use first available free table
			SELECT (aDBFList[1,2])
		CASE !EMPTY(aDBC[1])						&& use first available DBC
			m.lIsInDBC = .T.
			SET DATABASE TO (aDBC[1])
		ENDCASE
		
		IF m.lIsInDBC AND !EMPTY(ALIAS())
			LOCAL csName
			csName = CURSORGETPROP('sourcename')
			IF THIS.ALLOWQUERY AND ATC(".TMP",DBF())#0 ;
				AND m.csName # ALIAS() AND USED(m.csName);
				AND m.csName # DBF()
				IF !EMPTY(aDBFList[1])
					DIMENSION aDBFList[ALEN(aDBFList,1)+1,2]
				ENDIF
				aDBFList[ALEN(aDBFList,1),1] = DBF()
				aDBFList[ALEN(aDBFList,1),2] = ALIAS()
				m.lIsInDBC = .f.
			ENDIF
		ENDIF
		
		IF m.lIsInDBC
			*Populate object with DBC data
			THIS.CurrentDBC = DBC()
			THIS.cboData.Value = THIS.GetDBCAlias()
			THIS.GetDBCData(THIS.cboData.Value)
		ELSE
			*Populate object with Free Table data
			THIS.GetFreeData()
		ENDIF
		
		* Check if no tables found for table list
		IF THIS.lstTables.ListCount = 0
			THIS.lstTables.enabled= .F.
			THIS.lstLeft.enabled= .F.
			THIS.lstRight.enabled= .F.
		ENDIF
		
		SET EXACT &cOldExact
		
	ENDPROC

	PROCEDURE initvars
		DODEFAULT()
		
		THIS.ExclDBF = IIF(TYPE("THIS.ExclDBF")="C",THIS.ExclDBF,"")
		THIS.RefreshFields = IIF(TYPE("THIS.RefreshFields")="L",THIS.RefreshFields,.T.)
		THIS.ViewNoData = IIF(TYPE("THIS.ViewNoData")="L",THIS.ViewNoData,.T.)
		THIS.AllowViews = IIF(TYPE("THIS.AllowViews")="L",THIS.AllowViews,.T.)
		THIS.AllowQuery = IIF(TYPE("THIS.AllowQuery")="L",THIS.AllowQuery,.F.)
		
		* aSkipTables is array of aliases to skip -- those
		* which may be used by Wizard itself.
		
		PUBLIC aSkipTables,aDBFList,aDBCList
		
		* see if already defined since we are using Public for now
		IF TYPE("aSkipTables[1]") # "C"
			DIMENSION aSkipTables[1]
			aSkipTables = ""
		ENDIF
		
		IF TYPE("aDBFList[1]") # "C"
			DIMENSION aDBFList[1,2]
			aDBFList= ""
		ENDIF
		
		IF TYPE("aDBCList[1]") # "C"
			DIMENSION aDBCList[1,2]
			aDBCList = ""
		ENDIF
		
	ENDPROC

	PROCEDURE moverrefresh		&& Refreshes movers.
		* This routine refreshes mover list
		LPARAMETER lRefresh,lQuickPass,cSaveLstValue 
		LOCAL lOldRefresh,aTmpData,i,aPopItems
		
		* lRefresh - calls TblMover routines which repopulate lstTables and popups
		* lQuickPass - does a quick restore and returns if environment stayed same
		
		
		m.lOldRefresh = IIF(TYPE("THIS.RefreshFields")="L",THIS.RefreshFields,.T.)
		m.lQuickPass = IIF(TYPE("m.lQuickPass")="L",m.lQuickPass,.F.)
		
		THIS.RefreshFields = IIF(PARAMETER()#0 AND TYPE("m.lRefresh")="L",m.lRefresh,m.lOldRefresh)
		
		THIS.RefreshCurrent = IIF(TYPE("THIS.RefreshCurrent")="L",THIS.RefreshCurrent,.T.)
		
		IF THIS.RefreshCurrent &&update to current DBC,ALIAS()
			THIS.CurrentDBC = DBC()
			THIS.CurrentAlias = ALIAS()
		ENDIF
		
		* Update dropdown list if necessary
		DIMENSION aTmpData[1,2]
		DIMENSION aPopItems[1]
		STORE "" TO aTmpData,aPopItems
		IF ADATA(aTmpData)>0
			IF THIS.cboData.ListCount=0  &&no free table entry in list
				THIS.cboData.AddItem(C_FREETABLE_LOC)
			ENDIF
			IF THIS.cboData.ListCount=1  &&free table only in list
				THIS.cboData.AddItem("\-")
			ENDIF
			DIMENSION aPopItems[THIS.cboData.ListCount]
			FOR i = 1 TO THIS.cboData.ListCount
				aPopItems[m.i] = ALLTRIM(THIS.cboData.listitem[m.i])
			ENDFOR
			FOR i = 1 TO ALEN(aTmpData,1)
				IF ASCAN(aPopItems,aTmpData[m.i,1]) = 0
					THIS.cboData.AddItem(aTmpData[m.i,1])
				ENDIF
			ENDFOR
		ENDIF
		
		* Restore necessary data
		IF !EMPTY(THIS.CurrentAlias)
			IF USED(THIS.CurrentAlias)
				SELECT (THIS.CurrentAlias)
			ELSE
				THIS.RefreshFields = .T.
				THIS.CurrentAlias= ""
				SELECT 0
			ENDIF
		ELSE
			THIS.RefreshFields = .T.	
		ENDIF
		
		IF !EMPTY(THIS.CurrentAlias) AND THIS.ExclDBF==DBF(THIS.CurrentAlias)
			THIS.RefreshFields = .T.
			THIS.CurrentAlias= ""
			SELECT 0
		ENDIF
		
		cSaveLstValue = IIF(EMPTY(THIS.CurrentAlias),"",THIS.lstTables.Value)
		
		IF !EMPTY(THIS.CurrentDBC)
			*- Handle DBC Table
			SET DATABASE TO (THIS.CurrentDBC)
			IF THIS.RefreshFields OR !m.lQuickPass
				THIS.cboData.Value = THIS.GetDBCAlias()
				THIS.GetDBCData(THIS.cboData.Value)
			ENDIF
		ELSE
			*- Handle free tables
			THIS.GetFreeData()
		ENDIF
		
		IF !EMPTY(m.cSaveLstValue)
			THIS.lstTables.Value = m.cSaveLstValue 
		ENDIF
		
		THIS.RefreshFields = m.lOldRefresh
		
	ENDPROC

	PROCEDURE opentable		&& Routine opens datasource.
		LOCAL cGetDBF,sOldSafe,nPos,cOldExcl
		LOCAL sOldArea,cCurrDBC,cTmpDbc
		
		m.sOldSafe=SET('SAFETY')
		SET SAFETY OFF		&& needed for missing CDX file error
		m.sOldArea = SELECT()
		m.cCurrDBC=DBC()
		SET DATABASE TO
		
		DO WHILE .T.
		
			m.cGetDBF=""
			m.cGetDBF = GETFILE('DBF|DBC',C_TPROMPT_LOC)
			IF EMPTY(m.cGetDBF)
				* Reset -- user canceled out
				IF EMPTY(m.cCurrDBC)
					SET DATABASE TO
				ELSE
					SET DATABASE TO (m.cCurrDBC)
				ENDIF
				SELECT (m.sOldArea)
				EXIT
			ENDIF
		
			* Check if excluded file picked
			IF ASCAN(aSkipTables,m.cGetDBF, 1, 3) # 0 OR UPPER(THIS.ExclDBF)==m.cGetDBF
				m.cGetDBF=""
				IF EMPTY(m.cCurrDBC)
					SET DATABASE TO
				ELSE
					SET DATABASE TO (m.cCurrDBC)
				ENDIF
				SELECT (m.sOldArea)
				THIS.ALERT(C_READ3_LOC)
				EXIT
			ENDIF
		
			* Check if DBC picked
			IF RIGHT(m.cGetDBF,4)=".DBC"
				THIS.SKIPERROR  =.T.
				cOldExcl = SET("EXCL")
				DO CASE 
				CASE TYPE("THIS.ExclusiveSet")#"N"
				CASE THIS.ExclusiveSet = 1
					SET EXCLUSIVE OFF
				CASE THIS.ExclusiveSet = 2
					SET EXCLUSIVE ON
				ENDCASE
				OPEN DATABASE (m.cGetDBF)  && note: this doesn't affect DBCALIAS.
				SET EXCLUSIVE &cOldExcl
				THIS.SKIPERROR  =.F.
				IF EMPTY(DBC())				&& failed to open
					LOOP
				ELSE
					EXIT
				ENDIF
			ENDIF
		
			* Check if file already used in DBC.
			nPos = ASCAN(aDBCList,m.cGetDBF, 1, 3)
			IF m.nPos # 0
				SELECT (aDBCList[m.nPos+1])
				m.cTmpDbc = THIS.GetDBCName()
				IF DBC()#THIS.GetDBCName()
					SET DATABASE TO (m.cTmpDbc)
				ENDIF
				EXIT
			ENDIF
		
			* Check if file already used.
			nPos = ASCAN(aDBFList,m.cGetDBF, 1, 3)
			IF m.nPos # 0
				SELECT (aDBFList[m.nPos+1])
				EXIT
			ENDIF
		
			* Try to open it if not already opened.
			THIS.UseTable(m.cGetDBF,.T.)
		
			IF !EMPTY(ALIAS()) && successfully opened file
				EXIT
			ENDIF
		
		ENDDO
		
		SET SAFETY &sOldSafe
		RETURN m.cGetDBF
		
	ENDPROC

	PROCEDURE tablechange
	ENDPROC

	PROCEDURE usetable		&& Handles USEing datasource.
		LPARAMETER cGetDBF,lUseExcl
		
		LOCAL cTmpAlias,nTmpCount,cAlias,cOldSafe,badchars,goodchars,i,cOldExcl
		
		lUseExcl = IIF(PCOUNT()>1,"EXCLUSIVE","SHARED")
		cAlias= THIS.JUSTSTEM(m.cGetDBF)
		
		* Check to make sure we have valid characters in are alias since
		* DBCs can store names of tables\views with any character.
		IF VERSION(3) $ DBCS_LOC
			m.badchars  =    '/,-=:;!@#$%&*.<>()?'+;
			   '+'+CHR(34)+CHR(39)+" "
		ELSE
			m.badchars  =    ' ¡¢£¤¥/\,-=:;{}[]!@#$%^&*.<>()?'+;
			   '+|¦§¨©ª«¬­®¯°±²³´µ¶·¸¹º»¼½¾¿ÀÁÂÃÄÅÆÇÈÉÊËÌÍÎÏ'+;
			   'ÐÑÒÓÔÕÖ×ØÙÚÛÜÝÞßàáâãäåæçèéêëìíîïðñòóôõö÷øùúûüýþ'+CHR(34)+CHR(39)+" "
		ENDIF
		
		* Let's set the true bad characters which aren't allowed in fields
		* Note: this will differ based on code page
		m.goodchars=""
		FOR i = 1 TO LEN(m.badchars)
			IF ISALPHA(SUBSTR(m.badchars,m.i,1))
				m.goodchars = m.goodchars + SUBSTR(m.badchars,m.i,1)
			ENDIF
		ENDFOR
		m.badchars = CHRTRAN(m.badchars,m.goodchars,'')
		
		m.cAlias = CHRTRAN(m.cAlias,m.badchars,REPLICATE("_",LEN(m.badchars)))
		
		* Test if alias is a numeric name and precede it with "_"
		* so that it doesn't conflict with workarea number.
		IF ISDIGIT(m.cAlias)
			m.cAlias= '_'+m.cAlias
		ENDIF
		m.cTmpAlias = m.cAlias
		
		SELECT 0
		
		* Test for ALIAS name already being used
		m.nTmpCount = 1
		DO WHILE .T.
			IF !USED(m.cTmpAlias)
				EXIT
			ENDIF
			m.cTmpAlias = m.cAlias + "_"+ALLT(STR(m.nTmpCount))
			m.nTmpCount = m.nTmpCount+ 1
		ENDDO
		
		* Trap for error here -- update 3.0 tables in DBC
		THIS.SKIPERROR  =.T.
		m.cOldSafe = SET("SAFETY")
		SET SAFETY OFF  && to prevent 3.0 conversion dialog from appearing
		m.cOldExcl = SET("EXCL")
		
		DO CASE 
		CASE TYPE("THIS.ExclusiveSet")#"N"
		CASE THIS.ExclusiveSet = 1
			SET EXCLUSIVE OFF
		CASE THIS.ExclusiveSet = 2
			SET EXCLUSIVE ON
		ENDCASE
		
		IF THIS.ViewNoData	&& for Views - only get structure
			USE (m.cGetDBF) AGAIN NODATA ALIAS (m.cTmpAlias) &lUseExcl 
		ELSE
			USE (m.cGetDBF) AGAIN ALIAS (m.cTmpAlias) &lUseExcl
		ENDIF
		
		THIS.SKIPERROR  =.F.
		SET SAFETY &cOldSafe
		SET EXCLUSIVE &cOldExcl
		
		* Failed to open table
		IF EMPTY(ALIAS())
			RETURN
		ENDIF
		
		* check if it is a readonly table and Form wizard
		IF ISREADONLY() AND TYPE('THIS.AllowReadOnly')="L" AND !THIS.AllowReadOnly
			* Wizard does not allow ReadOnly Tables
			USE
			THIS.ALERT(C_READONLY_LOC)
			RETURN
		ENDIF
		
		* Let's update arrays here
		
		
		IF EMPTY(THIS.GetDBCName())			&& Free table
			IF !EMPTY(aDBFList[1])
				DIMENSION aDBFList[ALEN(aDBFList,1)+1,2]
			ENDIF
			aDBFList[ALEN(aDBFList,1),1] = DBF()
			aDBFList[ALEN(aDBFList,1),2] = ALIAS() 		
			THIS.lstTables.AddItem(ALIAS())
		ELSE										&& DBC
			* Need to update aDBCList array
			IF !EMPTY(aDBCList[1])
				DIMENSION aDBCList[ALEN(aDBCList,1)+1,2]
			ENDIF
			IF CURSORGETPROP("SourceType")#3
				aDBCList[ALEN(aDBCList,1),1] = CURSORGETPROP("SourceName")
			ELSE
				aDBCList[ALEN(aDBCList,1),1] = DBF()
			ENDIF
			aDBCList[ALEN(aDBCList,1),2] = ALIAS()
		ENDIF
		
	ENDPROC

	PROCEDURE cboData.InteractiveChange
		LOCAL cNewTable,lHadDBC,lOldLock,OldRefresh
		
		m.lHadDBC = !EMPTY(DBC())
		m.cNewTable = ""
		m.lOldLock = THISFORM.LockScreen
		THISFORM.LockScreen = .T.
		m.lOldRefresh = THIS.Parent.RefreshFields
		THIS.Parent.RefreshFields = .T.
		
		DO CASE
		CASE THIS.VALUE = C_FREETABLE_LOC AND !m.lHadDBC
			* User selected Free Table option when already previously selected.
		CASE m.lHadDBC AND THIS.VALUE == THIS.Parent.GetDBCAlias()
			* User selected same DBC name as already chosen.
		CASE THIS.VALUE # C_FREETABLE_LOC
			*Selected a DBC from list
			THIS.Parent.GetDBCData(THIS.VALUE)
			THIS.Parent.TableChange()
		OTHERWISE
			* Handle Free tables option
			SELECT 0
			THIS.PARENT.GetFreeData()
		
			* Refresh controls
			THIS.Parent.lstTables.ENABLED = !EMPTY(aDBFList[1])
			THIS.Parent.lstLeft.ENABLED = !EMPTY(aDBFList[1])
			IF !THIS.Parent.MultiTable
				THIS.Parent.lstRight.ENABLED = !EMPTY(aDBFList[1])
			ENDIF
			THIS.Parent.TableChange()
			IF THIS.Parent.lstTables.ListCount # 0 AND;
			   THIS.Parent.lstTables.ListIndex = 0
				THIS.Parent.lstTables.ListIndex = 1
			ENDIF
		ENDCASE
		
		THISFORM.LockScreen = m.lOldLock
		THIS.Parent.RefreshFields = m.lOldRefresh
		
	ENDPROC

	PROCEDURE cmdOpen.Click
		LOCAL lHasDBC,cDBCAlias,lOldLock,lOldRefresh,aDBCTables,cNewTable
		DIMENSION aDBCTables[1]
		
		m.lHasDBC = !EMPTY(DBC())
		
		m.cNewTable = THIS.Parent.OpenTable()
		m.loldLock = THISFORM.LockScreen
		THISFORM.LockScreen = .T.
		m.loldRefresh = THIS.Parent.RefreshFields
		THIS.Parent.RefreshFields = .T.
		
		
		m.cDBCAlias = THIS.Parent.GetDBCAlias()
		
		DO CASE
		CASE EMPTY(m.cNewTable)
			*- No table selected
			THIS.PARENT.cboData.VALUE = IIF(EMPTY(DBC()),C_FREETABLE_LOC,m.cDBCAlias)
		
		CASE RIGHT(m.cNewTable,4)=".DBC" OR !EMPTY(THIS.Parent.GetDBCName())
			*- Handle DBC/DBF from a DBC selected
			
			*- Make sure we get corrent DBCalias if we select new table
			IF RIGHT(m.cNewTable,4)#".DBC"
				m.cDBCAlias = THIS.Parent.GetDBCAlias(THIS.Parent.GetDBCName())
			ENDIF
			
			DO CASE
			CASE THIS.PARENT.cboData.VALUE # m.cDBCAlias
				THIS.Parent.GetDBCData(m.cDBCAlias)
			OTHERWISE
				* Avoid refreshing if already selected
				THIS.Parent.lstTables.VALUE = UPPER(CURSORGETPROP('sourcename'))
				THIS.Parent.GetTableData()
			ENDCASE
			THIS.Parent.TableChange()
		
		OTHERWISE
			*- Handle Free DBF selected
			IF m.lHasDBC
				*- Handle Free tables option if previously had DBC selected
				THIS.Parent.GetFreeData()
			ELSE
				*- Just get table field data
				THIS.Parent.GetTableData()
			ENDIF
			THIS.Parent.lstTables.VALUE = ALIAS()
			THIS.Parent.TableChange()
		ENDCASE
		
		THIS.Parent.lstTables.ENABLED = (THIS.Parent.lstTables.Listcount#0)
		THISFORM.LockScreen = m.lOldLock
		THIS.Parent.RefreshFields = m.lOldRefresh
		
	ENDPROC

	PROCEDURE lstTables.Init
		THIS.VALUE = ""
		
	ENDPROC

	PROCEDURE lstTables.InteractiveChange
		
		IF EMPTY(THIS.LIST[1])
			RETURN
		ENDIF
		
		IF EMPTY(THIS.VALUE)
			THIS.VALUE = THIS.LIST[1]
		ENDIF
		
		LOCAL lOldLock,lOldRefresh
		m.loldRefresh = THIS.Parent.RefreshFields
		THIS.Parent.RefreshFields = .T.
		m.lOldLock = THISFORM.LockScreen
		THISFORM.LockScreen = .T.
		
		IF !EMPTY(DBC())
			*We have a DBC
			THIS.Parent.GetDBCTable(ALLTRIM(THIS.Value))
			THIS.Parent.DBCTable = ALLTRIM(THIS.Value)
		ELSE
			*Free standing table
			SELECT (THIS.Value)
		ENDIF
		
		THIS.Parent.GetTableData()
		THIS.Parent.TableChange()
		THISFORM.LockScreen = m.lOldLock
		THIS.Parent.RefreshFields = m.lOldRefresh
		
	ENDPROC

ENDDEFINE
