*--------------------------------------------------------------------------------------------------------------------------------------------------------
* (ES) AUTOGENERADO - ¡¡ATENCIÓN!! - ¡¡NO PENSADO PARA EJECUTAR!! USAR SOLAMENTE PARA INTEGRAR CAMBIOS Y ALMACENAR CON HERRAMIENTAS SCM!!
* (EN) AUTOGENERATED - ATTENTION!! - NOT INTENDED FOR EXECUTION!! USE ONLY FOR MERGING CHANGES AND STORING WITH SCM TOOLS!!
*--------------------------------------------------------------------------------------------------------------------------------------------------------
*< FOXBIN2PRG: Version="1.19" SourceFile="rawprint.vcx" /> (Solo para binarios VFP 9 / Only for VFP 9 binaries)
*
*
DEFINE CLASS printdev AS custom 
 	*< CLASSDATA: Baseclass="custom" Timestamp="" Scale="Pixels" Uniqueid="" />

	*<DefinedPropArrayMethod>
		*m: declareapi		&& Declare API functions Required to access the printer device in raw mode.
		*m: long2char		&& Long value to char conversion
		*m: oblddocptr		&& Build a Pointer to String for use in the Doc_info_1 structure.
		*m: oclose		&& Close a printer device previouly opened with oOpen()
		*m: oisopen		&& Verify status of the print device.
		*m: oopen		&& Open the printer device specified in cPrinterName, and store the result handle in nPrnHandle.
		*m: oprintfile		&& Send the file specified in the cFilename to a previously opened print device.
		*m: oprintmem		&& Send the content of a string variable passed as parameter to a previouly opened printer device.
		*p: cdocname		&& Document name to show in print spooler
		*p: cfilename		&& File to use in oPrintFile()
		*p: cprintername		&& Name of the printer to open.
		*p: defprtname		&& Default printer name
		*p: hdocname		&& Memory Handle for DocName
		*p: nerror		&& Error returned from last API call.
		*p: nopenerror
		*p: nprnhandle		&& Printer handle returned from OpenPrinter
		*p: procheap		&& Current process heap
	*</DefinedPropArrayMethod>

	PROTECTED defprtname,hdocname,nprnhandle,procheap
	cdocname = (Space(0))		&& Document name to show in print spooler
	cfilename = (Space(0))		&& File to use in oPrintFile()
	cprintername = (Space(0))		&& Name of the printer to open.
	defprtname = (Space(0))		&& Default printer name
	hdocname = (0)		&& Memory Handle for DocName
	Name = "printdev"
	nerror = (0)		&& Error returned from last API call.
	nopenerror = (0)
	nprnhandle = (0)		&& Printer handle returned from OpenPrinter
	procheap = (0)		&& Current process heap
	
	PROTECTED PROCEDURE declareapi		&& Declare API functions Required to access the printer device in raw mode.
		*--
		*   pPrinterName - Pointer to a null-terminated string that specifies 
		*                  the name of the printer or print server. 
		*   phPrinter    - Pointer to a variable that receives the handle 
		*                  identifying the opened printer or print server object. 
		*   pDefault     - Pointer to a PRINTER_DEFAULTS structure. 
		*                  This value can be NULL. 
		*--
		DECLARE INTEGER OpenPrinter      IN WINSPOOL.DRV ;
		        STRING  pPrinterName,                    ;
		        INTEGER @phPrinter,                      ;
		        LONG    pDefault
		
		*--
		*   hPrinter     - Handle to the printer object to be closed. Use the OpenPrinter 
		*                  or AddPrinter function to retrieve a printer handle. 
		*--
		DECLARE INTEGER ClosePrinter     IN WINSPOOL.DRV ;
		        INTEGER hPrinter
		
		*--
		*   hPrinter     - Handle to the printer. Use the OpenPrinter or AddPrinter 
		*                  function to retrieve a printer handle. 
		*   nLevel       - Specifies the version of the structure to which
		*                  pDocInfo points. WinNT: 1, Win9x: 1 or 2. 
		*   pDocInfo     - Pointer to a structure that describes the document to print. 
		*--
		DECLARE INTEGER StartDocPrinter  IN WINSPOOL.DRV ;
		        INTEGER hPrinter,                        ;
		        LONG    nLevel,                          ;
		        STRING  pDocInfo
		
		*--
		*   hPrinter     - Handle to a printer for which the print job should be ended. 
		*                  Use the OpenPrinter or AddPrinter function to retrieve a 
		*                  printer handle.
		*--
		DECLARE INTEGER EndDocPrinter    IN WINSPOOL.DRV ;
		        INTEGER hPrinter
		
		*--
		*   hPrinter        - Handle to the printer. Use the OpenPrinter or AddPrinter 
		*                     function to retrieve a printer handle. 
		*   pBuf            - Pointer to an array of bytes that contains the data that 
		*                     should be written to the printer. 
		*   cbBuf           - Specifies the size, in bytes, of the array. 
		*   pcWritten       - Pointer to a value that specifies the number of bytes of 
		*                     data that were written to the printer. 
		*--
		DECLARE INTEGER WritePrinter     IN WINSPOOL.DRV ;
		        INTEGER hPrinter,                        ;
		        STRING  pBuf,                            ;
		        LONG    cbBuf,                           ;
		        LONG    @pcWritten
		*--
		*   Obtains a handle to the heap of the calling process.
		*--
		DECLARE INTEGER GetProcessHeap   IN WIN32API
		
		
		*--
		*   Allocates a block of memory from a heap.
		*--
		DECLARE LONG HeapAlloc           IN WIN32API     ;
		        INTEGER hHeap,                           ;
		        INTEGER dwFlags,                         ;
		        INTEGER dwBytes
		
		*--
		*   Frees a memory block allocated from a heap by HeapAlloc.
		*--
		DECLARE INTEGER HeapFree         IN WIN32API     ;
		        INTEGER hHeap,                           ;
		        INTEGER dwFlags,                         ;
		        LONG    lpMem
		
		*--
		*   Copies a block of memory from one location to another. 
		*--
		DECLARE memcpy          IN MSVCRT  AS CopyMemory ;
		        LONG Destination,                        ;
		        STRING Source,                           ;
		        INTEGER Length
		
		*--
		*   Get Last error in thread
		*--
		DECLARE INTEGER GetLastError IN WIN32API
		
	ENDPROC

	PROCEDURE Destroy
		this.oclose()
		
	ENDPROC

	PROCEDURE Init
		Local laprtlst(1,2), npos
		this.DeclareAPI()
		
		If Empty(this.cprintername) .And. !Empty(this.defprtname)
		   APrinters(laprtlst)
		   npos = ASCAN(laprtlst, this.defprtname)
		   If npos != 0
		      this.cprintername = laprtlst(npos)
		   Endif
		Endif
		
	ENDPROC

	PROTECTED PROCEDURE long2char		&& Long value to char conversion
		LParameter nLongVal
		Local lnlv, lcRetval
		
		lcRetVal=Replicate(chr(0),4)
		
		If type('nLongVal') = 'N'
		    lnlv = Int(nLongVal)
		    lcRetval = chr(bitand(lnlv,255))                 + ;
		               chr(bitand(bitrshift(lnlv,  8), 255)) + ;
		               chr(bitand(bitrshift(lnlv, 16), 255)) + ;
		               chr(bitand(bitrshift(lnlv, 24), 255))
		Endif
		
		Return lcRetVal
	ENDPROC

	PROTECTED PROCEDURE oblddocptr		&& Build a Pointer to String for use in the Doc_info_1 structure.
		Local lcDocPtr, lcDocstr
		
		lcDocPtr = Replicate(Chr(0), 20)
		If this.procheap = 0
		   this.procheap = GetProcessHeap()
		Endif
		
		If this.procheap != 0
		   Do Case
		      Case !Empty(this.cdocname)
		           lcdocstr = this.cdocname
		      Case !Empty(this.cfilename)
		           lcdocstr = this.cfilename
		      Otherwise
		           lcdocstr = "Visual Foxpro Document"
		   EndCase
		   
		   lcdocstr = lcDocStr+chr(0)
		   this.hdocname = HeapAlloc(this.procheap, 0, Len(lcdocstr)+1)
		
		   If this.hdocname != 0
		       CopyMemory(this.hdocname, lcDocstr, Len(lcDocstr) )
		       lcDocPtr  = this.Long2Char(this.hdocname) + Replicate(chr(0), 16)
		   Endif
		Endif
		
		Return lcDocPtr
	ENDPROC

	PROCEDURE oclose		&& Close a printer device previouly opened with oOpen()
		Local lresult
		
		this.DeclareAPI()
		lresult =.t.
		If this.nprnhandle != 0
		   EndDocPrinter(this.nprnhandle)
		   ClosePrinter(this.nprnhandle)
		   this.nprnhandle = 0
		Endif
		
		If this.hdocname != 0
		   HeapFree(this.procheap, 0, this.hdocname)
		   this.hdocname = 0
		Endif
		
		Return lresult
		
	ENDPROC

	PROCEDURE oisopen		&& Verify status of the print device.
		Return (this.nprnhandle != 0)
		
	ENDPROC

	PROCEDURE oopen		&& Open the printer device specified in cPrinterName, and store the result handle in nPrnHandle.
		Local lnhand, lndef, lcdoc
		
		lnhand = 0
		lndef  = 0
		
		this.DeclareAPI()
		this.oClose()
		
		this.nerror = OpenPrinter(this.cprintername, @lnhand, lndef)
		this.nopenerror = GetLastError()
		
		If this.nerror != 0
		   lcdoc  = this.oBldDocPtr()
		   this.nerror = StartDocPrinter(lnhand, 1, lcdoc)
		Endif
		
		If this.nerror != 0
		   this.nprnhandle = lnhand
		Else
		   If lnhand != 0
		      ClosePrinter(lnhand)
		   Endif
		Endif
		
		Return (this.nerror != 0)
		
	ENDPROC

	PROCEDURE oprintfile		&& Send the file specified in the cFilename to a previously opened print device.
		#define BLKSZ 65535
		Local lresult, lnwrtchr, lcMemo, lnflhnd, nfsize
		
		nfsize   = 0
		lnwrtchr = 0
		lresult  = .f.
		lcMemo   = Space(0)
		
		this.DeclareAPI()
		If this.nprnhandle != 0
		   If !Empty(this.cFilename) .And. File(this.cFilename)
		      lnflhnd = Fopen(this.cFilename)
		      If lnflhnd != -1
		         nfsize = Fseek(lnflhnd,0,2)
		         Fseek(lnflhnd,0,0)
		      Endif
		      If nfsize > 0
		         lresult = .t.
		         Do While !Feof(lnflhnd)
		            lcMemo = FRead(lnflhnd, BLKSZ)
		            If WritePrinter(this.nprnhandle, lcMemo, Len(lcMemo),@lnwrtchr) == 0
		              lresult = .f.
		            Endif
		         EndDo
		      Endif
		      If lnflhnd != -1
		         Fclose(lnflhnd)
		      Endif
		   Endif
		Endif
		
		Return lresult
		
	ENDPROC

	PROCEDURE oprintmem		&& Send the content of a string variable passed as parameter to a previouly opened printer device.
		LPARAM pcMemo
		Local lresult, lnwrtchr
		
		lresult=.f.
		
		this.DeclareAPI()
		If this.nprnhandle != 0
		   If type('pcMemo')='C' .And. Len(pcMemo)>0
		      If WritePrinter(this.nprnhandle, pcMemo, Len(pcMemo), @lnwrtchr) != 0
		         lresult = .t.
		      Endif
		   Endif
		Endif
		
		Return lresult
	ENDPROC

ENDDEFINE
