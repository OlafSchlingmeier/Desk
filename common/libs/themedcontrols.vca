*--------------------------------------------------------------------------------------------------------------------------------------------------------
* (ES) AUTOGENERADO - ¡¡ATENCIÓN!! - ¡¡NO PENSADO PARA EJECUTAR!! USAR SOLAMENTE PARA INTEGRAR CAMBIOS Y ALMACENAR CON HERRAMIENTAS SCM!!
* (EN) AUTOGENERATED - ATTENTION!! - NOT INTENDED FOR EXECUTION!! USE ONLY FOR MERGING CHANGES AND STORING WITH SCM TOOLS!!
*--------------------------------------------------------------------------------------------------------------------------------------------------------
*< FOXBIN2PRG: Version="1.19" SourceFile="themedcontrols.vcx" /> (Solo para binarios VFP 9 / Only for VFP 9 binaries)
*
*
DEFINE CLASS tcntpicturecollection AS tcontainer OF "_lvisual.vcx" 
 	*< CLASSDATA: Baseclass="container" Timestamp="" Scale="Pixels" Uniqueid="" />

	*<DefinedPropArrayMethod>
		*m: getpicture
	*</DefinedPropArrayMethod>

	Name = "tcntpicturecollection"
	Visible = .F.
	
	PROCEDURE getpicture
		LPARAMETERS tcPicture
		LOCAL lcName
		
		IF NOT FILE(tcPicture)
			tcPicture = "Picts\Bitmaps\maintenance.png"
		ENDIF
		lcName = "img" + LOWER(JUSTSTEM(tcPicture))
		IF NOT PEMSTATUS(this, lcName, 5)
			this.AddObject(lcName, "Image")
			this.&lcName..Picture = tcPicture
		ENDIF
		
		RETURN this.&lcName..Picture
	ENDPROC

ENDDEFINE

DEFINE CLASS tcntthemedheader AS tcontainer OF "_lvisual.vcx" 
 	*< CLASSDATA: Baseclass="container" Timestamp="" Scale="Pixels" Uniqueid="" />

	*-- OBJECTDATA items order determines ZOrder / El orden de los items OBJECTDATA determina el ZOrder 
	*< OBJECTDATA: ObjPath="hMoveBar" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Header1" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="LineLeft" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="LineTop" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Shape1" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="LineBottom" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="LineRight" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="imgTheme" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="vMoveBar" UniqueID="" Timestamp="" />

	#INCLUDE "win32api.h"
	*<DefinedPropArrayMethod>
		*m: bar_mousedown
		*m: bar_mousemove
		*m: bar_mouseup
		*m: b_updateheader
		*m: caption_access
		*m: caption_assign
		*m: caption_convert
		*m: columnresizable
		*m: drag_mousedown
		*m: drag_mousemove
		*m: drag_mouseup
		*m: drag_shadowcreate
		*m: drag_shadowdestroy
		*m: gettxtsize
		*m: headersort
		*m: lmovable_assign
		*m: lresizable_assign
		*m: onmouseenter
		*m: orefheader_assign
		*m: reset		&& Resets the Timer control so that it starts counting from 0.
		*m: resetcaption
		*m: setcolor
		*m: setpicture
		*m: tooltiptext_assign
		*p: caption		&& Specifies the text displayed in an object's caption.
		*p: ldrag
		*p: linit
		*p: lmovable
		*p: lresizable
		*p: mousedownx
		*p: mousedowny
		*p: nalignment
		*p: ndragmax
		*p: ndragmin
		*p: nheight
		*p: nmergecount
		*p: ntype
		*p: nvisible
		*p: nwidth
		*p: orefdown
		*p: orefheader
		*p: orefline
		*p: orefright
		*p: orefshadow
		*p: orefup
		*a: arefcolumns[1,0]
		*a: arefleftheaders[1,0]
	*</DefinedPropArrayMethod>

	HIDDEN ldrag,mousedownx,mousedowny,ndragmax,ndragmin,orefline,orefshadow
	Anchor = 0
	Height = 35
	mousedownx = 0
	mousedowny = 0
	nalignment = 3
	Name = "tcntthemedheader"
	ndragmax = 0
	ndragmin = 0
	nheight = -1
	nmergecount = 0
	ntype = 0
	nvisible = 0
	nwidth = 0
	orefdown = .NULL.
	orefheader = .NULL.
	orefline = .NULL.
	orefright = .NULL.
	orefshadow = .NULL.
	orefup = .NULL.

	ADD OBJECT 'Header1' AS tlabel WITH ;
		Anchor = 0, ;
		Left = 75, ;
		Name = "Header1", ;
		Top = 9, ;
		Width = 51, ;
		WordWrap = .T.
		*< END OBJECT: ClassLib="_lvisual.vcx" BaseClass="label" />

	ADD OBJECT 'hMoveBar' AS tcontainer WITH ;
		Anchor = 0, ;
		BackColor = 255,128,0, ;
		BackStyle = 1, ;
		Height = 34, ;
		Left = 193, ;
		MouseIcon = ..\cursors\header_resize_h.cur, ;
		MousePointer = 99, ;
		Name = "hMoveBar", ;
		Visible = .F., ;
		Width = 4
		*< END OBJECT: ClassLib="_lvisual.vcx" BaseClass="container" />

	ADD OBJECT 'imgTheme' AS timgthemedbg WITH ;
		Left = 169, ;
		Name = "imgTheme", ;
		themeparid = 1, ;
		themestate = 1, ;
		Top = 8, ;
		Visible = .F., ;
		Width = 17
		*< END OBJECT: ClassLib="themedcontrols.vcx" BaseClass="image" />

	ADD OBJECT 'LineBottom' AS tline WITH ;
		Anchor = 0, ;
		Height = 0, ;
		Left = 11, ;
		Name = "LineBottom", ;
		Top = 33, ;
		Width = 48
		*< END OBJECT: ClassLib="_lvisual.vcx" BaseClass="line" />

	ADD OBJECT 'LineLeft' AS tline WITH ;
		Anchor = 0, ;
		BorderColor = 255,255,255, ;
		Height = 28, ;
		Left = 12, ;
		Name = "LineLeft", ;
		Top = 5, ;
		Width = 0
		*< END OBJECT: ClassLib="_lvisual.vcx" BaseClass="line" />

	ADD OBJECT 'LineRight' AS tline WITH ;
		Anchor = 0, ;
		Height = 28, ;
		Left = 58, ;
		Name = "LineRight", ;
		Top = 6, ;
		Width = 0
		*< END OBJECT: ClassLib="_lvisual.vcx" BaseClass="line" />

	ADD OBJECT 'LineTop' AS tline WITH ;
		Anchor = 0, ;
		BorderColor = 255,255,255, ;
		Height = 0, ;
		Left = 12, ;
		Name = "LineTop", ;
		Top = 5, ;
		Width = 48
		*< END OBJECT: ClassLib="_lvisual.vcx" BaseClass="line" />

	ADD OBJECT 'Shape1' AS tshape WITH ;
		Anchor = 0, ;
		BackStyle = 1, ;
		BorderStyle = 0, ;
		BorderWidth = 0, ;
		DrawMode = 6, ;
		Height = 13, ;
		Left = 21, ;
		MousePointer = 99, ;
		Name = "Shape1", ;
		Top = 12, ;
		Width = 23
		*< END OBJECT: ClassLib="_lvisual.vcx" BaseClass="shape" />

	ADD OBJECT 'vMoveBar' AS tcontainer WITH ;
		Anchor = 0, ;
		BackColor = 255,128,0, ;
		BackStyle = 1, ;
		Height = 4, ;
		MouseIcon = ..\cursors\header_resize_v.cur, ;
		MousePointer = 99, ;
		Name = "vMoveBar", ;
		Top = 30, ;
		Visible = .F., ;
		Width = 12
		*< END OBJECT: ClassLib="_lvisual.vcx" BaseClass="container" />
	
	PROCEDURE bar_mousedown
		LPARAMETERS nButton, nShift, nXCoord, nYCoord
		LOCAL loGrid, lnIndex, loColumn, loColTmp, lnLock
		
		loGrid = this.Parent.oRefGrid
		IF NOT VARTYPE(loGrid) = "O"
			RETURN
		ENDIF
		
		this.MouseDownX	= nXCoord
		this.MouseDownY	= nYCoord
		
		DO CASE
			CASE nButton = 1 
				thisform.AddObject("_" + SYS(2015), "Line")
				this.oRefLine = thisform.Controls(thisform.ControlCount)
				this.oRefLine.DrawMode = this.Shape1.DrawMode
				this.oRefLine.AddProperty("nRangeMinX", OBJTOCLIENT(this, 2))
				this.oRefLine.AddProperty("nRangeMaxX", OBJTOCLIENT(this.Parent, 2) + this.Parent.Width)
				this.oRefLine.Move(OBJTOCLIENT(this, 2) + this.Width - 1, OBJTOCLIENT(this.Parent, 1), 0, ;
					MAX(loGrid.Height - IIF(INLIST(loGrid.ScrollBars, 1, 3), SYSMETRIC(8), 0) - 2, 0))
				this.oRefLine.Visible = .T.
			CASE nButton = 2
				lnLock = 0
				loColumn = this.Parent.GetColumn(this.Parent.GetGroupMax(this))
				FOR lnIndex = loGrid.LeftColumn TO loColumn.ColumnOrder
					loColTmp = this.Parent.GetColumn(lnIndex)
					IF loColTmp.Visible AND loColtmp.ControlCount > 0 AND OBJTOCLIENT(loColtmp.Controls(1), 2) > 0
						lnLock = lnLock + 1
					ENDIF
				NEXT
				IF this.Parent.nLock # lnLock
					this.Parent.HeaderLock(MAX(lnLock, this.Parent.nMinLock))
				ELSE
					this.Parent.HeaderLock(this.Parent.nMinLock) 
				ENDIF
		ENDCASE
	ENDPROC

	PROCEDURE bar_mousemove
		LPARAMETERS nButton, nShift, nXCoord, nYCoord
		LOCAL lnLeft
		
		IF VARTYPE(this.oRefLine) = "O"
			lnLeft = OBJTOCLIENT(this.hMoveBar, 2) - this.MouseDownX + nXCoord
			this.oRefLine.Left = MIN(this.oRefLine.nRangeMaxX, MAX(lnLeft, this.oRefLine.nRangeMinX))
		ENDIF
	ENDPROC

	PROCEDURE bar_mouseup
		LPARAMETERS nButton, nShift, nXCoord, nYCoord
		
		IF NOT ISNULL(this.oRefLine)
			thisform.RemoveObject(this.oRefLine.Name)
			this.oRefLine = .NULL.
		ENDIF
		
		IF nXCoord <> this.MouseDownX
			this.ColumnResizable(nXCoord - this.MouseDownX)
		ENDIF
	ENDPROC

	PROCEDURE b_updateheader
		LOCAL llModify
		LOCAL ARRAY laArray[1]
		
		IF ISNULL(this.oRefHeader)
			this.Header1.Caption = this.Caption_convert(this.Header1.Caption)
		ELSE
			IF AEVENTS(laArray, 0) > 0 AND laArray[1] = this.oRefHeader
				this.Header1.Caption = this.Caption_convert(this.oRefHeader.Caption)
				this.Header1.FontName = this.oRefHeader.FontName
				this.Header1.FontSize = this.oRefHeader.FontSize
				this.Header1.ForeColor = this.oRefHeader.ForeColor
				this.Header1.FontBold = this.oRefHeader.FontBold
				this.Header1.FontItalic = this.oRefHeader.FontItalic
				this.Header1.FontStrikethru = this.oRefHeader.FontStrikethru
				this.Header1.FontUnderline = this.oRefHeader.FontUnderline
				IF this.oRefHeader.BackColor = this.Parent._BackColor
					this.BackStyle = 0
					this.BackColor = this.Parent._BackColor
				ELSE
					this.BackStyle = 1
					this.BackColor = this.oRefHeader.BackColor
				ENDIF
			ENDIF
		ENDIF
		
		IF NOT this.imgTheme.Font.Caption == this.Header1.Caption
			llModify = .T.
			this.imgTheme.Font.Caption = this.Header1.Caption
		ENDIF
		IF NOT this.imgTheme.Font.FontName == this.Header1.FontName
			llModify = .T.
			this.imgTheme.Font.FontName = this.Header1.FontName
		ENDIF
		IF this.imgTheme.Font.ForeColor # this.Header1.ForeColor
			llModify = .T.
			this.imgTheme.Font.ForeColor = this.Header1.ForeColor
		ENDIF
		IF this.imgTheme.Font.FontSize # this.Header1.FontSize
			llModify = .T.
			this.imgTheme.Font.FontSize = this.Header1.FontSize
		ENDIF
		IF this.imgTheme.Font.FontBold # this.Header1.FontBold
			llModify = .T.
			this.imgTheme.Font.FontBold = this.Header1.FontBold
		ENDIF
		IF this.imgTheme.Font.FontItalic # this.Header1.FontItalic
			llModify = .T.
			this.imgTheme.Font.FontItalic = this.Header1.FontItalic
		ENDIF
		IF this.imgTheme.Font.FontStrikethru # this.Header1.FontStrikethru
			llModify = .T.
			this.imgTheme.Font.FontStrikethru = this.Header1.FontStrikethru
		ENDIF
		IF this.imgTheme.Font.FontUnderline # this.Header1.FontUnderline
			llModify = .T.
			this.imgTheme.Font.FontUnderline = this.Header1.FontUnderline
		ENDIF
		
		IF llModify
			this.imgTheme.ThemeClass = this.imgTheme.ThemeClass
			this.ResetCaption()
		ENDIF
	ENDPROC

	HIDDEN PROCEDURE caption_access
		RETURN this.Header1.Caption
	ENDPROC

	HIDDEN PROCEDURE caption_assign
		LPARAMETERS tcNewVal
		
		this.Header1.Caption = this.Caption_convert(tcNewVal)
		this.imgTheme.Font.Caption = this.Header1.Caption
		
		this.Refresh()
	ENDPROC

	PROCEDURE caption_convert
		LPARAMETERS tcCaption
		LOCAL lcCaption
		
		lcCaption = tcCaption
		IF NOT CRLF $ lcCaption
			lcCaption = STRTRAN(lcCaption, "\\", CHR(0))
			lcCaption = STRTRAN(lcCaption, "\n", CRLF)
			lcCaption = STRTRAN(lcCaption, CHR(0), "\")
		ENDIF
		
		RETURN lcCaption
	ENDPROC

	PROCEDURE Click
		this.Parent.OnClick(this)
	ENDPROC

	PROCEDURE columnresizable
		LPARAMETERS tnValue
		LOCAL loColumn, lnCell, lnCellWidth, lnMod
		
		lnCell = 0
		FOR EACH loColumn IN this.aRefColumns
			lnCell = lnCell + IIF(loColumn.Resizable, 1, 0)
		NEXT
		
		lnCellWidth = INT(tnValue/lnCell)
		lnMod = MOD(tnValue, lnCell)
		FOR EACH loColumn IN this.aRefColumns
			IF loColumn.Resizable
				lnCell = lnCell - 1
				IF lnCell = 0
					loColumn.Width = MAX(loColumn.Width + lnCellWidth + lnMod, 0)
				ELSE
					loColumn.Width = MAX(loColumn.Width + lnCellWidth, 0)
				ENDIF
			ENDIF
		NEXT
		
		this.Parent.HeaderRedraw()
		IF NOT ISNULL(this.Parent.oRefPanel)
			this.Parent.oRefPanel.HeaderRedraw()
		ENDIF
	ENDPROC

	PROCEDURE DblClick
		this.Parent.OnDblClick(this)
	ENDPROC

	PROCEDURE Destroy
		IF VARTYPE(this.oRefHeader) = "O"
			UNBINDEVENTS(this.oRefHeader)
		ENDIF
	ENDPROC

	PROCEDURE drag_mousedown
		LPARAMETERS nButton, nShift, nXCoord, nYCoord
		
		this.MouseDownX	= nXCoord
		this.MouseDownY	= nYCoord
		
		IF ISNULL(this.oRefup)
			this.nDragMin = OBJTOCLIENT(this.Parent, 2)
			this.nDragMax = this.nDragMin + this.Parent.Width
		ELSE
			this.nDragMin = OBJTOCLIENT(this.oRefup, 2)
			this.nDragMax = this.nDragMin + this.oRefup.Width
		ENDIF
		
		IF nButton = 1
			IF NOT this.Parent.lTheme OR NOT this.ImgTheme.lThemeDraw
				this.Shape1.BackStyle = 1
			ENDIF
		ENDIF
	ENDPROC

	PROCEDURE drag_mousemove
		LPARAMETERS nButton, nShift, nXCoord, nYCoord
		LOCAL lnLeft, loBorderHeader, lnMinLock
		
		IF NOT this.lDrag AND ABS(this.MouseDownX - nXCoord) > 5
			this.Drag_ShadowCreate()
			this.lDrag = .T.
		ENDIF
		
		IF this.lDrag AND BETWEEN(nXCoord, this.nDragMin, this.nDragMax)
			lnLeft = OBJTOCLIENT(this, 2)
			DO CASE
				CASE nXCoord < this.MouseDownX AND nXCoord < lnLeft
					loBorderHeader = this.Parent.GetHeaderLeft(this)
					IF NOT ISNULL(loBorderHeader) AND loBorderHeader.Visible AND nXCoord < OBJTOCLIENT(loBorderHeader, 2) + this.Width
						#IF VERSION(5) > 600
							lnMinLock = this.Parent.nMinLock
							DO CASE
								CASE loBorderHeader.nType = 0 AND loBorderHeader.aRefColumns[1].ColumnOrder <= lnMinLock
									RETURN
								CASE loBorderHeader.nType = 1 AND loBorderHeader.aRefColumns[1].ColumnOrder <= lnMinLock
									RETURN
								CASE loBorderHeader.nType = 2 AND this.Parent.GetGroupMin(loBorderHeader) <= lnMinLock
									RETURN
							ENDCASE
						#ENDIF
						
						this.MouseDownX = nXCoord
						this.Parent.HeaderSwap(this, loBorderHeader)
						this.Drag_ShadowCreate()
						this.Parent.OnDrag(this, 0)
					ENDIF
		
				CASE nXCoord > this.MouseDownX AND nXCoord > lnLeft + this.Width
					loBorderHeader = this.Parent.GetHeaderRight(this)
					IF NOT ISNULL(loBorderHeader) AND loBorderHeader.Visible AND nXCoord > OBJTOCLIENT(loBorderHeader, 2) + loBorderHeader.Width - this.Width
						this.MouseDownX = nXCoord
						this.Parent.HeaderSwap(loBorderHeader, this)
						this.Drag_ShadowCreate()
						this.Parent.OnDrag(this, 1)
					ENDIF
			ENDCASE
		ENDIF
	ENDPROC

	PROCEDURE drag_mouseup
		LPARAMETERS nButton, nShift, nXCoord, nYCoord
		
		this.lDrag = .F.
		this.Shape1.BackStyle = 0
		this.Drag_ShadowDestroy()
	ENDPROC

	PROCEDURE drag_shadowcreate
		LOCAL lnScroll
		
		IF ISNULL(this.oRefShadow)
			thisform.AddObject("_" + Sys(2015), "Shape")
			this.oRefShadow = thisform.Controls(thisform.ControlCount)
			lnScroll = IIF(INLIST(this.Parent.oRefGrid.ScrollBars, 1, 3), SYSMETRIC(8), 0) + 1
			this.oRefShadow.Top = OBJTOCLIENT(this, 1) + this.Height
			IF this.nType = 2
				this.oRefShadow.Height = MAX(this.Parent.oRefGrid.Top - this.Parent.Top + ;
					this.Parent.oRefGrid.Height - this.Height - lnScroll, 0)
			ELSE
				this.oRefShadow.Height = MAX(this.Parent.oRefGrid.Top - this.Parent.Top + ;
					this.Parent.oRefGrid.Height - this.Parent.Height - lnScroll, 0)
			ENDIF
			this.oRefShadow.BorderStyle = 0
			this.oRefShadow.BorderWidth = 0
			this.oRefShadow.DrawMode = 6
			this.oRefShadow.ZOrder(0)
		ENDIF
		
		this.oRefShadow.Move(OBJTOCLIENT(this, 2), this.oRefShadow.Top, this.Width)
		this.oRefShadow.Visible = this.Visible
	ENDPROC

	PROCEDURE drag_shadowdestroy
		IF NOT ISNULL(this.oRefShadow)
			thisform.RemoveObject(this.oRefShadow.Name)
		ENDIF
		
		this.oRefShadow = .NULL.
	ENDPROC

	HIDDEN PROCEDURE gettxtsize
		LPARAMETERS tnWidth, tnHeight
		LOCAL lhDC, lhFont, lhOldFont, lcCaption, lcFontName, lnFontSize, lsRect
		
		lsRect = BINTOC(0, "4rs") + BINTOC(0, "4rs") + BINTOC(this.Width, "4rs") + BINTOC(this.Height, "4rs")
		
		lhDC = GetDC(_VFP.hWnd)
		
		lcCaption = this.Header1.Caption
		lcFontName = this.Header1.FontName
		lnFontSize = -(this.Header1.FontSize * GetDeviceCaps(lhDC, LOGPIXELSX) / 72)
		lhFont = CreateFont(lnFontSize, 0, 0, 0, ;
			IIF(this.Header1.FontBold, FW_BOLD, 0), ;
			IIF(this.Header1.FontItalic, 1, 0), ;
			IIF(this.Header1.FontUnderline, 1, 0), ;
			IIF(this.Header1.FontStrikethru, 1, 0), ;
			DEFAULT_CHARSET, 0, 0, 0, 0, lcFontName)
		
		lhOldFont = SelectObject(lhDC, lhFont)
		
		lsRect = BINTOC(0, "4rs") + BINTOC(0, "4rs") + BINTOC(this.Width, "4rs") + BINTOC(this.Height, "4rs")
		DrawText(lhDC, lcCaption, LEN(lcCaption), @lsRect, DT_CALCRECT + DT_WORDBREAK)
		
		lhFont = SelectObject(lhDC, lhOldFont)
		DeleteObject(lhFont)
		
		tnWidth = CTOBIN(SUBSTR(lsRect, 9, 4), "4rs")
		tnHeight = CTOBIN(SUBSTR(lsRect, 13, 4), "4rs")
	ENDPROC

	PROCEDURE headersort
		LPARAMETERS tnSortOrder
		LOCAL loColumn, lnIndex
		LOCAL ARRAY laColumn(1)
		
		IF this.nType = 2
			DIMENSION laColumn[this.nMergeCount,2]
			FOR lnIndex = 1 TO this.nMergeCount
				loColumn = this.aRefColumns[lnIndex]
				laColumn[lnIndex,1] = loColumn
				laColumn[lnIndex,2] = loColumn.ColumnOrder
			NEXT
			ASORT(laColumn, 2, -1, IIF(VARTYPE(tnSortOrder) = "N" AND tnSortOrder # 0, 1, 0))
			FOR lnIndex = 1 TO this.nMergeCount
				this.aRefColumns[lnIndex] = laColumn[lnIndex,1]
			NEXT
		ENDIF
	ENDPROC

	PROCEDURE Init
		BINDEVENT(this.Header1, "Caption", this, "b_UpdateHeader", 1)
		BINDEVENT(this.Header1, "FontName", this, "b_UpdateHeader", 1)
		BINDEVENT(this.Header1, "FontSize", this, "b_UpdateHeader", 1)
		BINDEVENT(this.Header1, "ForeColor", this, "b_UpdateHeader", 1)
		BINDEVENT(this.Header1, "FontBold", this, "b_UpdateHeader", 1)
		BINDEVENT(this.Header1, "FontItalic", this, "b_UpdateHeader", 1)
		BINDEVENT(this.Header1, "FontStrikethru", this, "b_UpdateHeader", 1)
		BINDEVENT(this.Header1, "FontUnderline", this, "b_UpdateHeader", 1)
	ENDPROC

	PROCEDURE lmovable_assign
		LPARAMETERS tlNewVal
		
		this.lMovable = tlNewVal
		this.Shape1.MouseIcon = IIF(tlNewVal, "common\cursors\header_down.cur", "")
	ENDPROC

	HIDDEN PROCEDURE lresizable_assign
		LPARAMETERS tlNewVal
		
		this.lResizable = tlNewVal
		this.hMoveBar.Visible = tlNewVal
	ENDPROC

	PROCEDURE MiddleClick
		this.Parent.OnMiddleClick(this)
	ENDPROC

	PROCEDURE MouseDown
		LPARAMETERS nButton, nShift, nXCoord, nYCoord
		
		this.Parent.OnMouseDown(this, nButton, nShift, nXCoord, nYCoord)
	ENDPROC

	PROCEDURE MouseEnter
		LPARAMETERS nButton, nShift, nXCoord, nYCoord
		
		this.Parent.OnMouseEnter(this, nButton, nShift, nXCoord, nYCoord)
	ENDPROC

	PROCEDURE MouseLeave
		LPARAMETERS nButton, nShift, nXCoord, nYCoord
		
		this.Parent.OnMouseLeave(this, nButton, nShift, nXCoord, nYCoord)
	ENDPROC

	PROCEDURE MouseMove
		LPARAMETERS nButton, nShift, nXCoord, nYCoord
		
		this.Parent.OnMouseMove(this, nButton, nShift, nXCoord, nYCoord)
	ENDPROC

	PROCEDURE MouseUp
		LPARAMETERS nButton, nShift, nXCoord, nYCoord
		
		this.Parent.OnMouseUp(this, nButton, nShift, nXCoord, nYCoord)
	ENDPROC

	PROCEDURE MouseWheel
		LPARAMETERS nDirection, nShift, nXCoord, nYCoord
		
		this.Parent.OnMouseWheel(this, nDirection, nShift, nXCoord, nYCoord)
	ENDPROC

	PROCEDURE onmouseenter
		LPARAMETERS nButton, nShift, nXCoord, nYCoord
		
		this.Parent.OnMouseEnter(this, nButton, nShift, nXCoord, nYCoord)
	ENDPROC

	HIDDEN PROCEDURE orefheader_assign
		LPARAMETERS toNewVal
		
		this.oRefHeader = toNewVal
		
		IF VARTYPE(this.oRefHeader) = "O"
			BINDEVENT(this.oRefHeader, "Caption", this, "b_UpdateHeader", 1)
			BINDEVENT(this.oRefHeader, "FontName", this, "b_UpdateHeader", 1)
			BINDEVENT(this.oRefHeader, "FontSize", this, "b_UpdateHeader", 1)
			BINDEVENT(this.oRefHeader, "ForeColor", this, "b_UpdateHeader", 1)
			BINDEVENT(this.oRefHeader, "FontBold", this, "b_UpdateHeader", 1)
			BINDEVENT(this.oRefHeader, "FontItalic", this, "b_UpdateHeader", 1)
			BINDEVENT(this.oRefHeader, "FontStrikethru", this, "b_UpdateHeader", 1)
			BINDEVENT(this.oRefHeader, "FontUnderline", this, "b_UpdateHeader", 1)
			BINDEVENT(this.oRefHeader, "BackColor", this, "b_UpdateHeader", 1)
		ENDIF
	ENDPROC

	PROCEDURE reset		&& Resets the Timer control so that it starts counting from 0.
		this.SetColor()
		this.SetPicture()
		this.Caption = []
		this.ToolTipText = []
	ENDPROC

	HIDDEN PROCEDURE resetcaption
		LOCAL lnTxtW, lnTxtH, lnTop, lnLeft, lnAlign
		
		IF this.Parent.lTheme
			this.ImgTheme.Draw()
			RETURN
		ENDIF
			
		STORE 0 TO lnTop, lnLeft, lnTxtW, lnTxtH, lnAlign
		this.GetTxtSize(@lnTxtW, @lnTxtH)
		
		DO CASE
			CASE INLIST(this.nAlignMent, 0, 1, 2, 3)
				lnTop = MAX((this.Height - lnTxtH) / 2, 1)
			CASE INLIST(this.nAlignMent, 4, 5, 6)
				lnTop = 1
			CASE INLIST(this.nAlignMent, 7, 8, 9)
				lnTop = MAX(this.Height - lnTxtH, 1)
		ENDCASE
		
		DO CASE
			CASE INLIST(this.nAlignMent, 2, 3, 6, 9)
				lnLeft = MAX((this.Width - lnTxtW) / 2, 1)
				IF this.Width > lnTxtW
					lnAlign = 2
				ENDIF
			CASE INLIST(this.nAlignMent, 0, 4, 7)
				lnLeft = 1
			CASE INLIST(this.nAlignMent, 1, 5, 8)
				lnLeft = this.Width - lnTxtW
				lnAlign = 1
		ENDCASE
		
		this.Header1.Alignment = lnAlign
		this.Header1.Move(lnLeft, lnTop, lnTxtW, lnTxtH)
	ENDPROC

	PROCEDURE Resize
		this.ImgTheme.ZOrder(1)
		this.ImgTheme.Move(0, 0, this.Width, this.Height)
		
		this.hMoveBar.Move(this.Width - this.hMoveBar.Width, 0, this.hMoveBar.Width, this.Height)
		this.vMoveBar.Move(0, this.Height - this.vMoveBar.Height)
		
		this.LineTop.Move(0, 0, Max(this.Width - 1, 0), 0)
		this.LineBottom.Move(0, this.Height-1, this.Width, 0)
		this.LineLeft.Move(0, 0, 0, this.Height)
		this.LineRight.Move(this.Width - 1, 0, 0, this.Height)
		
		this.Shape1.Move(0, 0, this.Width, this.Height)
		this.Shape1.ZOrder(0)
		
		this.hMoveBar.ZOrder(0)
		this.vMoveBar.ZOrder(0)
		
		IF this.lInit
			this.ResetCaption()
			this.Parent.OnResize(this)
		ENDIF
	ENDPROC

	PROCEDURE RightClick
		this.Parent.OnRightClick(this)
	ENDPROC

	PROCEDURE setcolor
		LPARAMETERS tnColor
		
		IF NOT this.Parent.lTheme
			IF VARTYPE(tnColor)#"N" OR EMPTY(tnColor)
				this.BackStyle = 0
				this.BackColor = this.Parent._BackColor
			ELSE
				this.BackStyle = 1
				this.BackColor = tnColor
			ENDIF
		ENDIF
	ENDPROC

	PROCEDURE setpicture
		LPARAMETERS tcPicture
		
		tcPicture = IIF(VARTYPE(tcPicture)#"C", "", tcPicture)
		
		IF NOT this.Parent.lTheme
			this.imgTheme.Stretch = 1
			this.imgTheme.Picture = tcPicture
			this.imgTheme.Visible = NOT EMPTY(tcPicture)
		ENDIF
	ENDPROC

	PROCEDURE tooltiptext_assign
		LPARAMETERS tcNewVal
		
		this.ToolTipText = tcNewVal
		this.Shape1.ToolTipText = tcNewVal
	ENDPROC

	PROCEDURE hMoveBar.DblClick
		LOCAL loColumn, llLockScreen
		
		IF this.Parent.Parent.oRefGrid.AllowAutoColumnFit < 2
			llLockScreen = thisform.LockScreen
			thisform.LockScreen = .T.
			FOR EACH loColumn IN this.Parent.aRefColumns
				loColumn.AutoFit()
			NEXT
			this.Parent.Parent.HeaderRedraw()
			thisform.LockScreen = llLockScreen
		ENDIF
	ENDPROC

	PROCEDURE hMoveBar.Init
		this.BackStyle = 0
	ENDPROC

	PROCEDURE hMoveBar.MouseDown
		LPARAMETERS nButton, nShift, nXCoord, nYCoord
		
		this.Tag = "Y"
		this.Parent.Bar_MouseDown(nButton, nShift, nXCoord, nYCoord)
	ENDPROC

	PROCEDURE hMoveBar.MouseEnter
		LPARAMETERS nButton, nShift, nXcoord, nYcoord
		
		this.Parent.MouseEnter(nButton, nShift, nXcoord, nYcoord)
	ENDPROC

	PROCEDURE hMoveBar.MouseLeave
		LPARAMETERS nButton, nShift, nXcoord, nYcoord
		
		this.Parent.MouseLeave(nButton, nShift, nXcoord, nYcoord)
	ENDPROC

	PROCEDURE hMoveBar.MouseMove
		LPARAMETERS nButton, nShift, nXCoord, nYCoord
		
		IF nButton = 1 AND this.Tag = "Y"
			this.Parent.Bar_MouseMove(nButton, nShift, nXCoord, nYCoord)
		ENDIF
	ENDPROC

	PROCEDURE hMoveBar.MouseUp
		LPARAMETERS nButton, nShift, nXCoord, nYCoord
		
		this.Tag = ""
		IF nButton = 1
			this.Parent.Bar_MouseUp(nButton, nShift, nXCoord, nYCoord)
		ENDIF
	ENDPROC

	PROCEDURE Shape1.Click
		this.Parent.Click()
	ENDPROC

	PROCEDURE Shape1.DblClick
		this.Parent.DblClick()
	ENDPROC

	PROCEDURE Shape1.Init
		this.BackStyle = 0
	ENDPROC

	PROCEDURE Shape1.MiddleClick
		this.Parent.MiddleClick()
		
	ENDPROC

	PROCEDURE Shape1.MouseDown
		LPARAMETERS nButton, nShift, nXCoord, nYCoord
		
		IF this.Parent.lMovable
			IF this.Parent.Parent.lTheme
				this.Parent.ImgTheme.ThemeState = 3
			ENDIF
		
			this.Tag = "Y"
			this.Parent.Drag_MouseDown(nButton, nShift, nXCoord, nYCoord)
		ENDIF
		
		this.Parent.MouseDown(nButton, nShift, nXCoord, nYCoord)
	ENDPROC

	PROCEDURE Shape1.MouseEnter
		LPARAMETERS nButton, nShift, nXcoord, nYcoord
		
		IF this.Parent.Parent.lTheme
			this.Parent.ImgTheme.ThemeState = 2
		ENDIF
		
		this.Parent.OnMouseEnter(nButton, nShift, nXcoord, nYcoord)
	ENDPROC

	PROCEDURE Shape1.MouseLeave
		LPARAMETERS nButton, nShift, nXcoord, nYcoord
		
		IF this.Parent.Parent.lTheme
			this.Parent.ImgTheme.ThemeState = 1
		ENDIF
		
		this.Parent.MouseLeave(nButton, nShift, nXcoord, nYcoord)
	ENDPROC

	PROCEDURE Shape1.MouseMove
		LPARAMETERS nButton, nShift, nXCoord, nYCoord
		
		IF nButton = 1 AND this.Tag = "Y" AND this.Parent.lMovable
			this.Parent.Drag_MouseMove(nButton, nShift, nXCoord, nYCoord)
		ENDIF
		
		this.Parent.MouseMove(nButton, nShift, nXCoord, nYCoord)
	ENDPROC

	PROCEDURE Shape1.MouseUp
		LPARAMETERS nButton, nShift, nXCoord, nYCoord
		
		IF this.Parent.Parent.lTheme
			this.Parent.ImgTheme.ThemeState = 2
		ENDIF
		
		this.Tag = ""
		IF this.Parent.lMovable
			this.Parent.Drag_MouseUp(nButton, nShift, nXCoord, nYCoord)
		ENDIF
		
		this.Parent.MouseUp(nButton, nShift, nXCoord, nYCoord)
	ENDPROC

	PROCEDURE Shape1.MouseWheel
		LPARAMETERS nDirection, nShift, nXCoord, nYCoord
		
		this.Parent.MouseWheel(nDirection, nShift, nXCoord, nYCoord)
		
	ENDPROC

	PROCEDURE Shape1.RightClick
		this.Parent.RightClick()
	ENDPROC

	PROCEDURE vMoveBar.Init
		this.BackStyle = 0
		this.AddProperty("CurrentTop", 0)
		this.AddProperty("MouseDownX", 0)
		this.AddProperty("MouseDownY", 0)
		this.AddProperty("oRefLine", 0)
	ENDPROC

	PROCEDURE vMoveBar.MouseDown
		LPARAMETERS nButton, nShift, nXCoord, nYCoord
		LOCAL loGrid, loManyH
		
		loGrid = this.Parent.Parent.oRefGrid
		IF VARTYPE(loGrid) = "O"
			loManyH = this.Parent.Parent
			IF nButton = 1
				this.CurrentTop = OBJTOCLIENT(this, 1)
				this.MouseDownX	= nXCoord
				this.MouseDownY	= nYCoord
		
				this.Tag = "Y"
				thisform.AddObject("_" + Sys(2015), "Line")
				this.oRefLine = thisform.Controls(thisform.ControlCount)
				this.oRefLine.DrawMode = this.Parent.Shape1.DrawMode
				this.oRefLine.AddProperty("nRangeMinY", OBJTOCLIENT(loManyH, 1))
				this.oRefLine.AddProperty("nRangeMaxY", OBJTOCLIENT(loManyH, 1) + loManyH.Height)
				this.oRefLine.Move(OBJTOCLIENT(loManyH, 2), OBJTOCLIENT(this, 1) + this.Height / 2, loManyH.Width, 0)
				this.oRefLine.Visible = .T.
			ENDIF
		ENDIF
	ENDPROC

	PROCEDURE vMoveBar.MouseEnter
		LPARAMETERS nButton, nShift, nXcoord, nYcoord
		
		this.Parent.MouseEnter(nButton, nShift, nXcoord, nYcoord)
	ENDPROC

	PROCEDURE vMoveBar.MouseLeave
		LPARAMETERS nButton, nShift, nXcoord, nYcoord
		
		this.Parent.MouseLeave(nButton, nShift, nXcoord, nYcoord)
	ENDPROC

	PROCEDURE vMoveBar.MouseMove
		LPARAMETERS nButton, nShift, nXCoord, nYCoord
		LOCAL lnTop
		
		IF nButton = 1 AND this.Tag = "Y" AND VARTYPE(this.oRefLine) = "O"
			lnTop = this.CurrentTop - this.MouseDownY + nYCoord
			this.oRefLine.Top = MIN(this.oRefLine.nRangeMaxY, MAX(lnTop, this.oRefLine.nRangeMinY))
		ENDIF
	ENDPROC

	PROCEDURE vMoveBar.MouseUp
		LPARAMETERS nButton, nShift, nXCoord, nYCoord
		LOCAL lnHeight, loHeader
		
		this.Tag = ""
		IF NOT ISNULL(this.oRefLine)
			thisform.RemoveObject(this.oRefLine.Name)
			this.oRefLine = .NULL.
		ENDIF
		
		IF nYCoord # this.MouseDownX
			lnHeight = this.Parent.Height - this.MouseDownY + nYCoord
			this.Parent.nHeight = this.Parent.Height - this.MouseDownY + nYCoord
			IF BITTEST(GetKeyState(17), 15)
				FOR EACH loHeader IN this.Parent.Parent.Controls
					IF loHeader.Class == this.Parent.Class
						loHeader.nHeight = lnHeight
					ENDIF
				NEXT
				loHeader = .NULL.
			ELSE
				this.Parent.nHeight = lnHeight
			ENDIF
		
			this.Parent.Parent.HeaderRedraw()
		ENDIF
	ENDPROC

ENDDEFINE

DEFINE CLASS tcntthemedmanyheader AS tcontainer OF "_lvisual.vcx" 
 	*< CLASSDATA: Baseclass="container" Timestamp="" Scale="Pixels" Uniqueid="" />

	#INCLUDE "themedcontrols.h"
	*<DefinedPropArrayMethod>
		*m: bindevents
		*m: controlcreate
		*m: declare_dlls
		*m: ev_afterrowcolchange
		*m: ev_formlostfocus
		*m: ev_headerredraw
		*m: ev_keypress
		*m: ev_lockscreenbefore
		*m: ev_mousedown
		*m: ev_mouseup
		*m: ev_parentresize
		*m: ev_scrolled
		*m: ev_valid
		*m: ev_visible
		*m: getcolumn
		*m: getcolumnheader
		*m: getcolumnvisible
		*m: getgridcolumn
		*m: getgroupmax
		*m: getgroupmin
		*m: getheaderleft
		*m: getheaderright
		*m: getleftcolumn
		*m: getrefheader
		*m: getrefheaderdown
		*m: headerclear
		*m: headerdel
		*m: headerdelete
		*m: headerlock
		*m: headerlockcheck
		*m: headerlockex
		*m: headerredraw
		*m: headerredrawhor
		*m: headerresize
		*m: headerswap
		*m: initheader
		*m: llock_assign
		*m: makeunlockscreentimer
		*m: mergecleartry
		*m: mergeheader
		*m: onclick
		*m: ondblclick		&& ±
		*m: ondrag
		*m: onlock
		*m: onmiddleclick
		*m: onmousedown
		*m: onmouseenter
		*m: onmouseleave
		*m: onmousemove
		*m: onmouseup
		*m: onmousewheel
		*m: onresize
		*m: onrightclick
		*m: onstyle
		*m: onthemestyle
		*m: orefgrid_assign
		*m: panelcreate
		*m: paneldestroy
		*m: setcaptionshor
		*m: setcolorshor
		*m: splitheader
		*m: splitheaderhor
		*m: unlockscreen
		*m: visible_assign
		*p: hproc		&& call proc handle
		*p: lalignment
		*p: llock
		*p: llockscreen
		*p: lmaster
		*p: lsplitbar
		*p: ltheme
		*p: nclicksecond
		*p: ndeletemark
		*p: nleftcolumn
		*p: nleftoffset
		*p: nlock
		*p: nminlock
		*p: npanel
		*p: nrecordmark
		*p: nref
		*p: ntopoffset
		*p: nwhere_out
		*p: orefgrid
		*p: orefpanel
		*p: wm_code
		*a: acolumn[1,0]
		*a: areflocks[1,0]
		*p: _align		&& Default merge header align ment.
		*p: _backcolor		&& Default merge header back color.If the value is equal to -1, Get system color.(Note:When lTheme = .T., this value there is no role.)
		*p: _fontname		&& Default merge header font name, If the value is equal to empty, Get grid FontName.
		*p: _fontsize		&& Default merge header font size.If the value is equal to -1, Get grid FontSize
		*p: _fontstyle		&& Default merge header font Style(Sample: "BIDU")
		*p: _forecolor		&& Default merge header fore color.If the value is equal to -1, Get system color.(Note:When lTheme = .T., this value there is no role.)
	*</DefinedPropArrayMethod>

	HIDDEN hproc,llockscreen,nclicksecond
	Anchor = 0
	BackStyle = 1
	Height = 28
	hproc = 0		&& call proc handle
	llock = .T.
	lmaster = .T.
	lsplitbar = .T.
	ltheme = .T.
	Name = "tcntthemedmanyheader"
	nclicksecond = 0
	ndeletemark = 8
	nleftcolumn = 0
	nleftoffset = 0
	nlock = 0
	nminlock = 0
	npanel = 1
	nrecordmark = 10
	nref = -1
	ntopoffset = 0
	nwhere_out = 0
	orefgrid = .NULL.
	orefpanel = .NULL.
	Picture = ..\picts\gridbg.gif
	Visible = .F.
	wm_code = 0
	_align = 3		&& Default merge header align ment.
	_backcolor = -1		&& Default merge header back color.If the value is equal to -1, Get system color.(Note:When lTheme = .T., this value there is no role.)
	_fontname = 		&& Default merge header font name, If the value is equal to empty, Get grid FontName.
	_fontsize = -1		&& Default merge header font size.If the value is equal to -1, Get grid FontSize
	_fontstyle = 		&& Default merge header font Style(Sample: "BIDU")
	_forecolor = -1		&& Default merge header fore color.If the value is equal to -1, Get system color.(Note:When lTheme = .T., this value there is no role.)
	
	PROCEDURE bindevents
		#IF VERSION(5) > 600
			BINDEVENT(thisform, "Refresh", this, "ev_FormLostFocus")
			BINDEVENT(thisform, "LostFocus", this, "ev_FormLostFocus")
		
			BINDEVENT(this.oRefGrid, "AfterRowColChange", this, "Ev_AfterRowColChange")
			BINDEVENT(this.oRefGrid, "MouseDown", this, "Ev_MouseDown")
			BINDEVENT(this.oRefGrid, "MouseUp", this, "Ev_MouseUp")
			BINDEVENT(this.oRefGrid, "KeyPress", this, "Ev_KeyPress")
			BINDEVENT(this.oRefGrid, "Scrolled", this, "Ev_Scrolled")
			BINDEVENT(this.oRefGrid, "Valid", this, "Ev_Valid")
			BINDEVENT(this.oRefGrid, "AutoFit", this, "HeaderRedraw", 1)
			BINDEVENT(this.oRefGrid, "Resize", this, "HeaderResize")
			BINDEVENT(this.oRefGrid, "Moved", this, "HeaderResize")
			BINDEVENT(this.oRefGrid, "HeaderHeight", this, "Ev_LockScreenBefore")
			BINDEVENT(this.oRefGrid, "HeaderHeight", this, "Ev_HeaderRedraw", 1)
			BINDEVENT(this.oRefGrid, "Visible", this, "Ev_LockScreenBefore")
			BINDEVENT(this.oRefGrid, "Visible", this, "Ev_Visible", 1)
			
			IF UPPER(this.oRefGrid.Parent.BaseClass) == UPPER("Container")
				BINDEVENT(this.oRefGrid.Parent, "Resize", this, "Ev_LockScreenBefore")
				BINDEVENT(this.oRefGrid.Parent, "Resize", this, "Ev_ParentResize", 1)
			ENDIF
		#ENDIF
	ENDPROC

	HIDDEN PROCEDURE controlcreate
		#IF VERSION(5) > 600
			IF this.lLock AND this.ControlCount > 0
				this.HeaderRedraw()
			ENDIF
		#ENDIF
	ENDPROC

	PROCEDURE declare_dlls
		DECLARE LONG GetSysColor IN "User32" LONG
		DECLARE LONG GetKeyState IN "User32" LONG nVirtKey
		DECLARE LONG DrawText IN "User32" LONG hDC, STRING lpSTRING, LONG nCount, STRING @lpRect, LONG uFormat
		DECLARE LONG GetDC IN "User32" LONG hWnd
		DECLARE LONG ReleaseDC IN "User32" LONG hWnd, LONG hDC
		
		DECLARE LONG CreateCompatibleDC IN "Gdi32" LONG hDC
		DECLARE LONG CreateCompatibleBitmap IN "Gdi32" LONG hDC, LONG nWidth, LONG nHeight 
		DECLARE LONG GetDeviceCaps IN "Gdi32" LONG hDC, LONG nIndex
		DECLARE LONG GetDIBits IN "Gdi32" LONG hDC, LONG hBmp, LONG uStartScan, LONG cScanLines, LONG lpvBits, STRING @lpbi, LONG uUsage
		DECLARE LONG SelectObject IN "Gdi32" LONG hDC, LONG hObject
		DECLARE LONG DeleteDC IN "Gdi32" LONG hDC
		DECLARE LONG DeleteObject IN "Gdi32" LONG hDC
		DECLARE LONG CreateFont IN "Gdi32" LONG nHeight, LONG nWidth, LONG nEscapement, LONG nOrientation, LONG fnWeight, ;
			LONG fdwItalic, LONG fdwUnderline, LONG fdwStrikeOut, LONG fdwCharSet, LONG fdwOutputPrecision, ;
			LONG fdwClipPrecision, LONG fdwQuality, LONG fdwPitchAndFamily, STRING lpszFace
		
		DECLARE LONG OpenThemeData IN "UxTheme" LONG hWnd, STRING pszClassList
		DECLARE LONG DrawThemeBackground IN "UxTheme" LONG hTheme, LONG hDC, LONG iPartId, LONG iStateId, STRING @pRect, STRING @pClipRect
		DECLARE LONG DrawThemeText IN "UxTheme" LONG hTheme, LONG hDC, LONG iPartId, LONG iStateId, ;
			STRING pszText, LONG iCharCount, LONG dwTextFlag, LONG dwTextFlags2, STRING pRect
		DECLARE LONG GetThemeTextExtent IN "UxTheme" LONG hTheme, LONG hDC, LONG iPartId, LONG iStateId, ;
			STRING pszText, LONG iCharCount, LONG dwTextFlags, STRING @pBoundingRect, STRING @pExtentRect
		DECLARE LONG CloseThemeData IN "UxTheme" LONG hTheme
		DECLARE LONG GetThemePartSize IN "UxTheme" LONG hTheme, LONG hDC, LONG iPartId, LONG iStateId, STRING @prc, LONG eSize, STRING @psz
		
		DECLARE LONG LocalAlloc IN "Kernel32" LONG uFlags, LONG dwBytes
		DECLARE LONG LocalFree IN "Kernel32" LONG hLocMem
	ENDPROC

	PROCEDURE Destroy
		LOCAL loColumn, lnRef, lnMax
		
		UNBINDEVENTS(thisform, "Refresh", this, "ev_FormLostFocus")
		UNBINDEVENTS(thisform, "LostFocus", this, "ev_FormLostFocus")
		this.oRefGrid = .NULL.
	ENDPROC

	PROCEDURE ev_afterrowcolchange
		LPARAMETERS nColIndex
		LOCAL lnLeftColumn, llLockScreen
		
		IF VARTYPE(this.oRefGrid) = "O"
			llLockScreen = thisform.LockScreen
			thisform.LockScreen = .T.
		
			DO CASE
				CASE this.oRefGrid.Panel = this.nPanel
					lnLeftColumn = this.GetLeftColumn()
					IF lnLeftColumn # this.nLeftColumn
						this.nLeftColumn = lnLeftColumn
						this.HeaderLockEx()
						this.HeaderRedraw()
					ENDIF
				CASE NOT ISNULL(this.oRefPanel)
					lnLeftColumn = this.oRefPanel.GetLeftColumn()
					IF lnLeftColumn # this.oRefPanel.nLeftColumn
						this.oRefPanel.nLeftColumn = lnLeftColumn
						this.oRefPanel.HeaderLockEx()
						this.oRefPanel.HeaderRedraw()
					ENDIF
			ENDCASE
		
			thisform.LockScreen = llLockScreen
		ENDIF
	ENDPROC

	PROCEDURE ev_formlostfocus
		LOCAL llLockScreen
		
		IF VARTYPE(this.oRefGrid) = "O"
			llLockScreen = thisform.LockScreen
			thisform.LockScreen = .T.
			this.oRefGrid.Refresh()
			this.HeaderRedraw()
			thisform.LockScreen = llLockScreen
		ENDIF
	ENDPROC

	HIDDEN PROCEDURE ev_headerredraw
		IF this.lMaster AND VARTYPE(this.oRefGrid) = "O"
			this.Visible = (this.oRefGrid.Visible AND this.oRefGrid.HeaderHeight > 0)
			this.HeaderResize()
			IF NOT ISNULL(this.oRefPanel)
				this.oRefPanel.HeaderResize()
			ENDIF
		ENDIF
		
		thisform.LockScreen = this.lLockScreen
	ENDPROC

	PROCEDURE ev_keypress
		LPARAMETERS nKeyCode, nShiftAltCtrl
		
		IF VARTYPE(this.oRefGrid) = "O" AND NOT this.oRefGrid.AllowCellSelection
			this.UnLockScreen()
		ENDIF
	ENDPROC

	HIDDEN PROCEDURE ev_lockscreenbefore
		IF this.lMaster
			this.lLockScreen = thisform.LockScreen
			thisform.LockScreen = .T.
		ENDIF
	ENDPROC

	PROCEDURE ev_mousedown
		LPARAMETERS nButton, nShift, nXCoord, nYCoord
		LOCAL lnWhere_Out
		
		IF NOT VARTYPE(this.oRefGrid) = "O"
			RETURN
		ENDIF
		
		lnWhere_Out = 0
		this.oRefGrid.GridHitTest(nXCoord, nYCoord, @lnWhere_Out)
		this.nWhere_Out = lnWhere_Out
		
		DO CASE
			CASE lnWhere_Out = 11
				IF SECONDS() <= this.nClickSecond + _DBLCLICK
					this.nClickSecond = IIF(NOT thisform.LockScreen, -1, -2)
					thisform.LockScreen = .T.
				ELSE
					this.nClickSecond = SECONDS()
				ENDIF
			CASE INLIST(lnWhere_Out, 5, 16)
				this.UnLockScreen()
		ENDCASE
	ENDPROC

	PROCEDURE ev_mouseup
		LPARAMETERS nButton, nShift, nXCoord, nYCoord
		LOCAL llLockScreen
		
		IF this.lMaster
			llLockScreen = thisform.LockScreen
			thisform.LockScreen = .T.
		
			IF INLIST(this.nWhere_Out, 5, 11)
				this.HeaderResize()
		
				IF this.oRefGrid.Partition > 0
					IF NOT ISNULL(this.oRefPanel)
						this.oRefPanel.HeaderResize()
					ENDIF
				ELSE
					this.PanelDestroy()
				ENDIF
			ENDIF
		
			DO CASE
				CASE this.nClickSecond >= 0
					thisform.LockScreen = llLockScreen
				CASE this.nClickSecond = -2
					thisform.LockScreen = .T.
				OTHERWISE
					thisform.LockScreen = .F.
			ENDCASE
		ENDIF
	ENDPROC

	HIDDEN PROCEDURE ev_parentresize
		IF VARTYPE(this.oRefGrid) = "O"
			this.Visible = (this.oRefGrid.Parent.Height > 0 AND this.oRefGrid.Visible)
		ENDIF
		
		thisform.LockScreen = this.lLockScreen
	ENDPROC

	PROCEDURE ev_scrolled
		LPARAMETERS nDirection
		
		IF VARTYPE(this.oRefGrid) = "O" AND VARTYPE(nDirection) = "N" AND nDirection >= 4
			DO CASE
				CASE this.oRefGrid.Panel = this.nPanel
					this.nLeftColumn = this.GetLeftColumn()
					this.HeaderLockEx()
					this.HeaderRedraw()
				CASE NOT ISNULL(this.oRefPanel)
					this.oRefPanel.nLeftColumn = this.oRefPanel.GetLeftColumn()
					this.oRefPanel.HeaderLockEx()
					this.oRefPanel.HeaderRedraw()
			ENDCASE
		ENDIF
	ENDPROC

	PROCEDURE ev_valid
		this.UnLockScreen()
	ENDPROC

	HIDDEN PROCEDURE ev_visible
		IF this.lMaster 
			IF VARTYPE(this.oRefGrid) = "O"
				If this.oRefGrid.Visible = .F.
					this.Visible = .F.
				ELSE
					this.HeaderRedraw()
					this.Visible = .T.
					this.ZOrder(0)
				ENDIF
			ENDIF
		
			thisform.LockScreen = this.lLockScreen
		ENDIF
	ENDPROC

	PROCEDURE getcolumn
		LPARAMETERS tnOrder
		
		RETURN this.oRefGrid.Columns(ASCAN(this.aColumn, tnOrder))
	ENDPROC

	PROCEDURE getcolumnheader
		LPARAMETERS toColumn
		LOCAL loHeader
		
		FOR EACH loHeader IN toColumn.Controls
			IF UPPER(loHeader.BaseClass) = "HEADER"
				RETURN loHeader
			ENDIF
		NEXT
		
		RETURN .NULL.
	ENDPROC

	PROCEDURE getcolumnvisible
		LPARAMETERS toColumn
		LOCAL loHeader
		
		IF toColumn.Visible 
			IF toColumn.ControlCount > 0
				loHeader = this.GetColumnHeader(toColumn)
				IF NOT ISNULL(loHeader)
					RETURN OBJTOCLIENT(loHeader, 2) > 0
				ENDIF
			ENDIF
			RETURN OBJTOCLIENT(toColumn, 2) # OBJTOCLIENT(toColumn.Parent, 2)
		ELSE
			RETURN VERSION(5) <= 600
		ENDIF
	ENDPROC

	PROCEDURE getgridcolumn
		LOCAL lnIndex
		
		IF this.oRefGrid.ColumnCount = 0
			DIMENSION this.aColumn[1]
			this.aColumn = .NULL.
		ELSE
			DIMENSION this.aColumn[this.oRefGrid.ColumnCount]
			FOR lnIndex = 1 TO this.oRefGrid.ColumnCount
				this.aColumn[lnIndex] = this.oRefGrid.Columns(lnIndex).ColumnOrder
			NEXT
		ENDIF
	ENDPROC

	PROCEDURE getgroupmax
		LPARAMETERS toHeader
		LOCAL lnMaxOrder, loColumn
		
		lnMaxOrder = this.oRefGrid.ColumnCount
		FOR EACH loColumn IN toHeader.aRefColumns
			lnMaxOrder = MAX(loColumn.ColumnOrder, lnMaxOrder)
		NEXT
		
		RETURN lnMaxOrder
	ENDPROC

	PROCEDURE getgroupmin
		LPARAMETERS toHeader
		LOCAL lnMinOrder, loColumn
		
		lnMinOrder = this.oRefGrid.ColumnCount
		FOR EACH loColumn IN toHeader.aRefColumns
			lnMinOrder = MIN(loColumn.ColumnOrder, lnMinOrder)
		NEXT
		
		RETURN lnMinOrder
	ENDPROC

	PROCEDURE getheaderleft
		LPARAMETERS toHeader
		LOCAL loColumn, lnMinOrder, loHeader
		
		DO CASE
			CASE toHeader.nType = 0
				IF toHeader.aRefColumns[1].ColumnOrder = 1
					RETURN .NULL.
				ENDIF
				loColumn = this.GetColumn(toHeader.aRefColumns[1].ColumnOrder - 1)
				loHeader = this.GetRefHeader(loColumn)	
				IF ISNULL(loHeader.oRefup)
					RETURN loHeader
				ELSE
					RETURN loHeader.oRefup
				ENDIF
			CASE toHeader.nType = 1
				lnMinOrder = this.GetGroupMin(toHeader.oRefup)
				IF lnMinOrder = toHeader.aRefColumns[1].ColumnOrder
					RETURN .NULL.
				ELSE
					loColumn = this.GetColumn(toHeader.aRefColumns[1].ColumnOrder - 1)
					RETURN this.GetRefHeader(loColumn)
				ENDIF
			CASE toHeader.nType = 2
				lnMinOrder = this.GetGroupMin(toHeader)
				IF lnMinOrder = 1
					RETURN .NULL.
				ELSE
					loColumn = this.GetColumn(lnMinOrder - 1)
					loHeader = this.GetRefHeader(loColumn)
					IF ISNULL(loHeader.oRefup)
						RETURN loHeader
					ELSE
						RETURN loHeader.oRefup
					ENDIF
				ENDIF
			OTHERWISE
		ENDCASE
	ENDPROC

	PROCEDURE getheaderright
		LPARAMETERS toHeader
		LOCAL loColumn, lnMaxOrder, loHeader
		
		DO CASE
			CASE toHeader.nType = 0
				IF toHeader.aRefColumns[1].ColumnOrder >= this.oRefGrid.ColumnCount
					RETURN .NULL.
				ENDIF
				loColumn = this.GetColumn(toHeader.aRefColumns[1].ColumnOrder + 1)
				loHeader = this.GetRefHeader(loColumn)
				IF ISNULL(loHeader.oRefup)
					RETURN loHeader
				ELSE
					RETURN loHeader.oRefup
				ENDIF
			CASE toHeader.nType = 1
				lnMaxOrder = this.GetGroupMax(toHeader.oRefup)
				IF lnMaxOrder = toHeader.aRefColumns[1].ColumnOrder
					RETURN .NULL.
				ELSE
					loColumn = this.GetColumn(toHeader.aRefColumns[1].ColumnOrder + 1)
					RETURN this.GetRefHeader(loColumn)
				ENDIF
			CASE toHeader.nType = 2
				lnMaxOrder = this.GetGroupMax(toHeader)
				IF lnMaxOrder >= this.oRefGrid.ColumnCount
					RETURN .NULL.
				ELSE
					loColumn = this.GetColumn(lnMaxOrder + 1)
					loHeader = this.GetRefHeader(loColumn)
					IF ISNULL(loHeader.oRefup)
						RETURN loHeader
					ELSE
						RETURN loHeader.oRefup
					ENDIF
				ENDIF
			OTHERWISE
		ENDCASE
	ENDPROC

	PROCEDURE getleftcolumn
		LOCAL lnIndex, loColumn, lcLockColumns
		
		lcLockColumns = IIF(this.oRefGrid.Panel = 1, "LockColumns", "LockColumnsLeft")
		
		IF this.oRefGrid.&lcLockColumns = 0
			RETURN this.oRefGrid.LeftColumn
		ELSE
			FOR lnIndex = this.oRefGrid.&lcLockColumns + 1 TO this.oRefGrid.ColumnCount
				loColumn = this.GetColumn(lnIndex)
				IF this.GetColumnVisible(loColumn)
					RETURN lnIndex
				ENDIF
			NEXT
			RETURN 0
		ENDIF
	ENDPROC

	PROCEDURE getrefheader
		LPARAMETERS toColumn
		
		RETURN toColumn.aRefHeaders[this.nRef]
	ENDPROC

	PROCEDURE getrefheaderdown
		LPARAMETERS toColumn
		
		RETURN toColumn.aRefHeaders[this.nRef].oRefDown
	ENDPROC

	PROCEDURE headerclear
		DO WHILE this.ControlCount > 0
			this.RemoveObject(this.Controls(1).Name)
		ENDDO
		this.ControlCreate()
	ENDPROC

	HIDDEN PROCEDURE headerdel
		LPARAMETERS tvHeader
		LOCAL loHeader, loRefColumn, loRefHeader, lnIndex, loRefup, loColumn, llMovable, llResizable, lnMinOrder, lnMaxOrder
		
		DO CASE
			CASE VARTYPE(tvHeader) = "N" AND BETWEEN(tvHeader, 1, this.oRefGrid.ColumnCount)
				loHeader = this.GetRefHeader(this.GetColumn(tvHeader))
			CASE VARTYPE(tvHeader) = "O"
				loHeader = tvHeader
			OTHERWISE
				RETURN
		ENDCASE
		
		DO CASE
			CASE loHeader.nType = 0
			CASE loHeader.nType = 1 AND NOT ISNULL(loHeader.oRefup)
				loRefup = loHeader.oRefup
				IF BETWEEN(loRefup.nMergeCount, 1, 2)
					this.HeaderDel(loRefup)
				ELSE
					loRefColumn = loHeader.aRefColumns[1]
					loRefHeader = this.GetRefHeader(loRefColumn)
					FOR lnIndex = 1 TO loRefup.nMergeCount
						IF loRefup.aRefColumns[lnIndex] = loRefColumn
							ADEL(loRefup.aRefColumns, lnIndex)
							EXIT
						ENDIF
					NEXT
					loRefup.nMergeCount = loRefup.nMergeCount - 1
					DIMENSION loRefup.aRefColumns[loRefup.nMergeCount]
					loRefHeader.nType = 0
					loRefHeader.oRefup = .NULL.
		
					llMoveable = .F.
					llResizable = .F.
					FOR EACH loColumn IN loRefup.aRefColumns
						llMovable = IIF(loColumn.Movable, .T., llMoveable)
						llResizable = IIF(loColumn.Movable, .T., llResizable)
					NEXT
					loRefup.lMovable = llMovable
					loRefup.lResizable = llResizable
		
					lnMinOrder = this.GetGroupMin(loRefup)
					lnMaxOrder = this.GetGroupMax(loRefup)
					IF BETWEEN(loRefColumn.ColumnOrder, lnMinOrder + 1, lnMaxOrder - 1)
						DO WHILE loRefColumn.ColumnOrder < lnMaxOrder
							loRefColumn.ColumnOrder = loRefColumn.ColumnOrder + 1
						ENDDO
						this.GetGridColumn()
					ENDIF
				ENDIF
			CASE loHeader.nType = 2
				FOR EACH loColumn IN loHeader.aRefColumns
					loRefHeader = this.GetRefHeader(loColumn)
					loRefHeader.nType = 0
					loRefHeader.oRefup = .NULL.
				NEXT
				this.RemoveObject(loHeader.Name)
		ENDCASE
	ENDPROC

	PROCEDURE headerdelete
		LPARAMETERS toHeader
		LOCAL loColumn, loHeader
		
		IF this.lMaster AND NOT ISNULL(this.oRefPanel)
			IF VARTYPE(toHeader) = "O"
				loColumn = toHeader.aRefColumns[1]
				loHeader = loColumn.aRefHeaders[this.oRefPanel.nRef]
				IF toHeader.nType = 2
					this.oRefPanel.HeaderDelete(loHeader.oRefUp)
				ELSE
					this.oRefPanel.HeaderDelete(loHeader)
				ENDIF
			ELSE
				this.oRefPanel.HeaderDelete(toHeader)
			ENDIF
			this.oRefPanel.HeaderRedraw()
		ENDIF
		
		this.GetGridColumn()
		this.HeaderDel(toHeader)
		this.HeaderRedraw()
	ENDPROC

	PROCEDURE headerlock
		LPARAMETERS tnVal
		LOCAL ARRAY laColumns[1]
		LOCAL lnPanel, loGrid, lnLock, lnOrder, loColumn, loHeader, lnIndex, lnLoop, loRightColumn, llLockScreen
		
		IF VARTYPE(this.oRefGrid) # "O" OR this.nLock = tnVal
			RETURN
		ENDIF
		
		loGrid = this.oRefGrid
		lnPanel = loGrid.Panel
		loGrid.Panel = this.nPanel
		
		IF NOT this.HeaderLockCheck(tnVal)
			this.HeaderRedraw()
			MESSAGEBOX(ManyHeader_HeaderLock_1)
			RETURN .F.
		ENDIF
		
		llLockScreen = thisform.LockScreen
		thisform.LockScreen = .T.
		lnLock = 1
		lnOrder = 0
		FOR lnIndex = loGrid.LeftColumn TO loGrid.ColumnCount
			loColumn = this.GetColumn(lnIndex)
			IF NOT this.GetColumnVisible(loColumn)
				LOOP
			ENDIF
		
			lnOrder = lnOrder + 1
			DIMENSION laColumns[lnOrder]
			laColumns[lnOrder] = loColumn
			lnLock = lnLock + 1
			IF lnLock > tnVal
				EXIT
			ENDIF
		NEXT
		
		IF loColumn.ColumnOrder <> loGrid.ColumnCount
			loRightColumn = this.GetColumn(loColumn.ColumnOrder + 1)
		ELSE
			loRightColumn = .NULL.
		ENDIF
		
		loHeader = this.GetRefHeader(loColumn)
		IF loHeader.nType = 1
			loHeader = this.GetHeaderRight(loHeader)
			DO WHILE NOT ISNULL(loHeader)
				lnOrder = lnOrder + 1
				DIMENSION laColumns[lnOrder]
				laColumns[lnOrder] = loHeader.aRefColumns
				loHeader = this.GetHeaderRight(loHeader)
			ENDDO
		ENDIF
		
		lnLoop = 0
		FOR lnIndex = 1 TO lnOrder
			loColumn = laColumns[lnIndex]
			DO WHILE loColumn.ColumnOrder > lnIndex
				lnLoop = lnLoop + 1
				loColumn.ColumnOrder = loColumn.ColumnOrder - 1
			ENDDO
		NEXT
		IF this.nPanel = 1
			loGrid.LockColumns = MAX(tnVal, 0)
		ELSE
			loGrid.LockColumnsLeft = MAX(tnVal, 0)
		ENDIF
		
		IF NOT ISNULL(loRightColumn) AND tnVal > 0
			FOR lnIndex = 1 TO loGrid.ColumnCount
				IF this.GetColumnVisible(loRightColumn)
					EXIT
				ENDIF
				loGrid.DoScroll(5)
			NEXT
			FOR lnIndex = 1 TO loGrid.ColumnCount
				IF NOT this.GetColumnVisible(loRightColumn)
					EXIT 
				ENDIF
				loGrid.DoScroll(5)
			NEXT
			IF NOT this.GetColumnVisible(loRightColumn)
				loGrid.DoScroll(4)
			ENDIF
		ENDIF
		
		loGrid.Panel = lnPanel
		this.GetGridColumn()
		this.HeaderRedraw()
		
		IF NOT ISNULL(this.oRefPanel)
			this.oRefPanel.GetGridColumn()
			this.oRefPanel.HeaderRedraw()
		ENDIF
		
		thisform.LockScreen = llLockScreen
		this.nLock = tnVal
		this.OnLock(tnVal)
	ENDPROC

	HIDDEN PROCEDURE headerlockcheck
		LPARAMETERS tnVal
		LOCAL loCurColumn, loColumn, loHeader, lnLock, lnOrder
		
		IF tnVal > 0
			lnLock = 0
			lnOrder = 1
			DO WHILE lnLock < tnVal AND lnOrder < this.oRefGrid.ColumnCount
				loCurColumn = this.GetColumn(lnOrder)
				loHeader = loCurColumn.aRefHeaders[this.nRef]
		
				IF loHeader.nType = 0 AND NOT this.GetColumnVisible(loCurColumn)
					lnOrder = lnOrder + 1
					LOOP
				ENDIF
		
				IF loHeader.nType = 0
					lnOrder = lnOrder + 1
					lnLock = lnLock + 1
					LOOP
				ENDIF
		
				loHeader = loHeader.oRefup
				IF NOT loHeader.Visible 
					lnOrder = lnOrder + loHeader.nMergeCount
					LOOP
				ENDIF
		
				loHeader.HeaderSort(0)
				FOR EACH loColumn IN loHeader.aRefColumns
					IF lnLock > tnVal
						RETURN .T.
					ENDIF
					IF NOT this.GetColumnVisible(loColumn)
						RETURN .F.
					ENDIF
					lnOrder = lnOrder + 1
					lnLock = lnLock + 1
				NEXT
			ENDDO
		ENDIF
		
		RETURN .T.
	ENDPROC

	PROCEDURE headerlockex
		LOCAL loColumn
		
		IF .F. AND this.nLock > 0
			loColumn = this.oRefGrid.Column1
			DO CASE
				CASE loColumn.ColumnOrder < this.nLeftColumn
					DO WHILE loColumn.ColumnOrder < this.nLeftColumn
						loColumn.ColumnOrder = loColumn.ColumnOrder + 1
					ENDDO
					this.GetGridColumn()
				CASE loColumn.ColumnOrder > this.nLeftColumn
					DO WHILE loColumn.ColumnOrder > this.nLeftColumn
						loColumn.ColumnOrder = loColumn.ColumnOrder - 1
					ENDDO
					this.GetGridColumn()
			ENDCASE
		ENDIF
	ENDPROC

	PROCEDURE headerredraw
		LOCAL loLockup, lnIndex, loColumn, loHeader, lnLeft, lnTop, lnWidth, lnHeight, llLockScreen, lnPanel
		
		IF NOT VARTYPE(this.oRefGrid) = "O"
			RETURN
		ENDIF
		
		llLockScreen = thisform.LockScreen
		thisform.LockScreen = .T.
		
		lnPanel = this.oRefGrid.Panel
		this.oRefGrid.Panel = this.nPanel
		
		this.SetAll("Visible", .F., "tcntThemedHeader")
		
		lnLeft = 0
		loLockUp = .NULL.
		loHeader = .NULL.
		loColumn = .NULL.
		FOR lnIndex = this.oRefGrid.LeftColumn TO this.oRefGrid.ColumnCount
			loColumn = this.GetColumn(lnIndex)
			IF NOT this.GetColumnVisible(loColumn)
				LOOP
			ENDIF
		
			loHeader = this.GetRefHeader(loColumn)
			lnTop = 0
			lnWidth = loColumn.Width + 1
			lnHeight = this.Height
		
			IF lnLeft + lnWidth > this.Width
				lnWidth = this.Width - lnLeft
			ENDIF
		
			DO CASE
				CASE NOT ISNULL(loHeader.oRefUp)
					IF loHeader.oRefUp.nHeight > 0
						lnHeight = MIN(lnHeight, loHeader.oRefUp.nHeight)
					ELSE
						lnHeight = INT(lnHeight/2)
					ENDIF
		
					lnTop = 0
					this.HeaderRedrawHor(loHeader.oRefUp, lnLeft, lnTop, lnWidth, lnHeight)
					lnTop = lnHeight
		
					lnHeight = this.Height - lnHeight
				CASE NOT ISNULL(loHeader.oRefDown)
					IF loHeader.oRefDown.nHeight > 0
						lnHeight = MIN(lnHeight, loHeader.oRefDown.nHeight)
					ELSE
						lnHeight = INT(lnHeight/2)
					ENDIF
		
					lnTop = lnHeight
					this.HeaderRedrawHor(loHeader.oRefDown, lnLeft, lnTop, lnWidth, lnHeight)
					lnTop = 0
		
					lnHeight = this.Height - lnHeight
				OTHERWISE
			ENDCASE
		
			this.HeaderRedrawHor(loHeader, lnLeft, lnTop, lnWidth, lnHeight)
			lnLeft = lnLeft + lnWidth
		
			IF lnLeft >= this.Width
				EXIT
			ENDIF
		NEXT
		
		this.oRefGrid.Panel = lnPanel
		this.Refresh()
		thisform.LockScreen = llLockScreen
	ENDPROC

	PROCEDURE headerredrawhor
		LPARAMETERS toHeader, tnLeft, tnTop, tnWidth, tnHeight
		* Display horizontaly splitted header on one column. 
		LOCAL i, lnLeftSH, lnWidthSH, lnWidthRest
		
		lnLeftSH = tnLeft
		lnWidthSH = tnWidth
		lnWidthRest = tnWidth
		FOR i = 1 TO toHeader.nVisible
			lnWidthSH = MIN(lnWidthRest, toHeader.aRefLeftHeaders(i).nWidth)
			IF lnWidthSH > 0
				toHeader.aRefLeftHeaders(i).Move(lnLeftSH, tnTop, lnWidthSH, tnHeight)
				toHeader.aRefLeftHeaders(i).Visible = .T.
			ELSE
				EXIT
			ENDIF
			lnWidthRest = lnWidthRest - lnWidthSH
			lnLeftSH = lnLeftSH + lnWidthSH
		NEXT
		IF lnWidthSH > 0
			toHeader.Move(lnLeftSH, tnTop, lnWidthRest, tnHeight)
			toHeader.Visible = .T.
		ENDIF
	ENDPROC

	PROCEDURE headerresize
		LOCAL lnLeft, lnTop, lnWidth, lnHeight, lnScroll, lnPanel, llLockScreen
		
		IF VARTYPE(this.oRefGrid) = "O"
			llLockScreen = thisform.LockScreen
			thisform.LockScreen = .T.
		
			lnLeft = this.nLeftOffset + 1
			lnTop = this.nTopOffset + 1
		
			lnPanel = this.oRefGrid.Panel
			IF this.nPanel = 1
				this.oRefGrid.Panel = 1
				lnLeft = lnLeft + this.oRefGrid.Partition
				lnWidth = this.oRefGrid.Width
			ELSE
				this.oRefGrid.Panel = 0
				lnWidth = this.oRefGrid.Partition + 1
			ENDIF
		
			lnLeft = lnLeft + IIF(this.oRefGrid.RecordMark, this.nRecordMark, 0)
			lnLeft = lnLeft + IIF(this.oRefGrid.DeleteMark, this.nDeleteMark, 0)
			lnScroll = IIF(INLIST(this.oRefGrid.ScrollBars, 2, 3), SYSMETRIC(5), 0)
		
			lnWidth = lnWidth - lnLeft - lnScroll - 2
			lnHeight = this.oRefGrid.HeaderHeight + 1
			lnScroll = IIF(INLIST(this.oRefGrid.ScrollBars, 1, 3), SYSMETRIC(7), 0)
			lnHeight = MIN(lnHeight - lnTop, this.oRefGrid.Height - lnScroll - 1)
		
			this.Move(this.oRefGrid.Left + lnLeft, this.oRefGrid.Top + lnTop, MAX(lnWidth, 0), MAX(lnHeight, 0))
		
			IF this.lSplitBar AND this.lMaster AND this.oRefGrid.Partition > 0
				this.PanelCreate()
			ENDIF
		
			this.oRefGrid.Panel = lnPanel
			this.HeaderRedraw()
			thisform.LockScreen = llLockScreen
		ELSE
			this.Visible = .F.
		ENDIF
	ENDPROC

	PROCEDURE headerswap
		LPARAMETERS toHeaderA, toHeaderB
		LOCAL loColumn, loHeaderA, loHeaderB, lnMinOrderA, lnMaxOrderA, lnMinOrderB, lnMaxOrderB
		
		loHeaderA = IIF(ISNULL(toHeaderA.oRefup), toHeaderA, toHeaderA.oRefup)
		loHeaderB = IIF(ISNULL(toHeaderB.oRefup), toHeaderB, toHeaderB.oRefup)
		
		DO CASE
			CASE toHeaderA.nType = 2 AND toHeaderB.nType = 1 AND toHeaderB.oRefup = toHeaderA
				MESSAGEBOX(ManyHeader_HeaderSwap_1, 16)
			CASE toHeaderB.nType = 2 AND toHeaderA.nType = 1 AND toHeaderA.oRefup = toHeaderA
				MESSAGEBOX(ManyHeader_HeaderSwap_1, 16)
			CASE toHeaderA.nType = 0 AND toHeaderB.nType = 0
				toHeaderA.aRefColumns[1].ColumnOrder = toHeaderB.aRefColumns[1].ColumnOrder
			CASE toHeaderA.nType = 1 AND toHeaderB.nType = 1 AND toHeadera.oRefup = toHeaderB.oRefup
				toHeaderA.aRefColumns[1].ColumnOrder = toHeaderB.aRefColumns[1].ColumnOrder
			CASE loHeaderA.nType = 0 AND loHeaderB.nType = 2
				lnOrder = loHeaderA.aRefColumns[1].ColumnOrder
				lnMinOrderB = this.GetGroupMin(loHeaderB)
				lnMaxOrderB = this.GetGroupMax(loHeaderB)
				IF lnOrder < lnMinOrderB
					FOR lnLoop = 1 TO lnMaxOrderB - lnOrder
						loHeaderA.aRefColumns[1].ColumnOrder = loHeaderA.aRefColumns[1].ColumnOrder + 1
					NEXT
					loHeaderB.HeaderSort(0)
					FOR lnLoop = 1 TO lnMinOrderB - lnOrder - 1
						FOR EACH loColumn IN loHeaderB.aRefColumns
							loColumn.ColumnOrder = loColumn.ColumnOrder - 1
						NEXT
					NEXT
				ELSE
					this.HeaderSwap(loHeaderB, loHeaderA)
				ENDIF
			CASE loHeaderA.nType = 2 AND loHeaderB.nType = 0
				lnMinOrderA = this.GetGroupMin(loHeaderA)
				lnMaxOrderA = this.GetGroupMax(loHeaderA)
				loHeaderB.HeaderSort()
				lnOrder = loHeaderB.aRefColumns[1].ColumnOrder
				IF lnMaxOrderA < lnOrder
					loHeaderA.HeaderSort(1)
					FOR EACH loColumn IN loHeaderA.aRefColumns
						FOR lnLoop = 1 TO lnOrder - lnMaxOrderA
							loColumn.ColumnOrder = loColumn.ColumnOrder + 1
						NEXT
					NEXT
					loHeaderA.HeaderSort(0)
					FOR lnLoop = 1 TO lnOrder - lnMaxOrderA - 1
						loHeaderB.aRefColumns[1].ColumnOrder = loHeaderB.aRefColumns[1].ColumnOrder - 1
					NEXT
				ELSE
					this.HeaderSwap(loHeaderB, loHeaderA)
				ENDIF
			CASE loHeaderA.nType = 2 AND loHeaderB.nType = 2
				lnMinOrderA = this.GetGroupMin(loHeaderA)
				lnMaxOrderA = this.GetGroupMax(loHeaderA)
				lnMinOrderB = this.GetGroupMin(loHeaderB)
				lnMaxOrderB = this.GetGroupMax(loHeaderB)
				IF lnMinOrderA < lnMinOrderB
					loHeaderA.HeaderSort(1)
					FOR EACH loColumn IN loHeaderA.aRefColumns
						FOR lnLoop = 1 TO lnMaxOrderB - lnMaxOrderA
							loColumn.ColumnOrder = loColumn.ColumnOrder + 1
						NEXT
					NEXT
					loHeaderB.HeaderSort(0)
					FOR EACH loColumn IN loHeaderB.aRefColumns
						FOR lnLoop = 1 TO lnMinOrderB - lnMaxOrderA - 1
							loColumn.ColumnOrder = loColumn.ColumnOrder - 1
						NEXT
					NEXT
				ELSE
					this.HeaderSwap(loHeaderB, loHeaderA)
				ENDIF
			OTHERWISE
				MESSAGEBOX(ManyHeader_HeaderSwap_2, 16)
		ENDCASE
		
		this.GetGridColumn()
		this.HeaderRedraw()
		IF NOT ISNULL(this.oRefPanel)
			this.oRefPanel.GetGridColumn()
			this.oRefPanel.HeaderRedraw()
		ENDIF
	ENDPROC

	PROCEDURE Init
		this.lTheme = ("5.01" $ OS(1) OR "5.02" $ OS(1))
		this.Declare_Dlls()
	ENDPROC

	PROCEDURE initheader
		LPARAMETERS toGrid
		LOCAL llLockScreen, lnIndex, loColumn, loHeader, loColHeader, lnPanel
		
		IF NOT VARTYPE(toGrid) = "O" OR ISNULL(toGrid) OR NOT UPPER(toGrid.BaseClass) = "GRID"
			MESSAGEBOX(ManyHeader_InitHeader_1, 16)
			RETURN
		ENDIF
		
		this.oRefGrid = toGrid
		this.lTheme = this.lTheme AND this.oRefGrid.Themes
		
		IF NOT this.oRefGrid.ColumnCount > 0
			RETURN
		ENDIF
		
		IF NOT this.oRefGrid.Columns(1).ColumnOrder > 0
			RETURN
		ENDIF
		
		IF _VFP.StartMode = 0 AND PEMSTATUS(this.oRefGrid, "AllowCellSelection", 5)
			IF this.oRefGrid.AllowCellSelection = .F. AND NOT PEMSTATUS(this.oRefGrid, "Valid", 0)
				MESSAGEBOX(ManyHeader_InitHeader_2, 64)
			ENDIF
		ENDIF
		
		#DEFINE COLOR_BTNFACE 	15
		#DEFINE COLOR_BTNTEXT 	18
		
		this._FontName = IIF(EMPTY(this._FontName), this.oRefGrid.FontName, this._FontName)
		this._FontSize = IIF(this._FontSize < 0, this.oRefGrid.FontSize, this._FontSize)
		this._BackColor = IIF(this._BackColor < 0, GetSysColor(COLOR_BTNFACE), this._BackColor)
		this._ForeColor = IIF(this._ForeColor < 0, GetSysColor(COLOR_BTNTEXT), this._ForeColor)
		
		IF NOT VERSION(5) > 600
			this.nMinLock = 0
		ENDIF
		
		this.MakeUnLockScreenTimer()
		llLockScreen = thisform.LockScreen
		thisform.LockScreen = .T.
		
		IF NOT PEMSTATUS(this.oRefGrid, "LockColumns", 5)
			this.oRefGrid.AddProperty("LockColumns", 0)
		ENDIF
		IF NOT PEMSTATUS(this.oRefGrid, "LockColumnsLeft", 5)
			this.oRefGrid.AddProperty("LockColumnsLeft", 0)
		ENDIF
		
		lnPanel = this.oRefGrid.Panel
		IF this.oRefGrid.SplitBar
			this.oRefGrid.PanelLink = .F.
			this.oRefGrid.Panel = 0
			this.oRefGrid.ScrollBars = IIF(INLIST(this.oRefGrid.ScrollBars, 0, 2), 0, 1)
			this.oRefGrid.Panel = lnPanel
			this.oRefGrid.PanelLink = .T.
		ENDIF
		
		this.GetGridColumn()
		this.HeaderClear()
		
		IF this.nPanel = 1
			this.oRefGrid.LockColumns = MAX(this.oRefGrid.LockColumns, this.nMinLock)
			this.nLock = this.oRefGrid.LockColumns
		ELSE
			this.oRefGrid.LockColumnsLeft = MAX(this.oRefGrid.LockColumnsLeft, this.nMinLock)
			this.nLock = this.oRefGrid.LockColumnsLeft
		ENDIF
		
		loColumn = this.oRefGrid.Columns(1)
		IF this.nRef = -1
			IF PEMSTATUS(loColumn, "aRefHeaders", 5)
				this.nRef = ALEN(loColumn.aRefHeaders) + 1
			ELSE
				this.nRef = 1
			ENDIF
		ENDIF
		FOR lnIndex = 1 TO this.oRefGrid.ColumnCount
			loColumn = this.oRefGrid.Columns(this.aColumn[lnIndex])
			loColumn.AddProperty("nIndex", this.aColumn[lnIndex])
			#IF VERSION(5) > 600
				BINDEVENT(loColumn, "Width", this, "Ev_LockScreenBefore")
				BINDEVENT(loColumn, "Width", this, "Ev_HeaderRedraw", 1)
			#ENDIF
		
			this.AddObject(loColumn.Name, "tcntThemedHeader")
			loHeader = this.Controls(this.ControlCount)
			loColHeader = this.GetColumnHeader(loColumn)
		
			loHeader.aRefColumns[1] = loColumn
			IF this.nRef = 1
				loColumn.AddProperty("aRefHeaders[1]", .NULL.)
			ELSE
				DIMENSION loColumn.aRefHeaders[this.nRef]
			ENDIF
			loColumn.aRefHeaders[this.nRef] = loHeader
		
			loHeader.oRefHeader = loColHeader
			loHeader.Caption = loColHeader.Caption
			loHeader.nAlignment = IIF(this.lAlignment, loColHeader.Alignment, loHeader.nAlignment)
			loHeader.lResizable = loColumn.Resizable
			loHeader.lMovable = loColumn.Movable
		
			IF this.lMaster
				this.OnStyle(loHeader, loColHeader)
			ELSE
				IF NOT ISNULL(this.oRefPanel)
					this.oRefPanel.OnStyle(loHeader, loColHeader)
				ENDIF
			ENDIF
			loHeader.lInit = .T.
		NEXT 
		this.nLeftColumn = this.oRefGrid.LeftColumn
		
		this.HeaderResize()
		IF this.lMaster 
			IF this.oRefGrid.Partition > 0
				IF ISNULL(this.oRefPanel)
					this.PanelCreate()
				ENDIF
				this.oRefPanel.InitHeader(this.oRefGrid)
			ELSE
				this.PanelDestroy()
			ENDIF
		ENDIF
		
		this.BindEvents()
		this.Zorder(0)
		
		this.Visible = this.oRefGrid.Visible
		thisform.LockScreen = llLockScreen
	ENDPROC

	HIDDEN PROCEDURE llock_assign
		LPARAMETERS tlNewVal
		
		this.lLock = tlNewVal
		
		IF tlNewVal
			this.ControlCreate()
		ENDIF
		
		IF this.lMaster AND NOT ISNULL(this.oRefPanel)
			this.oRefPanel.lLock = tlNewVal
		ENDIF
	ENDPROC

	PROCEDURE makeunlockscreentimer
		IF VARTYPE(thisform.tmrUnLockScreen) # "O"
			thisform.AddObject("tmrUnLockScreen", "UnLockScreenTimer")
		ENDIF
	ENDPROC

	HIDDEN PROCEDURE mergecleartry
		LPARAMETERS tnStart, tnEnd
		LOCAL loHeaderA, loHeaderB, loHeader, loColumn, lnMinOrder, lnMaxOrder
		
		loColumn = this.GetColumn(tnStart)
		loHeaderA = this.GetRefHeader(loColumn)
		loColumn = this.GetColumn(tnEnd)
		loHeaderB = this.GetRefHeader(loColumn)
		
		DO CASE
			CASE ISNULL(loHeaderA.oRefup) AND ISNULL(loHeaderB.oRefup)
				FOR lnIndex = tnStart TO tnEnd
					this.HeaderDel(lnIndex)
				NEXT
			CASE ISNULL(loHeaderA.oRefup) AND NOT ISNULL(loHeaderB.oRefup)
				FOR lnIndex = tnStart TO tnEnd
					this.HeaderDel(lnIndex)
				NEXT
			CASE NOT ISNULL(loHeaderA.oRefup) AND ISNULL(loHeaderB.oRefup)
				FOR lnIndex = tnEnd TO tnStart
					this.HeaderDel(lnIndex)
				NEXT
			CASE loHeaderA.oRefup = loHeaderB.oRefup
				lnMinOrder = this.GetGroupMin(loHeaderA.oRefup)
				lnMaxOrder = this.GetGroupMax(loHeaderA.oRefup)
				DO CASE
					CASE lnMinOrder = tnStart
						FOR lnIndex = tnStart TO tnEnd
							this.HeaderDel(lnIndex)
						NEXT
					CASE lnMaxOrder = tnEnd
						FOR lnIndex = tnEnd TO tnStart STEP - 1
							this.HeaderDel(lnIndex)
						NEXT
					OTHERWISE
				ENDCASE
			CASE loHeaderA.oRefup <> loHeaderB.oRefup
				lnMaxOrder = this.GetGroupMax(loHeaderA.oRefup)
				FOR lnIndex = lnMaxOrder TO tnStart STEP -1
					this.HeaderDel(lnIndex)
				NEXT
				lnMinOrder = this.GetGroupMin(loHeaderB.oRefup)
				FOR lnIndex = lnMinOrder TO tnEnd
					this.HeaderDel(lnIndex)
				NEXT
				FOR lnIndex = lnMaxOrder TO lnMinOrder
					this.HeaderDel(lnIndex)
				NEXT
		ENDCASE
	ENDPROC

	PROCEDURE mergeheader
		LPARAMETERS tnStart, tnEnd, tcCaption, tnHeight
		LOCAL llError, lnIndex, lnCount, lnOrder, loMergeHeader, loColumn, loHeader, llResizable, llMovable, lnHeight
		
		llError = .T.
		DO CASE
			CASE VARTYPE(this.oRefGrid) # "O"
				MESSAGEBOX(ManyHeader_MergeHeader_1, 16)
			CASE NOT VARTYPE(tcCaption) = "C"
				MESSAGEBOX(ManyHeader_MergeHeader_2, 16)
			CASE NOT VARTYPE(tnStart) = "N" OR NOT VARTYPE(tnEnd) = "N" 
				MESSAGEBOX(ManyHeader_MergeHeader_3, 16)
			CASE tnStart > tnEnd
				MESSAGEBOX(ManyHeader_MergeHeader_4, 16)
			CASE tnStart <= 0
				MESSAGEBOX(ManyHeader_MergeHeader_5, 16)
			CASE tnEnd > this.oRefGrid.ColumnCount
				MESSAGEBOX(ManyHeader_MergeHeader_6, 16)
			OTHERWISE
				llError = .F.
		ENDCASE
		
		IF llError
			RETURN
		ENDIF
		
		this.MergeClearTry(tnStart, tnEnd)
		
		loMergeHeader = .NULL.
		this.AddObject("_" + SYS(2015), "tcntThemedHeader")
		loMergeHeader = this.Controls(this.ControlCount)
		lnCount = tnEnd - tnStart + 1
		loMergeHeader.nHeight = IIF(VARTYPE(tnHeight) = "N" AND tnHeight > 0, tnHeight, -1)
		DIMENSION loMergeHeader.aRefColumns[lnCount]
		
		llResizable = .F.
		llMovable = .F.
		
		FOR lnIndex = lnCount TO 1 STEP -1
			loColumn = this.GetColumn(lnIndex + tnStart - 1)
			llResizable = IIF(loColumn.Resizable, .T., llResizable)
			llMovable = IIF(loColumn.Movable, .T., llMovable)
			loHeader = this.GetRefHeader(loColumn)
			loMergeHeader.aRefColumns[lnIndex] = loColumn
			IF loHeader.nType = 1
				this.HeaderDel(this.GetRefHeader(loColumn))
			ENDIF
			loHeader.nType = 1
			loHeader.oRefup = loMergeHeader
		NEXT
		
		loHeader = this.GetColumnHeader(loMergeHeader.aRefColumns[1])
		loMergeHeader.Caption = tcCaption
		loMergeHeader.nAlignment = this._Align
		loMergeHeader.lResizable = llResizable
		loMergeHeader.lMovable = llMovable
		loMergeHeader.nType = 2
		loMergeHeader.vMoveBar.Visible = .T.
		loMergeHeader.nMergeCount = lnCount
		
		IF this.lMaster
			this.OnStyle(loMergeHeader, loHeader)
		ELSE
			IF NOT ISNULL(this.oRefPanel)
				this.oRefPanel.OnStyle(loMergeHeader, this.GetColumnHeader(loMergeHeader.aRefColumns[1]))
			ENDIF
		ENDIF
		loMergeHeader.lInit = .T.
		
		this.HeaderRedraw()
		IF this.lMaster AND NOT ISNULL(this.oRefPanel)
			this.oRefPanel.MergeHeader(tnStart, tnEnd, tcCaption)
			this.oRefPanel.GetGridColumn()
			this.oRefPanel.HeaderRedraw()
		ENDIF
		
		RETURN loMergeHeader
	ENDPROC

	PROCEDURE onclick
		LPARAMETERS toHeader
		
		IF this.lMaster
			IF InList(toHeader.nType, 0, 1) AND VARTYPE(toHeader.oRefHeader) = "O"
				toHeader.oRefHeader.Click()
			ENDIF
		ELSE
			this.oRefPanel.OnClick(toHeader)
		ENDIF
	ENDPROC

	PROCEDURE ondblclick		&& ±
		LPARAMETERS toHeader
		
		IF this.lMaster
			IF InList(toHeader.nType, 0, 1) AND VARTYPE(toHeader.oRefHeader) = "O"
				toHeader.oRefHeader.DblClick()
			ENDIF
		ELSE
			this.oRefPanel.OnDblClick(toHeader)
		ENDIF
	ENDPROC

	PROCEDURE ondrag
		LPARAMETERS toHeader, tnType
		
		IF NOT this.lMaster
			this.oRefPanel.OnDrag(toHeader, tnType)
		ENDIF
	ENDPROC

	PROCEDURE onlock
		LPARAMETERS tnVal
		
		IF NOT this.lMaster
			this.oRefPanel.OnLock(tnVal)
		ENDIF
	ENDPROC

	PROCEDURE onmiddleclick
		LPARAMETERS toHeader
		
		IF this.lMaster
			IF INLIST(toHeader.nType, 0, 1) AND VARTYPE(toHeader.oRefHeader) = "O"
				toHeader.oRefHeader.MiddleClick()
			ENDIF
		ELSE
			this.oRefPanel.OnMiddleClick(toHeader)
		ENDIF
	ENDPROC

	PROCEDURE onmousedown
		LPARAMETERS toHeader, nButton, nShift, nXCoord, nYCoord
		
		IF this.lMaster
			IF INLIST(toHeader.nType, 0, 1) AND VARTYPE(toHeader.oRefHeader) = "O"
				toHeader.oRefHeader.MouseDown(nButton, nShift, nXCoord, nYCoord)
			ENDIF
		ELSE
			this.oRefPanel.OnMouseDown(toHeader, nButton, nShift, nXCoord, nYCoord)
		ENDIF
	ENDPROC

	PROCEDURE onmouseenter
		LPARAMETERS toHeader, nButton, nShift, nXCoord, nYCoord
		
		IF this.lMaster
			IF INLIST(toHeader.nType, 0, 1) AND VARTYPE(toHeader.oRefHeader) = "O"
				toHeader.oRefHeader.MouseEnter(nButton, nShift, nXCoord, nYCoord)
			ENDIF
		ELSE
			this.oRefpanel.OnMouseEnter(toHeader, nButton, nShift, nXCoord, nYCoord)
		ENDIF
	ENDPROC

	PROCEDURE onmouseleave
		LPARAMETERS toHeader, nButton, nShift, nXCoord, nYCoord
		
		IF this.lMaster
			IF INLIST(toHeader.nType, 0, 1) AND VARTYPE(toHeader.oRefHeader) = "O"
				toHeader.oRefHeader.MouseLeave(nButton, nShift, nXCoord, nYCoord)
			ENDIF
		ELSE
			this.oRefpanel.OnMouseLeave(toHeader, nButton, nShift, nXCoord, nYCoord)
		ENDIF
	ENDPROC

	PROCEDURE onmousemove
		LPARAMETERS toHeader, nButton, nShift, nXCoord, nYCoord
		
		IF this.lMaster
			IF INLIST(toHeader.nType, 0, 1) AND VARTYPE(toHeader.oRefHeader) = "O"
				toHeader.oRefHeader.MouseMove(nButton, nShift, nXCoord, nYCoord)
			ENDIF
		ELSE
			this.oRefPanel.OnMouseMove(toHeader, nButton, nShift, nXCoord, nYCoord)
		ENDIF
	ENDPROC

	PROCEDURE onmouseup
		LPARAMETERS toHeader, nButton, nShift, nXCoord, nYCoord
		
		IF this.lMaster
			IF INLIST(toHeader.nType, 0, 1) AND VARTYPE(toHeader.oRefHeader) = "O"
				toHeader.oRefHeader.MouseUp(nButton, nShift, nXCoord, nYCoord)
			ENDIF
		ELSE
			this.oRefPanel.OnMouseUp(toHeader, nButton, nShift, nXCoord, nYCoord)
		ENDIF
	ENDPROC

	PROCEDURE onmousewheel
		LPARAMETERS toHeader, nDirection, nShift, nXCoord, nYCoord
		
		IF this.lMaster
			IF INLIST(toHeader.nType, 0, 1) AND VARTYPE(toHeader.oRefHeader) = "O"
				toHeader.oRefHeader.MouseWheel(nDirection, nShift, nXCoord, nYCoord)
			ENDIF
		ELSE
			this.oRefPanel.OnMouseWheel(toHeader, nDirection, nShift, nXCoord, nYCoord)
		ENDIF
	ENDPROC

	PROCEDURE onresize
		LPARAMETERS toHeader
		
		IF NOT this.lMaster AND NOT ISNULL(this.oRefpanel)
			this.oRefPanel.OnResize(toHeader)
		ENDIF
	ENDPROC

	PROCEDURE onrightclick
		LPARAMETERS toHeader
		
		IF this.lMaster
			IF INLIST(toHeader.nType, 0, 1) AND VARTYPE(toHeader.oRefHeader) = "O"
				toHeader.oRefHeader.RightClick()
			ENDIF
		ELSE
			this.oRefPanel.RightClick(toHeader)
		ENDIF
	ENDPROC

	PROCEDURE onstyle
		LPARAMETERS toHeader, toColumnHeader
		
		IF toHeader.nType = 2
			toHeader.Header1.ForeColor = this._ForeColor
			toHeader.Header1.FontName = this._FontName
			toHeader.Header1.FontSize = this._FontSize
			toHeader.Header1.FontBold = "B" $ this._FontStyle
			toHeader.Header1.FontItalic = "I" $ this._FontStyle
			toHeader.Header1.FontStrikethru = "D" $ this._FontStyle
			toHeader.Header1.FontUnderline = "U" $ this._FontStyle
			IF toHeader.BackColor # this._BackColor
				toHeader.BackStyle = 1
				toHeader.BackColor = this._BackColor
			ENDIF
		ELSE
			toHeader.Header1.ForeColor = toColumnHeader.ForeColor
			toHeader.Header1.FontName = toColumnHeader.FontName
			toHeader.Header1.FontSize = toColumnHeader.FontSize
			toHeader.Header1.FontBold = toColumnHeader.FontBold
			toHeader.Header1.FontItalic = toColumnHeader.FontItalic
			toHeader.Header1.FontStrikethru = toColumnHeader.FontStrikethru
			toHeader.Header1.FontUnderline = toColumnHeader.FontUnderline
			IF toHeader.BackColor # toColumnHeader.BackColor
				toHeader.BackStyle = 1
				toHeader.BackColor = toColumnHeader.BackColor
			ENDIF
		ENDIF
		
		toHeader.imgTheme.nAlignMent = toHeader.nAlignMent
		
		this.OnThemeStyle(toHeader)
	ENDPROC

	PROCEDURE onthemestyle
		LPARAMETERS toHeader
		
		IF this.lTheme
			toHeader.ImgTheme.Draw()
			toHeader.SetAll("Visible", NOT toHeader.ImgTheme.lThemeDraw, "tLine")
			toHeader.Header1.Visible = NOT toHeader.ImgTheme.lThemeDraw
			toHeader.imgTheme.Visible = toHeader.ImgTheme.lThemeDraw
		ENDIF
	ENDPROC

	PROCEDURE orefgrid_assign
		LPARAMETERS toNewVal
		LOCAL lnRef, lnMax, loColumn
		
		IF VARTYPE(toNewVal) # "O" AND VARTYPE(this.oRefGrid) = "O"
			UNBINDEVENTS(this.oRefGrid, "AfterRowColChange", this, "Ev_AfterRowColChange")
			UNBINDEVENTS(this.oRefGrid, "MouseDown", this, "Ev_MouseDown")
			UNBINDEVENTS(this.oRefGrid, "MouseUp", this, "Ev_MouseUp")
			UNBINDEVENTS(this.oRefGrid, "KeyPress", this, "Ev_KeyPress")
			UNBINDEVENTS(this.oRefGrid, "Scrolled", this, "Ev_Scrolled")
			UNBINDEVENTS(this.oRefGrid, "Valid", this, "Ev_Valid")
			UNBINDEVENTS(this.oRefGrid, "Resize", this, "HeaderResize")
			UNBINDEVENTS(this.oRefGrid, "Moved", this, "HeaderResize")
			UNBINDEVENTS(this.oRefGrid, "AutoFit", this, "HeaderRedraw")
			UNBINDEVENTS(this.oRefGrid, "HeaderHeight", this, "Ev_LockScreenBefore")
			UNBINDEVENTS(this.oRefGrid, "HeaderHeight", this, "Ev_HeaderRedraw")
			UNBINDEVENTS(this.oRefGrid, "Visible", this, "Ev_LockScreenBefore")
			UNBINDEVENTS(this.oRefGrid, "Visible", this, "Ev_Visible")
		
			IF UPPER(this.oRefGrid.Parent.BaseClass) = UPPER("Container")
				UNBINDEVENTS(this.oRefGrid.Parent, "Resize", this, "Ev_LockScreenBefore")
				UNBINDEVENTS(this.oRefGrid.Parent, "Resize", this, "Ev_ParentResize")
			ENDIF
		
			lnRef = this.nRef
			lnMax = 0
			FOR EACH loColumn IN this.oRefGrid.Columns
				IF lnMax = 0
					lnMax = ALEN(loColumn.aRefHeaders) - 1
				ENDIF
		
				UNBINDEVENTS(loColumn, "Width", this, "Ev_LockScreenBefore")
				UNBINDEVENTS(loColumn, "Width", this, "Ev_HeaderRedraw")
		
				IF lnRef = lnMax
					ADEL(loColumn.aRefHeaders, lnRef)
					DIMENSION loColumn.aRefHeaders[lnMax]
				ELSE
					loColumn.aRefHeaders[lnRef] = .NULL.
				ENDIF
			NEXT
		ENDIF
		
		this.oRefGrid = toNewVal
	ENDPROC

	PROCEDURE panelcreate
		LPARAMETERS toGrid
		LOCAL loHeader, loSubHeader
		
		IF ISNULL(this.oRefPanel)
			this.Parent.AddObject(SYS(2015), this.Class)
			this.oRefPanel = this.Parent.Controls(this.Parent.ControlCount)
			this.oRefPanel.nPanel = IIF(this.nPanel = 1, 0, 1)
			this.oRefPanel.lSplitBar = .F.
			this.oRefPanel.lMaster = .F.
			this.oRefPanel.lTheme = this.lTheme
			this.oRefPanel.lLock = this.lLock
			this.oRefPanel.Picture = this.Picture
			this.oRefPanel.oRefPanel = this
			this.oRefPanel.InitHeader(this.oRefGrid)
		
			FOR EACH loHeader IN this.Controls
				IF UPPER(loHeader.Class) = UPPER("tcntThemedHeader") AND loHeader.nType = 2
					loSubHeader = this.oRefPanel.MergeHeader(this.GetGroupMin(loHeader), ;
						this.GetGroupMax(loHeader), loHeader.Header1.Caption, loHeader.nHeight)
					loSubHeader.Name = loHeader.Name
					loSubHeader.ForeColor = loHeader.ForeColor
					loSubHeader.Header1.FontName = loHeader.Header1.FontName
					loSubHeader.Header1.FontSize = loHeader.Header1.FontSize
					loSubHeader.Header1.FontBold = loHeader.Header1.FontBold
					loSubHeader.Header1.FontItalic = loHeader.Header1.FontItalic
					loSubHeader.Header1.FontStrikethru = loHeader.Header1.FontStrikethru
					loSubHeader.Header1.FontUnderline = loHeader.Header1.FontUnderline
				ENDIF
			NEXT
		ENDIF
	ENDPROC

	PROCEDURE paneldestroy
		IF NOT ISNULL(this.oRefPanel)
			this.oRefPanel.Destroy()
			this.Parent.RemoveObject(this.oRefPanel.Name)
			this.oRefPanel = .NULL.
		ENDIF
	ENDPROC

	PROCEDURE setcaptionshor
		LPARAMETERS tnHeaderNo, taCaptions, tlDown
		EXTERNAL ARRAY taCaptions
		LOCAL llError, loColumn, loHeader
		
		llError = .T.
		DO CASE
			CASE VARTYPE(this.oRefGrid) # "O"
				MESSAGEBOX(ManyHeader_MergeHeader_1, 16)
			CASE NOT VARTYPE(tnHeaderNo) = "N"
				MESSAGEBOX(ManyHeader_MergeHeader_3, 16)
			CASE tnHeaderNo <= 0
				MESSAGEBOX(ManyHeader_MergeHeader_5, 16)
			CASE tnHeaderNo > this.oRefGrid.ColumnCount
				MESSAGEBOX(ManyHeader_MergeHeader_6, 16)
			OTHERWISE
				llError = .F.
		ENDCASE
		
		IF llError
			RETURN
		ENDIF
		
		loColumn = this.GetColumn(tnHeaderNo)
		IF tlDown
			loHeader = this.GetRefHeaderDown(loColumn)
		ELSE
			loHeader = this.GetRefHeader(loColumn)
		ENDIF
		loHeader.nVisible = ALEN(taCaptions)
		FOR i = 1 TO ALEN(loHeader.aRefLeftHeaders)
			loHeader.aRefLeftHeaders(i).Caption = IIF(i > loHeader.nVisible, "", taCaptions(i))
		NEXT
	ENDPROC

	PROCEDURE setcolorshor
		LPARAMETERS tnHeaderNo, taColors, tlDown
		EXTERNAL ARRAY taColors
		LOCAL llError, loColumn, loHeader
		
		llError = .T.
		DO CASE
			CASE VARTYPE(this.oRefGrid) # "O"
				MESSAGEBOX(ManyHeader_MergeHeader_1, 16)
			CASE NOT VARTYPE(tnHeaderNo) = "N"
				MESSAGEBOX(ManyHeader_MergeHeader_3, 16)
			CASE tnHeaderNo <= 0
				MESSAGEBOX(ManyHeader_MergeHeader_5, 16)
			CASE tnHeaderNo > this.oRefGrid.ColumnCount
				MESSAGEBOX(ManyHeader_MergeHeader_6, 16)
			OTHERWISE
				llError = .F.
		ENDCASE
		
		IF llError
			RETURN
		ENDIF
		
		loColumn = this.GetColumn(tnHeaderNo)
		IF tlDown
			loHeader = this.GetRefHeaderDown(loColumn)
		ELSE
			loHeader = this.GetRefHeader(loColumn)
		ENDIF
		FOR i = 1 TO ALEN(loHeader.aRefLeftHeaders)
			IF i > loHeader.nVisible OR taColors(i) = this._BackColor
				loHeader.aRefLeftHeaders(i).BackStyle = 0
			ELSE
				loHeader.aRefLeftHeaders(i).BackStyle = 1
				loHeader.aRefLeftHeaders(i).BackColor = taColors(i)
			ENDIF
		NEXT
	ENDPROC

	PROCEDURE splitheader
		LPARAMETERS tnHeaderNo, tcCaption, tnHeight
		LOCAL llError, loSplitHeader, loColumn, loHeader
		
		llError = .T.
		DO CASE
			CASE VARTYPE(this.oRefGrid) # "O"
				MESSAGEBOX(ManyHeader_MergeHeader_1, 16)
			CASE NOT VARTYPE(tcCaption) = "C"
				MESSAGEBOX(ManyHeader_MergeHeader_2, 16)
			CASE NOT VARTYPE(tnHeaderNo) = "N"
				MESSAGEBOX(ManyHeader_MergeHeader_3, 16)
			CASE tnHeaderNo <= 0
				MESSAGEBOX(ManyHeader_MergeHeader_5, 16)
			CASE tnHeaderNo > this.oRefGrid.ColumnCount
				MESSAGEBOX(ManyHeader_MergeHeader_6, 16)
			OTHERWISE
				llError = .F.
		ENDCASE
		
		IF llError
			RETURN
		ENDIF
		
		loSplitHeader = .NULL.
		this.AddObject("_" + SYS(2015), "tcntThemedHeader")
		loSplitHeader = this.Controls(this.ControlCount)
		loColumn = this.GetColumn(tnHeaderNo)
		loHeader = this.GetRefHeader(loColumn)
		
		loSplitHeader.aRefColumns[1] = loColumn
		loSplitHeader.oRefUp = loHeader
		
		loHeader.oRefDown = loSplitHeader
		loHeader.oRefUp = .NULL.
		loHeader.nHeight = IIF(VARTYPE(tnHeight) = "N" AND tnHeight > 0, tnHeight, -1)
		loHeader.nType = 2
		
		loSplitHeader.nType = 1
		loSplitHeader.Caption = tcCaption
		loSplitHeader.nAlignment = loHeader.nAlignment
		loSplitHeader.lResizable = loHeader.lResizable
		loSplitHeader.lMovable = loHeader.lMovable
		loSplitHeader.vMoveBar.Visible = .T.
		loSplitHeader.nMergeCount = 1
		loSplitHeader.lInit = .T.
		
		this.HeaderRedraw()
		IF this.lMaster AND NOT ISNULL(this.oRefPanel)
			this.oRefPanel.SplitHeader(tnHeaderNo, tcCaption, tnHeight)
			this.oRefPanel.GetGridColumn()
			this.oRefPanel.HeaderRedraw()
		ENDIF
		
		RETURN loSplitHeader
	ENDPROC

	PROCEDURE splitheaderhor
		LPARAMETERS tnHeaderNo, taWidths, tlDown
		EXTERNAL ARRAY taWidths
		LOCAL llError, loSplitHeader, loColumn, loHeader
		
		llError = .T.
		DO CASE
			CASE VARTYPE(this.oRefGrid) # "O"
				MESSAGEBOX(ManyHeader_MergeHeader_1, 16)
			CASE NOT VARTYPE(tnHeaderNo) = "N"
				MESSAGEBOX(ManyHeader_MergeHeader_3, 16)
			CASE tnHeaderNo <= 0
				MESSAGEBOX(ManyHeader_MergeHeader_5, 16)
			CASE tnHeaderNo > this.oRefGrid.ColumnCount
				MESSAGEBOX(ManyHeader_MergeHeader_6, 16)
			OTHERWISE
				llError = .F.
		ENDCASE
		
		IF llError
			RETURN
		ENDIF
		
		loColumn = this.GetColumn(tnHeaderNo)
		IF tlDown
			loHeader = this.GetRefHeaderDown(loColumn)
		ELSE
			loHeader = this.GetRefHeader(loColumn)
		ENDIF
		DIMENSION loHeader.aRefLeftHeaders(ALEN(taWidths))
		FOR i = 1 TO ALEN(taWidths)
			loSplitHeader = .NULL.
			this.AddObject("_" + SYS(2015), "tcntThemedHeader")
			loSplitHeader = this.Controls(this.ControlCount)
			loHeader.aRefLeftHeaders(i) = loSplitHeader
		
			loSplitHeader.aRefColumns[1] = loColumn
			loSplitHeader.oRefRight = loHeader
			loSplitHeader.nHeight = loHeader.nHeight
			loSplitHeader.nType = 3
			loSplitHeader.nWidth = taWidths(i)
			loSplitHeader.nAlignment = loHeader.nAlignment
			loSplitHeader.lInit = .T.
		NEXT
		
		RETURN .T.
	ENDPROC

	HIDDEN PROCEDURE unlockscreen
		IF VARTYPE(thisform.tmrUnLockScreen) = "O"
			* In Thermaris Schedule form stay locked in some cases (Range and bill form under)
			thisform.LockScreen = .T.
			thisform.tmrUnLockScreen.Enabled = .T.
		ENDIF
	ENDPROC

	PROCEDURE visible_assign
		LPARAMETERS tlNewVal
		
		this.Visible = tlNewVal
		
		IF this.lMaster AND NOT ISNULL(this.oRefPanel)
			this.oRefPanel.Visible = tlNewVal
		ENDIF
	ENDPROC

ENDDEFINE

DEFINE CLASS timgthemedbg AS timage OF "_lvisual.vcx" 
 	*< CLASSDATA: Baseclass="image" Timestamp="" Scale="Pixels" Uniqueid="" />

	#INCLUDE "win32api.h"
	*<DefinedPropArrayMethod>
		*m: draw
		*m: themeclass_assign
		*m: themestate_assign
		*p: cfontname
		*p: font
		*p: lcustomh
		*p: lcustomw
		*p: ltheme
		*p: lthemedraw
		*p: nalignment
		*p: nbeforeh
		*p: nbeforestate
		*p: nbeforew
		*p: themeclass
		*p: themeparid		&& Theme Parid
		*p: themestate		&& Theme State
	*</DefinedPropArrayMethod>

	HIDDEN ltheme,nbeforeh,nbeforestate,nbeforew
	Anchor = 0
	cfontname = 
	font = .NULL.
	lcustomh = .T.
	lcustomw = .T.
	nalignment = 0
	Name = "timgthemedbg"
	nbeforeh = -1
	nbeforestate = -1
	nbeforew = -1
	themeclass = Header
	themeparid = 0		&& Theme Parid
	themestate = 0		&& Theme State
	
	PROCEDURE draw
		* http://topic.csdn.net/t/20030325/15/1574488.html
		
		LOCAL lhWnd, lhTheme, lhDC, lhMemDC, lhOldBmp, lpMemory, ;
			lsRect, lsSize, lsBitmapInfo, lsBitmapFile, lsFontRect, ;
			lnBmpH, lnBmpW, lnBits, lnPaletteSize, lnBmpFSize, lcBmpValue, ;
			lcCaption, lnFontSize, lhFont, lhOldFont, lnTxtW, lnTxtH, lnTop, lnLeft, lnAlign
		
		IF NOT this.lTheme
			RETURN
		ENDIF
		
		IF this.nBeforeW = this.Width AND this.nBeforeH = this.Height AND this.nBeforeState = this.ThemeState
			RETURN
		ENDIF
		
		IF this.Width = 0 OR this.Height = 0
			RETURN
		ENDIF
		
		this.lThemeDraw = .F.
		IF EMPTY(this.ThemeClass)
			RETURN
		ENDIF
		
		lhWnd = 0
		lhTheme = OpenThemeData(0, STRCONV(this.ThemeClass + CHR(0), 5))
		IF lhTheme = 0
			this.PictureVal = ""
			RETURN
		ENDIF
		
		lhDC = GetDC(lhWnd)
		IF lhDC = 0
			RETURN
		ENDIF
		
		lsRect = REPLICATE(CHR(0), RECT_SIZE)
		lsSize = REPLICATE(CHR(0), POINT_SIZE)
		GetThemePartSize(lhTheme, lhDC, this.ThemeParId, this.ThemeState, @lsRect, TS_TRUE, @lsSize)
		lnBmpW = CTOBIN(SUBSTR(lsSize, 1, 4), "4rs")
		lnBmpH = CTOBIN(SUBSTR(lsSize, 5, 4), "4rs")
		
		lnBmpW = MAX(IIF(this.lCustomW, this.Width, lnBmpW), 1)
		lnBmpH = MAX(IIF(this.lCustomH, this.Height, lnBmpH), 1)
		
		lhMemDC = CreateCompatibleDC(lhDC)
		lhBitmap = CreateCompatibleBitmap(lhDC, lnBmpW, lnBmpH)
		lhOldBmp = SelectObject(lhMemDC, lhBitmap)
		
		lsRect = BINTOC(0, "4rs") + BINTOC(0, "4rs") + BINTOC(lnBmpW, "4rs") + BINTOC(lnBmpH, "4rs")
		DrawThemeBackground(lhTheme, lhMemDC, this.ThemeParId, this.ThemeState, @lsRect, @lsRect)
		
		lnFontSize = -(this.Font.FontSize * GetDeviceCaps(lhMemDC, LOGPIXELSX) / 72)
		lhFont = CreateFont(lnFontSize, 0, 0, 0, ;
			IIF(this.Font.FontBold, FW_BOLD, 0), ;
			IIF(this.Font.FontItalic, 1, 0), ;
			IIF(this.Font.FontUnderline, 1, 0), ;
			IIF(this.Font.FontStrikethru, 1, 0), ;
			DEFAULT_CHARSET, 0, 0, 0, 0, this.Font.FontName)
		
		lhOldFont = SelectObject(lhMemDC, lhFont)
		
		lcCaption = this.Font.Caption
		lcCaption = STRCONV(lcCaption, 5) + CHR(0)
		
		lsFontRect = REPLICATE(CHR(0), 16)
		GetThemeTextExtent(lhTheme, lhMemDC, this.ThemeParId, this.ThemeState, lcCaption, -1, DT_WORDBREAK + DT_CENTER, @lsRect, @lsFontRect)
		lnTxtW = CTOBIN(SUBSTR(lsFontRect, 9, 4), "4rs")
		lnTxtH = CTOBIN(SUBSTR(lsFontRect, 13, 4), "4rs")
		
		lnTop = 0
		lnLeft = 0
		lnAlign = DT_WORDBREAK
		
		DO CASE
			CASE INLIST(this.nAlignMent, 0, 1, 2, 3)
				lnTop = MAX((lnBmpH - lnTxtH) / 2, 0)
			CASE INLIST(this.nAlignMent, 4, 5, 6)
				lnTop = 0
			CASE INLIST(this.nAlignMent, 7, 8, 9)
				lnTop = MAX(lnBmpH - lnTxtH, 0)
		ENDCASE
		
		DO CASE
			CASE INLIST(this.nAlignMent, 2, 3, 6, 9)
				lnLeft = MAX((lnBmpW - lnTxtW) / 2, 0)
				IF lnBmpW > lnTxtW
					lnAlign = lnAlign + DT_CENTER
				ENDIF
			CASE INLIST(this.nAlignMent, 0, 4, 7)
				lnLeft = 0
			CASE INLIST(this.nAlignMent, 1, 5, 8)
				lnLeft = lnBmpW - lnTxtW
				lnAlign = lnAlign + DT_RIGHT
		ENDCASE
		
		lsRect = BINTOC(lnLeft, "4rs") + BINTOC(lnTop, "4rs") + BINTOC(lnLeft + lnTxtW, "4rs") + BINTOC(lnTop + lnTxtH, "4rs")
		DrawThemeText(lhTheme, lhMemDC, this.ThemeParId, this.ThemeState, lcCaption, -1, lnAlign, 0, lsRect)
		lhFont = SelectObject(lhMemDC, lhOldFont)
		DeleteObject(lhFont)
		
		lnBits = GetDeviceCaps(lhDC, BITSPIXEL) * GetDeviceCaps(lhDC, PLANES)
		lnBmpFSize = INT(((lnBmpW * lnBits + 31)/32) * 4 * lnBmpH)
		
		lnPaletteSize = IIF(lnBits <= 8, (lnBits^2) * 4, 0)
		lsBitmapFile = "BM";								&& WORD bfType
			+ BINTOC(lnBmpFSize, "4rs") ;					&& DWORD bfSize
			+ BINTOC(0, "2rs") ;							&& WORD bfReserved1
			+ BINTOC(0, "2rs") ;							&& WORD bfReserved2
			+ BINTOC(54 + lnPaletteSize, "4rs")				&& DWORD bfOffBits BITMAPFILEHEADER + BITMAPINFOHEADER
		
		lsBitmapInfo = BINTOC(40 ,"4rs") ;					&& DWORD biSize BITMAPINFOHEADER
			+ BINTOC(lnBmpW,"4rs") ;						&& LONG biWidth
			+ BINTOC(lnBmpH, "4rs") ;						&& LONG biHeight
			+ CHR(MOD(1, 256)) + CHR(INT(1/256)) ;			&& WORD biPlanes
			+ CHR(MOD(lnBits, 256)) + CHR(INT(lnBits/256)) ;&& WORD biBitCount
			+ BINTOC(BI_RGB, "4rs") ;						&& DWORD  biCompression
			+ REPLICATE(Chr(0), 20)
		
		lpMemory = LocalAlloc(LMEM_FIXED, lnBmpFSize)
		GetDIBits(lhMemDC, lhBitmap, 0, lnBmpH, lpMemory, @lsBitmapInfo, DIB_RGB_COLORS)
		lcBmpValue = lsBitmapFile + lsBitmapInfo + SYS(2600, lpMemory, lnBmpFSize)
		
		LocalFree(lpMemory)
		
		lhBitmap = SelectObject(lhMemDC, lhOldBmp)
		DeleteObject(lhBitmap)
		
		DeleteDC(lhMemDC)
		ReleaseDC(lhWnd, lhDC)
		
		CloseThemeData(lhTheme)
		
		this.nBeforeW = this.Width
		this.nBeforeH = this.Height
		this.nBeforeState = this.ThemeState
		
		this.PictureVal = lcBmpValue
		
		this.lThemeDraw = .T.
		RETURN .T.
	ENDPROC

	PROCEDURE Init
		this.lTheme = this.Parent.Parent.lTheme	&& ManyHeader ObjRef
		
		this.Font = NEWOBJECT("Label")
		this.Font.Caption = ""
	ENDPROC

	PROCEDURE MouseDown
		LPARAMETERS nButton, nShift, nXCoord, nYCoord
		
		IF nButton = 1
			this.ThemeState = 3
		ENDIF
	ENDPROC

	PROCEDURE MouseEnter
		LPARAMETERS nButton, nShift, nXCoord, nYCoord
		
		this.ThemeState = 2
	ENDPROC

	PROCEDURE MouseLeave
		LPARAMETERS nButton, nShift, nXCoord, nYCoord
		
		this.ThemeState = 0
	ENDPROC

	PROCEDURE MouseUp
		LPARAMETERS nButton, nShift, nXCoord, nYCoord
		
		this.ThemeState = 2
	ENDPROC

	HIDDEN PROCEDURE themeclass_assign
		LPARAMETERS tcNewVal
		
		this.ThemeClass = tcNewVal
		this.nBeforeW = -1
		this.nBeforeH = -1
		this.nBeforeState = -1
	ENDPROC

	PROCEDURE themestate_assign
		LPARAMETERS tnNewVal
		
		this.ThemeState = tnNewVal
		this.Draw()
	ENDPROC

ENDDEFINE
