*--------------------------------------------------------------------------------------------------------------------------------------------------------
* (ES) AUTOGENERADO - ¡¡ATENCIÓN!! - ¡¡NO PENSADO PARA EJECUTAR!! USAR SOLAMENTE PARA INTEGRAR CAMBIOS Y ALMACENAR CON HERRAMIENTAS SCM!!
* (EN) AUTOGENERATED - ATTENTION!! - NOT INTENDED FOR EXECUTION!! USE ONLY FOR MERGING CHANGES AND STORING WITH SCM TOOLS!!
*--------------------------------------------------------------------------------------------------------------------------------------------------------
*< FOXBIN2PRG: Version="1.19" SourceFile="worktimehandler.vcx" /> (Solo para binarios VFP 9 / Only for VFP 9 binaries)
*
*
DEFINE CLASS edittimeplan AS custom 
 	*< CLASSDATA: Baseclass="custom" Timestamp="" Scale="Pixels" Uniqueid="" />

	*<DefinedPropArrayMethod>
		*m: createnewcursor
		*m: getcomparedintervals
		*m: getnewintervals
		*m: overlapped
		*m: updatetimeplan
		*m: validatefields
		*p: asgemplalias
		*p: backcolor		&& Specifies the background color used to display text and graphics in an object.
		*p: dfrom
		*p: dto
		*p: nemployeeid
		*p: nttnr
		*p: ofunctions
		*p: timetypealias
		*a: aweekday[7,0]
	*</DefinedPropArrayMethod>

	asgemplalias = .F.
	backcolor = (RGB(212,208,200))		&& Specifies the background color used to display text and graphics in an object.
	Name = "edittimeplan"
	timetypealias = .F.
	
	PROCEDURE createnewcursor
		LPARAMETERS lp_nEmId, lp_nAeId
		LOCAL l_cCursor, l_cSqlQuery, l_lForceVFP
		DO CASE
			CASE PCOUNT() = 0
				l_cWhere = '0=1'
			CASE PCOUNT() = 1
				l_cWhere = 'ae_emid = ' + this.oFunctions.SqlCnv(lp_nEmId)
			OTHERWISE
				l_cWhere = 'ae_emid = ' + this.oFunctions.SqlCnv(lp_nEmId) + ' AND ae_aeid <> ' + this.oFunctions.SqlCnv(lp_nAeId)
		ENDCASE
		l_cCursor = SYS(2015)
		l_cSqlQuery = 'SELECT '+this.asgemplalias+'.*, '+this.timetypealias+'.tt_descr FROM '+this.asgemplalias+' LEFT JOIN '+this.timetypealias+' ON ae_ttnr = tt_ttnr ' + ;
				+ 'WHERE ' + l_cWhere
		l_lForceVFP = TYPE("param.pa_foaze")="L" AND EVALUATE("param.pa_foaze")=.T.
		IF l_lForceVFP
			this.oFunctions.SqlCursor(l_cSqlQuery, l_cCursor + ' READWRITE',,,,,,,l_lForceVFP)
		ELSE
			this.oFunctions.SqlCursor(l_cSqlQuery, l_cCursor + ' READWRITE')
		ENDIF
		RETURN l_cCursor
	ENDPROC

	PROCEDURE getcomparedintervals
		LPARAMETERS lp_cCurOldIntervals, lp_cCurNewIntervals
		LOCAL l_cOldNear, l_oOld, l_oNew, l_cSqlQuery
		LOCAL l_lNewLeftPart, l_lNewRightPart
		LOCAL ARRAY l_aResult(3,3)
		l_cOldNear = SET("NEAR")
		
		l_cSqlQuery = 'SELECT *, .F. AS lSelected, .F. AS lOldInterval, RGB(0,0,0) AS nColor ' + ;
			'FROM ' + lp_cCurNewIntervals + ' WHERE .F. INTO CURSOR curComparedIntervals READWRITE'
		
		&l_cSqlQuery
		
		SELECT (lp_cCurOldIntervals)
		INDEX ON ae_to TAG TAG1
		SET NEAR ON
		SELECT (lp_cCurNewIntervals)
		SCAN
			SCATTER NAME l_oNew
			SELECT (lp_cCurOldIntervals)
			SEEK(l_oNew.ae_from)
			SCATTER NAME l_oOld
			DO WHILE this.Overlapped(l_oNew,l_oOld,@l_aResult) AND NOT EOF()
				l_lNewLeftPart = l_aResult(1,3)
				l_lNewRightPart = l_aResult(3,3)
				IF l_lNewLeftPart
					INSERT INTO curComparedIntervals ;
						(lOldInterval,lSelected,nColor,ae_aeid,ae_from,ae_to,ae_ttnr, tt_descr) VALUES ;
						(.F. , .T., RGB(255,255,255), l_oNew.ae_aeid,l_aResult(1,1),l_aResult(1,2), l_oNew.ae_ttnr, l_oNew.tt_descr)
					l_oNew.ae_aeid = 0	&& Just first is edited. Others are inserted.
					l_oNew.ae_from = l_aResult(1,2)+1
				ENDIF
				INSERT INTO curComparedIntervals ;
					(lOldInterval,lSelected,nColor,ae_from,ae_to,ae_ttnr, tt_descr) VALUES ;
					(.T. , .F., this.BackColor,l_aResult(2,1),l_aResult(2,2), l_oOld.ae_ttnr, l_oOld.tt_descr)
				l_oNew.ae_from = l_aResult(2,2)+1
				IF l_lNewRightPart
					l_oNew.ae_from = l_aResult(3,1)
				ENDIF
				SELECT (lp_cCurOldIntervals)
				SKIP
				SCATTER NAME l_oOld
			ENDDO
			IF l_oNew.ae_from<=l_oNew.ae_to
				INSERT INTO curComparedIntervals ;
					(lOldInterval,lSelected,nColor,ae_aeid,ae_from,ae_to,ae_ttnr, tt_descr) VALUES ;
					(.F., .T., RGB(255,255,255), l_oNew.ae_aeid,l_oNew.ae_from, l_oNew.ae_to, l_oNew.ae_ttnr, l_oNew.tt_descr)
			ENDIF
			SELECT (lp_cCurNewIntervals)
		ENDSCAN
		USE IN (lp_cCurOldIntervals)
		USE IN (lp_cCurNewIntervals)
		SELECT curComparedIntervals
		INDEX ON ae_to TAG TAG1
		SET NEAR &l_cOldNear
	ENDPROC

	PROCEDURE getnewintervals
		LPARAMETERS lp_nAeId
		LOCAL l_cTempAlias, l_lIntervalFound, l_dFrom, l_dTo, l_dCurrentDate, l_cTypeDescription
		LOCAL l_lDayChecked, l_lNextDayChecked, l_lIntervalFound, l_cTimeTypeAlias, l_lForceVFP
		l_nAeId = IIF(EMPTY(lp_nAeId), 0, lp_nAeId)
		l_cTimeTypeAlias = this.timetypealias
		l_cTempAlias = this.CreateNewCursor()
		l_dCurrentDate = this.dFrom
		l_dFrom = {}
		l_lForceVFP = TYPE("param.pa_foaze")="L" AND EVALUATE("param.pa_foaze")=.T.
		DO WHILE l_dCurrentDate <= this.dTo
			l_lDayChecked = this.aWeekDay(DOW(l_dCurrentDate,2))
			IF EMPTY(l_dFrom) AND l_lDayChecked
				l_dFrom = l_dCurrentDate
			ENDIF
			l_lNextDayChecked = this.aWeekDay(DOW(l_dCurrentDate+1,2))
			l_lIntervalFound = l_lDayChecked AND (NOT l_lNextDayChecked ;
				OR (l_dCurrentDate = this.dTo))
			IF l_lIntervalFound
				l_dTo = l_dCurrentDate
				APPEND BLANK IN &l_cTempAlias
				IF l_lForceVFP
					l_cTypeDescription = this.oFunctions.dlookup(l_cTimeTypeAlias,"tt_ttnr = " + this.oFunctions.SqlCnv(this.nTtnr),"tt_descr",,l_lForceVFP)
				ELSE
					l_cTypeDescription = this.oFunctions.dlookup(l_cTimeTypeAlias,"tt_ttnr = " + this.oFunctions.SqlCnv(this.nTtnr),"tt_descr")
				ENDIF
				REPLACE ae_aeid WITH l_nAeId, ;
						ae_from WITH l_dFrom, ;
						ae_to WITH l_dTo, ;
						ae_ttnr WITH this.nTtnr, ;
						ae_emid WITH this.nEmployeeID ;
						tt_descr WITH l_cTypeDescription IN &l_cTempAlias
				l_dFrom = {}
				l_nAeId = 0
			ENDIF
			l_dCurrentDate = l_dCurrentDate + 1
		ENDDO
		RETURN l_cTempAlias
	ENDPROC

	PROCEDURE overlapped
		LPARAMETERS lp_oNew, lp_oOld, lp_aResult
		LOCAL l_aInterval(2,2)
		EXTERNAL ARRAY lp_aResult
		l_aInterval(1,1) = lp_oNew.ae_from
		l_aInterval(1,2) = lp_oNew.ae_to
		l_aInterval(2,1) = lp_oOld.ae_from
		l_aInterval(2,2) = lp_oOld.ae_to
		IF NOT (l_aInterval(1,1)<=l_aInterval(2,2) AND l_aInterval(2,1)<=l_aInterval(1,2))
			RETURN .F.
		ELSE
			lp_aResult(1,1) = MIN(l_aInterval(1,1),l_aInterval(2,1))
			lp_aResult(1,2) = MAX(l_aInterval(1,1),l_aInterval(2,1))-1
			lp_aResult(1,3) = (lp_aResult(1,1)<=lp_aResult(1,2)) AND ;
				BETWEEN(lp_aResult(1,1),l_aInterval(1,1),l_aInterval(1,2))
		
			lp_aResult(2,1) = MAX(l_aInterval(1,1),l_aInterval(2,1))
			lp_aResult(2,2) = MIN(l_aInterval(1,2),l_aInterval(2,2))
			lp_aResult(2,3) = (lp_aResult(2,1)<=lp_aResult(2,2))
		
			lp_aResult(3,1) = MIN(l_aInterval(1,2),l_aInterval(2,2))+1
			lp_aResult(3,2) = MAX(l_aInterval(1,2),l_aInterval(2,2))
			lp_aResult(3,3) = (lp_aResult(3,1)<=lp_aResult(3,2)) AND ;
				BETWEEN(lp_aResult(3,1),l_aInterval(1,1),l_aInterval(1,2))
			RETURN .T.
		ENDIF
	ENDPROC

	PROCEDURE updatetimeplan
		LPARAMETERS lp_lForceVFP
		LOCAL l_CopyData, l_lForceODBC
		l_lForceODBC = NOT lp_lForceVFP
		IF USED("curComparedIntervals")
			SELECT curComparedIntervals
			SCAN
				IF lSelected
					SCATTER NAME l_CopyData
					l_CopyData.ae_emID = this.nemployeeID
					l_CopyData.ae_ttnr = this.nttnr
					IF EMPTY(l_CopyData.ae_aeID)
						l_CopyData.ae_aeID = this.oFunctions.NextID('ASGEMPL', this.asgemplalias)
						this.oFunctions.DAppend(this.asgemplalias, l_CopyData, l_lForceODBC)
					ELSE
						this.oFunctions.DUpdate(this.asgemplalias, "ae_aeid = " + ;
							this.oFunctions.SqlCnv(l_CopyData.ae_aeID), l_CopyData, l_lForceODBC)
					ENDIF
				ENDIF
			ENDSCAN
			USE IN curComparedIntervals
		ENDIF
	ENDPROC

	PROCEDURE validatefields
		LOCAL l_nErrorCode
		
		* l_nErrorCode values
		* -------------------
		* 0 everything OK
		* 1 invalid dtxtFrom
		* 2 invalid dtxtTo
		* 3 invalid cboType
		
		DO CASE
			CASE EMPTY(thisform.dFrom)
				this.oFunctions.alert(this.oFunctions.GetLanguageText("TXT_REQUIRED"))
				l_nErrorCode = 1
			CASE EMPTY(thisform.dTo)
				this.oFunctions.alert(this.oFunctions.GetLanguageText("TXT_REQUIRED"))
				l_nErrorCode = 2
			CASE thisform.dTo < thisform.dFrom
				this.oFunctions.alert(this.oFunctions.GetLanguageText("TXT_INVALID_FIELD"))
				l_nErrorCode = 2
			CASE EMPTY(thisform.nTtnr)
				this.oFunctions.alert(this.oFunctions.GetLanguageText("TXT_REQUIRED"))
				l_nErrorCode = 3
			OTHERWISE
				l_nErrorCode = 0
		ENDCASE
		RETURN l_nErrorCode
	ENDPROC

ENDDEFINE

DEFINE CLASS worktimecontrol AS custom 
 	*< CLASSDATA: Baseclass="custom" Timestamp="" Scale="Pixels" Uniqueid="" />

	*<DefinedPropArrayMethod>
		*m: choosetimetype
		*m: createmonthplancursor
		*m: createworkbreakscursor
		*m: createworkhoursbreaksdetailscursor
		*m: createworkhourscursor
		*m: createworkhoursdetailscursor
		*m: getcaption
		*m: getdefaultworkbreak
		*m: getmonthdates
		*m: getmonthplandata
		*m: getparam
		*m: getroundedhours
		*m: getroundedhourscaption
		*m: getworkbreaksdata
		*m: getworkhoursbreaksdetailsdata
		*m: getworkhoursdata
		*m: getworkhoursdetailsdata
		*m: mergeintervals
		*m: settimetype
		*m: userisemployee
		*m: workhourshandle
		*m: workpausehandle
		*p: asgemplalias
		*p: azepickalias
		*p: curtimeplan
		*p: employeealias
		*p: employehalias
		*p: nenginebehavior
		*p: ofunctions
		*p: paramalias
		*p: timetypealias
		*p: workbrkalias
		*p: workbrkdalias
		*p: workintalias
	*</DefinedPropArrayMethod>

	curtimeplan = 
	Name = "worktimecontrol"
	nenginebehavior = 0
	
	PROCEDURE choosetimetype
		LPARAMETERS lp_nXCoord, lp_nYCoord
		LOCAL l_nArea, l_nTtNr, l_nAsc
		
		l_nArea = SELECT()
		
		lp_nXCoord = EVL(lp_nXCoord, MCOL(_screen.Name))
		lp_nYCoord = EVL(lp_nYCoord, MROW(_screen.Name))
		
		l_nTtNr = 0
		
		DEFINE POPUP PopupMenu SHORTCUT RELATIVE FROM lp_nYCoord, lp_nXCoord IN SCREEN
		DEFINE BAR 999 OF PopupMenu PROMPT "\<0"
		ON SELECTION BAR 999 OF PopupMenu l_nTtNr = BAR()
		
		l_nAsc = 49
		SELECT (this.timetypealias)
		SCAN FOR NOT tt_deleted
		     DEFINE BAR tt_ttnr OF PopupMenu PROMPT "\<" + CHR(l_nAsc) + " " + ALLTRIM(tt_code)+" - "+ALLTRIM(tt_descr)
		     ON SELECTION BAR tt_ttnr OF PopupMenu l_nTtNr = BAR()
		     l_nAsc = IIF(l_nAsc = 57, 65, l_nAsc + 1)
		ENDSCAN
		
		ACTIVATE POPUP PopupMenu
		
		SELECT (l_nArea)
		
		RETURN l_nTtNr
	ENDPROC

	PROCEDURE createmonthplancursor
		LPARAMETERS lp_cMonthPlanCur
		LOCAL ARRAY astruct(1,16)
		LOCAL i
		
		this.oFunctions.CursorAddField(@astruct, "CR_EMID", "I", 0, 0)
		this.oFunctions.CursorAddField(@astruct, "CR_NAME", "C", 52, 0)
		this.oFunctions.CursorAddField(@astruct, "CR_VACATIO", "N", 3, 0)
		this.oFunctions.CursorAddField(@astruct, "CR_UNUSVAC", "N", 3, 0)
		this.oFunctions.CursorAddField(@astruct, "CR_USEDVAC", "N", 3, 0)
		this.oFunctions.CursorAddField(@astruct, "CR_WHINTEND", "N", 8, 0)
		FOR i = 1 TO 31
		     this.oFunctions.CursorAddField(@astruct, "CR_DAY" + TRANSFORM(i), "C", 2, 0)
		     this.oFunctions.CursorAddField(@astruct, "CR_TTNR" + TRANSFORM(i), "N", 2, 0)
		NEXT
		
		this.oFunctions.CreateCursorFromArray(lp_cMonthPlanCur, @astruct)
		
		RETURN .T.
	ENDPROC

	PROCEDURE createworkbreakscursor
		LPARAMETERS lp_cworkplancur
		LOCAL ARRAY astruct(1,16)
		
		this.oFunctions.CursorAddField(@astruct, "CR_WBID", "N", 8, 0)
		this.oFunctions.CursorAddField(@astruct, "CR_BEGIN", "T", 0, 0)
		this.oFunctions.CursorAddField(@astruct, "CR_END", "T", 0, 0)
		
		this.oFunctions.CreateCursorFromArray(lp_cworkplancur, @astruct)
		
		RETURN .T.
	ENDPROC

	PROCEDURE createworkhoursbreaksdetailscursor
		LPARAMETERS lp_curWHBDet
		LOCAL l_cEmployeeAlias
		
		l_cEmployeeAlias = this.EmployeeAlias
		
		this.CreateWorkHoursDetailsCursor(lp_curWHBDet)
		
		SELECT &l_cEmployeeAlias..*, &lp_curWHBDet..*, CAST({} AS T) AS cr_brbegin, CAST({} AS T) AS cr_brend ;
		     FROM &l_cEmployeeAlias, &lp_curWHBDet ;
		     WHERE 0=1 ;
		     INTO CURSOR &lp_curWHBDet READWRITE
		
		RETURN .T.
	ENDPROC

	PROCEDURE createworkhourscursor
		LPARAMETERS lp_cworkplancur
		LOCAL ARRAY astruct(1,16)
		
		this.oFunctions.CursorAddField(@astruct, "CR_EMID", "I", 0, 0)
		this.oFunctions.CursorAddField(@astruct, "CR_PERNR", "N", 5, 0)
		this.oFunctions.CursorAddField(@astruct, "CR_NAME", "C", 51, 0)
		this.oFunctions.CursorAddField(@astruct, "CR_VACATIO", "N", 3, 0)
		this.oFunctions.CursorAddField(@astruct, "CR_UNUSVAC", "N", 3, 0)
		this.oFunctions.CursorAddField(@astruct, "CR_USEDVAC", "N", 3, 0)
		this.oFunctions.CursorAddField(@astruct, "CR_SEC", "N", 8, 0)
		
		this.oFunctions.CreateCursorFromArray(lp_cworkplancur, @astruct)
		
		RETURN .T.
	ENDPROC

	PROCEDURE createworkhoursdetailscursor
		LPARAMETERS lp_cwdetcur
		LOCAL ARRAY astruct(1,16)
		
		this.oFunctions.CursorAddField(@astruct, "CR_EMID", "N", 8, 0)
		this.oFunctions.CursorAddField(@astruct, "CR_WHID", "I", 0, 0)
		this.oFunctions.CursorAddField(@astruct, "CR_NDAY", "N", 2, 0)
		this.oFunctions.CursorAddField(@astruct, "CR_EVENT", "C", 3, 0)
		this.oFunctions.CursorAddField(@astruct, "CR_TTCODE", "C", 2, 0)
		this.oFunctions.CursorAddField(@astruct, "CR_SYSDATE", "D", 0, 0)
		this.oFunctions.CursorAddField(@astruct, "CR_WHINTEND", "N", 8, 0)
		this.oFunctions.CursorAddField(@astruct, "CR_BEGIN", "T", 0, 0)
		this.oFunctions.CursorAddField(@astruct, "CR_END", "T", 0, 0)
		this.oFunctions.CursorAddField(@astruct, "CR_NPAUSE", "N", 8, 0)
		this.oFunctions.CursorAddField(@astruct, "CR_NWHOURS", "N", 8, 0)
		this.oFunctions.CursorAddField(@astruct, "CR_NRWHOURS", "N", 8, 0)
		this.oFunctions.CursorAddField(@astruct, "CR_OVERTIME", "N", 8, 0)
		this.oFunctions.CursorAddField(@astruct, "CR_WHSUN", "N", 8, 0)
		this.oFunctions.CursorAddField(@astruct, "CR_WHHOL", "N", 8, 0)
		this.oFunctions.CursorAddField(@astruct, "CR_WHNG1", "N", 8, 0)
		this.oFunctions.CursorAddField(@astruct, "CR_WHNG2", "N", 8, 0)
		this.oFunctions.CursorAddField(@astruct, "CR_WHNG3", "N", 8, 0)
		this.oFunctions.CursorAddField(@astruct, "CR_DMIN", "I", 0, 0)
		this.oFunctions.CursorAddField(@astruct, "CR_DEFBRK", "L", 0, 0)
		
		this.oFunctions.CreateCursorFromArray(lp_cwdetcur, @astruct)
		
		RETURN .T.
	ENDPROC

	PROCEDURE getcaption
		LPARAMETERS lp_cCode
		LOCAL l_nNightStart, l_nNightEnd, l_nMidnightStart, l_nMidnightEnd, l_nMidnight1
		
		l_nNightStart =    INT(this.oFunctions.DLookUp(this.AzepickAlias, "aq_label = 'PARAMS    ' AND aq_charcod = 'NGS'", "aq_nval1"))
		l_nNightEnd =      INT(this.oFunctions.DLookUp(this.AzepickAlias, "aq_label = 'PARAMS    ' AND aq_charcod = 'NGE'", "aq_nval1"))
		l_nMidnightStart = INT(this.oFunctions.DLookUp(this.AzepickAlias, "aq_label = 'PARAMS    ' AND aq_charcod = 'MDS'", "aq_nval1"))
		l_nMidnight1     = INT(this.oFunctions.DLookUp(this.AzePickAlias, "aq_label = 'PARAMS    ' AND aq_charcod = 'MD1'", "aq_nval1"))
		l_nMidnightEnd =   INT(this.oFunctions.DLookUp(this.AzepickAlias, "aq_label = 'PARAMS    ' AND aq_charcod = 'MDE'", "aq_nval1"))
		DO CASE
		     CASE lp_cCode = "NIGHT"
		          lp_cCaption = this.oFunctions.GetLanguageText("BY_NIGHT")+" "+PADL(l_nNightStart,2,"0")+":00-"+PADL(l_nNightEnd,2,"0")+":00"
		     CASE lp_cCode = "MIDNIGHT 1"
		          lp_cCaption = this.oFunctions.GetLanguageText("BY_NIGHT")+" "+PADL(l_nMidnightStart,2,"0")+":00-"+PADL(l_nMidnight1,2,"0")+":00"
		     CASE lp_cCode = "MIDNIGHT 2"
		          lp_cCaption = this.oFunctions.GetLanguageText("BY_NIGHT")+" "+PADL(l_nMidnight1,2,"0")+":00-"+PADL(l_nMidnightEnd,2,"0")+":00"
		     CASE lp_cCode = "EVENING"
		          lp_cCaption = this.oFunctions.GetLanguageText("BY_NIGHT")+" "+PADL(l_nNightStart,2,"0")+":00-"+PADL(l_nMidnightStart,2,"0")+":00, "+PADL(l_nMidnightEnd,2,"0")+":00-"+PADL(l_nNightEnd,2,"0")+":00"
		     OTHERWISE
		          lp_cCaption = ""
		ENDCASE
		     
		RETURN lp_cCaption
	ENDPROC

	PROCEDURE getdefaultworkbreak
		LPARAMETERS lp_curBreaks, lp_dDate, lp_tBegin, lp_tEnd, lp_lNotClose
		LOCAL i, l_nArea, l_dDate, l_nWbMin, l_nValue1, l_nValue2, l_cCwField, l_cWbField
		
		l_nArea = SELECT()
		
		lp_dDate = EVL(lp_dDate,{})
		
		IF EMPTY(lp_curBreaks)
		     lp_curBreaks = SYS(2015)
		     CREATE CURSOR &lp_curBreaks (pa_date D, pa_cwsec1 N(6), pa_cwsec2 N(6), pa_wbmin N(3))
		     SELECT (this.WorkBrkDAlias)
		     SCAN
		          l_dDate = wd_date
		          IF wd_cwhour0 > 0 OR wd_cwhour1 > 0 AND wd_wbmin1 > 0 OR wd_cwhour2 > 0 AND wd_wbmin2 > 0 OR wd_cwhour3 > 0 AND wd_wbmin3 > 0
		               l_nValue1 = 0
		               l_nValue2 = wd_cwhour0*3600
		               IF l_nValue2 > 0
		                    l_nWbMin = 0
		                    INSERT INTO &lp_curBreaks (pa_date, pa_cwsec1, pa_cwsec2, pa_wbmin) VALUES (l_dDate, l_nValue1, l_nValue2, l_nWbMin)
		                    l_nValue1 = l_nValue2
		               ENDIF
		               FOR i = 1 TO 3
		                    l_cWbField = "wd_wbmin" + TRANSFORM(i)
		                    l_cCwField = "wd_cwhour" + TRANSFORM(i)
		                    l_nValue2 = &l_cCwField*3600
		                    IF l_nValue2 > 0 AND l_nValue2 > l_nValue1
		                         l_nWbMin = MAX(0, &l_cWbField)
		                         INSERT INTO &lp_curBreaks (pa_date, pa_cwsec1, pa_cwsec2, pa_wbmin) VALUES (l_dDate, l_nValue1, l_nValue2, l_nWbMin)
		                         l_nValue1 = l_nValue2
		                    ENDIF
		               NEXT
		               REPLACE pa_cwsec2 WITH 999999 IN &lp_curBreaks
		          ELSE
		               l_nWbMin = MAX(0, wd_min)
		               INSERT INTO &lp_curBreaks (pa_date, pa_cwsec2, pa_wbmin) VALUES (l_dDate, 999999, l_nWbMin)
		          ENDIF
		     ENDSCAN
		     l_dDate = {}
		     IF this.GetParam("pa_cwhour0") > 0 OR this.GetParam("pa_cwhour1") > 0 AND this.GetParam("pa_wbmin1") > 0 OR ;
		               this.GetParam("pa_cwhour2") > 0 AND this.GetParam("pa_wbmin2") > 0 OR this.GetParam("pa_cwhour3") > 0 AND this.GetParam("pa_wbmin3") > 0
		          l_nValue1 = 0
		          l_nValue2 = this.GetParam("pa_cwhour0")*3600
		          IF l_nValue2 > 0
		               l_nWbMin = 0
		               INSERT INTO &lp_curBreaks (pa_date, pa_cwsec1, pa_cwsec2, pa_wbmin) VALUES (l_dDate, l_nValue1, l_nValue2, l_nWbMin)
		               l_nValue1 = l_nValue2
		          ENDIF
		          FOR i = 1 TO 3
		               l_nValue2 = this.GetParam("pa_cwhour" + TRANSFORM(i))*3600
		               IF l_nValue2 > 0 AND l_nValue2 > l_nValue1
		                    l_nWbMin = MAX(0, this.GetParam("pa_wbmin" + TRANSFORM(i)))
		                    INSERT INTO &lp_curBreaks (pa_date, pa_cwsec1, pa_cwsec2, pa_wbmin) VALUES (l_dDate, l_nValue1, l_nValue2, l_nWbMin)
		                    l_nValue1 = l_nValue2
		               ENDIF
		          NEXT
		          REPLACE pa_cwsec2 WITH 999999 IN &lp_curBreaks
		     ELSE
		          l_nWbMin = MAX(0, this.GetParam("pa_wbmin"))
		          INSERT INTO &lp_curBreaks (pa_date, pa_cwsec2, pa_wbmin) VALUES (l_dDate, 999999, l_nWbMin)
		     ENDIF
		ENDIF
		l_nWbMin = 0
		DO CASE
		     CASE EMPTY(lp_tBegin) OR EMPTY(lp_tEnd)
		     CASE this.oFunctions.DLocate(lp_curBreaks, "BETWEEN(" + this.oFunctions.SqlCnv(ROUND(lp_tEnd-lp_tBegin,0)) + ", pa_cwsec1, pa_cwsec2) AND (pa_date = " + this.oFunctions.SqlCnv(lp_dDate) + " OR pa_date = {})")
		          l_nWbMin = &lp_curBreaks..pa_wbmin
		     OTHERWISE
		ENDCASE
		
		IF NOT lp_lNotClose
		     this.oFunctions.TbClose(lp_curBreaks)
		     lp_curBreaks = ""
		ENDIF
		
		SELECT (l_nArea)
		
		RETURN l_nWbMin
	ENDPROC

	PROCEDURE getmonthdates
		LPARAMETERS lp_dDate, lp_dFromDate, lp_dToDate, lp_nMonth, lp_nYear, lp_nFirstDay, lp_nLastDay
		
		lp_nFirstDay = 1
		lp_nMonth = MONTH(lp_dDate)
		lp_nYear = YEAR(lp_dDate)
		lp_dFromDate = DATE(lp_nYear,lp_nMonth,lp_nFirstDay)
		lp_nLastDay = this.oFunctions.LastDay(lp_dFromDate)
		lp_dToDate = DATE(lp_nYear,lp_nMonth,lp_nLastDay)
		
		RETURN .T.
	ENDPROC

	PROCEDURE getmonthplandata
		LPARAMETERS pdSearchDate, pnJobNr, pcurmonplanname, pnLastDay
		LOCAL l_nSelect, l_lReset, l_curEmployeealias, l_curPVacation, l_curVacation, l_curResult, l_dDate, l_dPNYStartDate, l_dNYStartDate, l_dNYEndDate, l_cFieldName, l_oData
		LOCAL dFromDate, dToDate, nMonth, nYear, nFirstDay, nLastDay
		
		l_nSelect = SELECT()
		
		IF SET("EngineBehavior") <> 70
		     l_lReset = .T.
		     SET ENGINEBEHAVIOR 70
		ENDIF
		
		l_dPNYStartDate = DATE(YEAR(pdSearchDate)-1,1,1)
		l_dNYStartDate = DATE(YEAR(pdSearchDate),1,1)
		l_dNYEndDate = DATE(YEAR(pdSearchDate),12,31)
		pnLastDay = EVL(pnLastDay,0)
		
		this.GetMonthDates(pdSearchDate, @dFromDate, @dToDate, @nMonth, @nYear, @nFirstDay, @nLastDay)
		
		*** Create monthplan cursor
		this.CreateMonthPlanCursor(pcurmonplanname)
		
		*** Fill the cursor
		l_curEmployeealias = SYS(2015)
		l_curPVacation = SYS(2015)
		l_curVacation = SYS(2015)
		SELECT * FROM (this.employeealias) ;
		     WHERE (EMPTY(pnJobNr) OR em_jbnr = pnJobNr) AND NOT em_inactiv ;
		     GROUP BY em_emid ;
		     INTO CURSOR &l_curEmployeealias
		
		SELECT ae_emid, ae_from, ae_to ;
		     FROM (this.asgemplalias) ;
		     INNER JOIN (l_curEmployeealias) ON em_emid = ae_emid ;
		     INNER JOIN (this.timetypealias) ON tt_ttnr = ae_ttnr ;
		     WHERE ae_from < l_dNYStartDate AND ae_to >= l_dPNYStartDate AND tt_vacatio ;
		     INTO CURSOR &l_curPVacation READWRITE
		REPLACE ae_from WITH MAX(ae_from, l_dPNYStartDate), ae_to WITH MIN(ae_to, l_dNYStartDate-1) ALL
		SELECT ae_emid AS c_emid, SUM(ae_to-ae_from+1) AS c_planvac ;
		     FROM &l_curPVacation ;
		     GROUP BY ae_emid ;
		     INTO CURSOR &l_curPVacation
		
		SELECT ae_emid, ae_from, ae_to ;
		     FROM (this.asgemplalias) ;
		     INNER JOIN (l_curEmployeealias) ON em_emid = ae_emid ;
		     INNER JOIN (this.timetypealias) ON tt_ttnr = ae_ttnr ;
		     WHERE ae_from <= l_dNYEndDate AND ae_to >= l_dNYStartDate AND tt_vacatio ;
		     INTO CURSOR &l_curVacation READWRITE
		REPLACE ae_from WITH MAX(ae_from, l_dNYStartDate), ae_to WITH MIN(ae_to, l_dNYEndDate) ALL
		SELECT ae_emid AS c_emid, SUM(ae_to-ae_from+1) AS c_planvac ;
		     FROM &l_curVacation ;
		     GROUP BY ae_emid ;
		     INTO CURSOR &l_curVacation
		
		l_curResult = SYS(2015)
		SELECT em_emid, em_lname, em_fname, em_whweek, em_dayweek, ;
		       CAST(NVL(eh1.eh_vacatio,0) AS N(3)) AS eh_vacat1, ;
		       CAST(NVL(eh2.eh_vacatio,0) AS N(3)) AS eh_vacat2, ;
		       CAST(NVL(v1.c_planvac,0) AS N(3)) AS c_planvac1, ;
		       CAST(NVL(v2.c_planvac,0) AS N(3)) AS c_planvac2, ;
		       CAST(NVL(ae_emid,0) AS I) AS ae_emid, ;
		       CAST(NVL(ae_from,{}) AS D) AS ae_from, ;
		       CAST(NVL(ae_to,{}) AS D) AS ae_to, ;
		       CAST(NVL(ae_ttnr,0) AS N(2)) AS ae_ttnr, ;
		       CAST(NVL(tt_ttnr,0) AS N(2)) AS tt_ttnr, ;
		       CAST(NVL(tt_code,"") AS C(2)) AS tt_code ;
		     FROM (l_curEmployeealias) ;
		     LEFT JOIN (this.employehalias) eh1 ON eh1.eh_emid = em_emid AND eh1.eh_year = YEAR(pdSearchDate)-1 ;
		     LEFT JOIN (this.employehalias) eh2 ON eh2.eh_emid = em_emid AND eh2.eh_year = YEAR(pdSearchDate) ;
		     LEFT JOIN (this.asgemplalias) ON ae_emid = em_emid AND ae_from <= dToDate AND ae_to >= dFromDate ;
		     LEFT JOIN (this.timetypealias) ON tt_ttnr = ae_ttnr ;
		     LEFT JOIN (l_curPVacation) v1 ON v1.c_emid = em_emid ;
		     LEFT JOIN (l_curVacation) v2 ON v2.c_emid = em_emid ;
		     ORDER BY em_emid, ae_from ;
		     INTO CURSOR &l_curResult
		
		INSERT INTO &pcurmonplanname (cr_emid, cr_name, cr_vacatio, cr_unusvac, cr_usedvac, cr_whintend) ;
		     SELECT em_emid, ALLTRIM(em_lname) + ", " + ALLTRIM(em_fname), eh_vacat2, eh_vacat1-c_planvac1, c_planvac2, IIF(em_dayweek=0,00000000,INT(em_whweek*3600/em_dayweek)) ;
		          FROM &l_curResult ;
		          GROUP BY 1 ;
		          ORDER BY 2
		BLANK FIELDS cr_unusvac FOR cr_unusvac < 0 IN &pcurmonplanname
		
		SELECT &l_curResult
		SCAN FOR NOT EMPTY(ae_emid) AND this.oFunctions.DLocate(pcurmonplanname, "cr_emid = " + this.oFunctions.SqlCnv(ae_emid))
		     SELECT &pcurmonplanname
		     SCATTER FIELDS LIKE cr_day*, cr_ttnr* NAME l_oData
		     l_dDate = MAX(dFromDate, &l_curResult..ae_from)
		     DO WHILE l_dDate <= MIN(dToDate, &l_curResult..ae_to)
		          l_cFieldName = "cr_day" + TRANSFORM(DAY(l_dDate))
		          l_oData.&l_cFieldName = &l_curResult..tt_code
		          l_cFieldName = "cr_ttnr" + TRANSFORM(DAY(l_dDate))
		          l_oData.&l_cFieldName = &l_curResult..tt_ttnr
		          l_dDate = l_dDate + 1
		     ENDDO
		     GATHER NAME l_oData
		ENDSCAN
		GO TOP IN &pcurmonplanname
		this.oFunctions.TbClose(l_curEmployeealias)
		this.oFunctions.TbClose(l_curPVacation)
		this.oFunctions.TbClose(l_curVacation)
		this.oFunctions.TbClose(l_curResult)
		
		pnLastDay = nLastDay
		
		IF l_lReset
		     SET ENGINEBEHAVIOR this.nEngineBehavior
		ENDIF
		
		SELECT (l_nSelect)
		
		RETURN .T.
	ENDPROC

	PROCEDURE getparam
		LPARAMETERS lp_cParamField
		LOCAL l_cParamAlias
		
		l_cParamAlias = this.ParamAlias
		
		RETURN &l_cParamAlias..&lp_cParamField
	ENDPROC

	PROCEDURE getroundedhours
		LPARAMETERS lp_nSec, lp_nResultSec
		LOCAL l_nRoundMode, l_nRoundSec
		
		* Code for rounding with pa_tkround
		* 2 - Round up by defined number of minutes
		* 3 - Round down by defined number of minutes
		* otherwise - Accurately
		
		l_nRoundMode = this.GetParam("pa_tkround")
		l_nRoundSec = this.GetParam("pa_wrndmin") * 60
		
		DO CASE
		     CASE l_nRoundMode = 2 AND l_nRoundSec > 0
		          lp_nResultSec = CEILING(lp_nSec / l_nRoundSec) * l_nRoundSec
		     CASE l_nRoundMode = 3 AND l_nRoundSec > 0
		          lp_nResultSec = FLOOR(lp_nSec / l_nRoundSec) * l_nRoundSec
		     OTHERWISE
		          lp_nResultSec = lp_nSec
		ENDCASE
		
		RETURN lp_nResultSec
	ENDPROC

	PROCEDURE getroundedhourscaption
		LPARAMETERS lp_cCaption
		LOCAL l_nRoundMode, l_nRoundMin
		
		* Code for rounding with pa_tkround
		* 2 - Round up by defined number of minutes
		* 3 - Round down by defined number of minutes
		* otherwise - Accurately
		
		l_nRoundMode = this.GetParam("pa_tkround")
		l_nRoundMin = this.GetParam("pa_wrndmin")
		
		DO CASE
		     CASE l_nRoundMode = 2 AND l_nRoundMin > 0
		          lp_cCaption = this.oFunctions.GetLanguageText("ROUND_UP") + " " + TRANSFORM(l_nRoundMin) + " min."
		     CASE l_nRoundMode = 3 AND l_nRoundMin > 0
		          lp_cCaption = this.oFunctions.GetLanguageText("ROUND_DOWN") + " " + TRANSFORM(l_nRoundMin) + " min."
		     OTHERWISE
		          lp_cCaption = CHR(13)+this.oFunctions.GetLanguageText("ACCURATELY")
		ENDCASE
		     
		RETURN lp_cCaption
	ENDPROC

	PROCEDURE getworkbreaksdata
		LPARAMETERS lp_dDate, lp_nWhID, lp_curWbDetails
		LOCAL l_nSelect, l_curBreaks, l_nWbMin
		LOCAL ARRAY l_aPauses(1), l_aTimes(1)
		
		l_nSelect = SELECT()
		
		INSERT INTO (lp_curWbDetails) (cr_wbid, cr_begin, cr_end) ;
		     SELECT wb_wbid, wb_begin, wb_end ;
		          FROM (this.WorkBrkAlias) ;
		          WHERE wb_whid = lp_nWhID
		IF NOT EMPTY(lp_dDate) AND this.GetParam("pa_wbautoc")
		     SELECT COUNT(wb_wbid) FROM (this.WorkBrkAlias) ;
		          INNER JOIN (this.WorkIntAlias) wi1 ON wi1.wi_whid = wb_whid ;
		          INNER JOIN (this.WorkIntAlias) wi2 ON wi2.wi_sysdate = wi1.wi_sysdate AND wi2.wi_emid = wi1.wi_emid ;
		          WHERE wi2.wi_whid = lp_nWhID ;
		          INTO ARRAY l_aPauses
		     IF EMPTY(l_aPauses(1))
		          SELECT TOP 1 wi1.wi_begin, wi1.wi_end, ROUND(wi1.wi_end-wi1.wi_begin,0) FROM (this.WorkIntAlias) wi1 ;
		               INNER JOIN (this.WorkIntAlias) wi2 ON wi2.wi_sysdate = wi1.wi_sysdate AND wi2.wi_emid = wi1.wi_emid ;
		               WHERE wi2.wi_whid = lp_nWhID AND NOT EMPTY(wi1.wi_end) ;
		               ORDER BY 3 DESC ;
		               INTO ARRAY l_aTimes
		          l_nWbMin = this.GetDefaultWorkBreak(@l_curBreaks, lp_dDate, l_aTimes(1,1), l_aTimes(1,2))
		          IF l_nWbMin > 0
		               INSERT INTO (lp_curWbDetails) (cr_end) VALUES (DTOT(lp_dDate)+l_nWbMin*60)
		          ENDIF
		     ENDIF
		ENDIF
		
		SELECT (l_nSelect)
		
		RETURN .T.
	ENDPROC

	PROCEDURE getworkhoursbreaksdetailsdata
		LPARAMETERS lp_dSelDate, lp_nEmID, lp_nJobNr, lp_curWHBDet
		LOCAL l_nSelect, l_lReset, l_curEmployeealias, l_curWhDetails, l_curResult, l_nWhID
		
		l_nSelect = SELECT()
		
		IF SET("EngineBehavior") <> 70
		     l_lReset = .T.
		     SET ENGINEBEHAVIOR 70
		ENDIF
		
		l_curEmployeealias = SYS(2015)
		l_curWhDetails = SYS(2015)
		l_curResult = SYS(2015)
		
		this.curTimePLan = SYS(2015)
		this.GetMonthPlanData(lp_dSelDate, lp_nJobNr, this.curTimePLan)
		this.CreateWorkHoursDetailsCursor(l_curWhDetails)
		
		SELECT * FROM &l_curWhDetails INTO CURSOR &l_curResult READWRITE
		SELECT * FROM (this.employeealias) ;
		     WHERE (EMPTY(lp_nEmID) OR em_emid = lp_nEmID) AND (EMPTY(lp_nJobNr) OR em_jbnr = lp_nJobNr) ;
		     GROUP BY em_emid ;
		     INTO CURSOR &l_curEmployeealias
		SCAN
		     this.GetWorkHoursDetailsData(lp_dSelDate, em_emid, l_curResult)
		     IF this.oFunctions.Dlocate(l_curResult, "NOT EMPTY(cr_whid)")
		          INSERT INTO &l_curWhDetails SELECT * FROM &l_curResult
		     ENDIF
		     SELECT (l_curEmployeealias)
		ENDSCAN
		USE IN &l_curResult
		
		SELECT *, CAST(NVL(wb_begin,{}) AS T) AS cr_brbegin, CAST(NVL(wb_end,{}) AS T) AS cr_brend ;
		     FROM &l_curWhDetails ;
		     LEFT JOIN (l_curEmployeealias) ON em_emid = cr_emid ;
		     LEFT JOIN (this.WorkBrkAlias) ON wb_whid = cr_whid ;
		     INTO CURSOR &l_curWhDetails READWRITE
		l_nWhID = 0
		SCAN FOR NOT EMPTY(cr_whid)
		     IF l_nWhID = cr_whid
		          BLANK FIELDS cr_sysdate, cr_begin, cr_end, cr_dmin, cr_defbrk, cr_npause, cr_nwhours, cr_nrwhours WHILE cr_whid = l_nWhID
		          SKIP -1
		     ELSE
		          l_nWhID = cr_whid
		     ENDIF
		ENDSCAN
		BLANK FIELDS cr_event, cr_ttcode, cr_whintend, cr_overtime FOR EMPTY(cr_sysdate)
		BLANK FIELDS cr_whsun, cr_whhol, cr_whng1, cr_whng2, cr_whng3 FOR EMPTY(cr_nrwhours)
		
		SELECT &lp_curWHBDet
		APPEND FROM DBF(l_curWhDetails)
		this.oFunctions.TbClose(this.curTimePLan)
		this.oFunctions.TbClose(l_curWhDetails)
		this.oFunctions.TbClose(l_curEmployeealias)
		
		IF l_lReset
		     SET ENGINEBEHAVIOR this.nEngineBehavior
		ENDIF
		
		SELECT (l_nSelect)
	ENDPROC

	PROCEDURE getworkhoursdata
		LPARAMETERS lp_dFromDate, lp_dToDate, lp_nJobNr, lp_curWorkPlan
		LOCAL l_nSelect, l_lReset, l_curResult, l_curEmployeealias, l_curPVacation, l_curVacation, l_dPNYStartDate, l_dNYStartDate, l_dNYEndDate, l_curBreaks, l_nWbMin
		LOCAL l_aTimes(1)
		
		l_nSelect = SELECT()
		
		IF SET("EngineBehavior") <> 70
		     l_lReset = .T.
		     SET ENGINEBEHAVIOR 70
		ENDIF
		
		l_dPNYStartDate = DATE(YEAR(lp_dFromDate)-1,1,1)
		l_dNYStartDate = DATE(YEAR(lp_dFromDate),1,1)
		l_dNYEndDate = DATE(YEAR(lp_dFromDate),12,31)
		
		l_curEmployeealias = SYS(2015)
		l_curPVacation = SYS(2015)
		l_curVacation = SYS(2015)
		SELECT * FROM (this.employeealias) ;
		     WHERE EMPTY(lp_nJobNr) OR em_jbnr = lp_nJobNr ;
		     GROUP BY em_emid ;
		     INTO CURSOR &l_curEmployeealias
		
		SELECT ae_emid, ae_from, ae_to ;
		     FROM (this.asgemplalias) ;
		     INNER JOIN (l_curEmployeealias) ON em_emid = ae_emid ;
		     INNER JOIN (this.timetypealias) ON tt_ttnr = ae_ttnr ;
		     WHERE ae_from < l_dNYStartDate AND ae_to >= l_dPNYStartDate AND tt_vacatio ;
		     INTO CURSOR &l_curPVacation READWRITE
		REPLACE ae_from WITH MAX(ae_from, l_dPNYStartDate), ae_to WITH MIN(ae_to, l_dNYStartDate-1) ALL
		SELECT ae_emid AS c_emid, SUM(ae_to-ae_from+1) AS c_planvac ;
		     FROM &l_curPVacation ;
		     GROUP BY ae_emid ;
		     INTO CURSOR &l_curPVacation
		
		SELECT ae_emid, ae_from, ae_to ;
		     FROM (this.asgemplalias) ;
		     INNER JOIN (l_curEmployeealias) ON em_emid = ae_emid ;
		     INNER JOIN (this.timetypealias) ON tt_ttnr = ae_ttnr ;
		     WHERE ae_from <= l_dNYEndDate AND ae_to >= l_dNYStartDate AND tt_vacatio ;
		     INTO CURSOR &l_curVacation READWRITE
		REPLACE ae_from WITH MAX(ae_from, l_dNYStartDate), ae_to WITH MIN(ae_to, l_dNYEndDate) ALL
		SELECT ae_emid AS c_emid, SUM(ae_to-ae_from+1) AS c_planvac ;
		     FROM &l_curVacation ;
		     GROUP BY ae_emid ;
		     INTO CURSOR &l_curVacation
		
		l_curResult = SYS(2015)
		
		SELECT wi_sysdate, wi_emid, em_pernr, em_lname, em_fname, eh_vacat1, eh_vacat2, c_planvac1, c_planvac2, ;
		     SUM(ROUND(wi_end-wi_begin,0)) AS wi_sum, SUM(NVL(wb_sum,0)) AS wb_sum, 000 AS wd_min FROM (this.WorkIntAlias) ;
		     INNER JOIN ( ;
		          SELECT e.*, ;
		                 CAST(NVL(eh1.eh_vacatio,0) AS N(3)) AS eh_vacat1, ;
		                 CAST(NVL(eh2.eh_vacatio,0) AS N(3)) AS eh_vacat2, ;
		                 CAST(NVL(v1.c_planvac,0) AS N(3)) AS c_planvac1, ;
		                 CAST(NVL(v2.c_planvac,0) AS N(3)) AS c_planvac2 ;
		               FROM (l_curEmployeealias) e ;
		               LEFT JOIN (this.employehalias) eh1 ON eh1.eh_emid = em_emid AND eh1.eh_year = YEAR(lp_dFromDate)-1 ;
		               LEFT JOIN (this.employehalias) eh2 ON eh2.eh_emid = em_emid AND eh2.eh_year = YEAR(lp_dFromDate) ;
		               LEFT JOIN (l_curPVacation) v1 ON v1.c_emid = em_emid ;
		               LEFT JOIN (l_curVacation) v2 ON v2.c_emid = em_emid ;
		     ) em ON em_emid = wi_emid ;
		     LEFT JOIN (SELECT wb_whid, SUM(ROUND(wb_end-wb_begin,0)) AS wb_sum FROM (this.WorkBrkAlias) WHERE NOT EMPTY(wb_end) GROUP BY wb_whid) wb ON wb.wb_whid = wi_whid ;
		     WHERE BETWEEN(wi_sysdate, lp_dFromDate, lp_dToDate) AND NOT EMPTY(wi_end) ;
		     GROUP BY wi_emid, wi_sysdate ;
		     INTO CURSOR &l_curResult READWRITE
		IF this.GetParam("pa_wbautoc")
		     SCAN FOR EMPTY(wb_sum)
		          STORE .F. TO l_aTimes
		          SELECT TOP 1 wi_begin, wi_end, ROUND(wi_end-wi_begin,0) FROM (this.WorkIntAlias) ;
		               WHERE wi_sysdate = &l_curResult..wi_sysdate AND wi_emid = &l_curResult..wi_emid AND NOT EMPTY(wi_end) ;
		               ORDER BY 3 DESC ;
		               INTO ARRAY l_aTimes
		          IF NOT EMPTY(l_aTimes(1))
		               l_nWbMin = this.GetDefaultWorkBreak(@l_curBreaks, wi_sysdate, l_aTimes(1,1), l_aTimes(1,2), .T.)
		               REPLACE wd_min WITH l_nWbMin
		          ENDIF
		     ENDSCAN
		ENDIF
		
		ZAP IN &lp_curWorkPlan
		INSERT INTO &lp_curWorkPlan (cr_emid, cr_name, cr_pernr, cr_vacatio, cr_unusvac, cr_usedvac, cr_sec) ;
		     SELECT wi_emid, ALLTRIM(em_lname)+", "+ALLTRIM(em_fname), em_pernr, eh_vacat2, eh_vacat1-c_planvac1, c_planvac2, SUM(CallFunc("MAX(p1-EVL(p2,60*p3),0)", wi_sum, wb_sum, wd_min)) FROM &l_curResult GROUP BY 1, 2, 3
		BLANK FIELDS cr_unusvac FOR cr_unusvac < 0 IN &lp_curWorkPlan
		
		IF NOT EMPTY(l_curEmployeealias)
		     this.oFunctions.TbClose(l_curEmployeealias)
		ENDIF
		IF NOT EMPTY(l_curPVacation)
		     this.oFunctions.TbClose(l_curPVacation)
		ENDIF
		IF NOT EMPTY(l_curVacation)
		     this.oFunctions.TbClose(l_curVacation)
		ENDIF
		IF NOT EMPTY(l_curResult)
		     this.oFunctions.TbClose(l_curResult)
		ENDIF
		IF NOT EMPTY(l_curBreaks)
		     this.oFunctions.TbClose(l_curBreaks)
		ENDIF
		
		IF l_lReset
		     SET ENGINEBEHAVIOR this.nEngineBehavior
		ENDIF
		
		SELECT (l_nSelect)
		
		RETURN .T.
	ENDPROC

	PROCEDURE getworkhoursdetailsdata
		LPARAMETERS lp_dSelDate, lp_nEmID, lp_curWhDetails
		LOCAL dFromDate, dToDate, nMonth, nYear, nFirstDay, nLastDay
		LOCAL l_nSelect, l_lReset, l_curResult, l_curTimePLan, l_dDate, l_nWhIntend, l_nPause, l_nDefPause, l_nWhours, l_nRWhours, l_nOvertime, l_nNightStart, l_nNightEnd, l_nMidnightStart, l_nMidnightEnd
		LOCAL l_nRow, l_curBreaks, l_nWbMin, l_lCloseMonthPlan, l_cWhIntend, l_cFieldExpr, l_nMidnight1
		LOCAL ARRAY l_aPauses(1), l_aTimes(1), l_aSumRwhours(1)
		
		l_nSelect = SELECT()
		
		this.GetMonthDates(lp_dSelDate, @dFromDate, @dToDate, @nMonth, @nYear, @nFirstDay, @nLastDay)
		
		l_curTimePLan = EVL(this.curTimePLan, SYS(2015))
		IF NOT USED(l_curTimePLan)
		     l_lCloseMonthPlan = .T.
		     this.GetMonthPlanData(lp_dSelDate, 0, l_curTimePLan)
		ENDIF
		l_curResult = MakeDatesCursor(dFromDate, dToDate, "cr_sysdate")
		l_nNightStart =    INT(this.oFunctions.DLookUp(this.AzePickAlias, "aq_label = 'PARAMS    ' AND aq_charcod = 'NGS'", "aq_nval1"))     && Night hours start
		l_nNightEnd =      INT(this.oFunctions.DLookUp(this.AzePickAlias, "aq_label = 'PARAMS    ' AND aq_charcod = 'NGE'", "aq_nval1"))     && Night hours end
		l_nMidnightStart = INT(this.oFunctions.DLookUp(this.AzePickAlias, "aq_label = 'PARAMS    ' AND aq_charcod = 'MDS'", "aq_nval1"))     && Midnight hours start
		l_nMidnight1     = INT(this.oFunctions.DLookUp(this.AzePickAlias, "aq_label = 'PARAMS    ' AND aq_charcod = 'MD1'", "aq_nval1"))     && Midnight part 1
		l_nMidnightEnd =   INT(this.oFunctions.DLookUp(this.AzePickAlias, "aq_label = 'PARAMS    ' AND aq_charcod = 'MDE'", "aq_nval1"))     && Midnight hours end
		
		IF SET("EngineBehavior") <> 70
		     l_lReset = .T.
		     SET ENGINEBEHAVIOR 70
		ENDIF
		
		l_dDate = {}
		SELECT lp_nEmID AS cr_emid, DAY(cr_sysdate) AS cr_nday, cr_sysdate, CAST(NVL(wi_whid,0) AS I) AS cr_whid, CAST(0 AS N(8)) AS cr_whintend, ;
		     CAST(NVL(wi_begin,{}) AS T) AS cr_begin, CAST(NVL(wi_end,{}) AS T) AS cr_end, ;
		     CAST(0 AS Integer) AS cr_dmin, 0=1 AS cr_defbrk, SUM(NVL(ROUND(wb_end-wb_begin,0),0)) AS cr_npause, ;
		     SUM(CFCalcInterval("NIGHT", cr_sysdate, wb_begin, wb_end, l_nNightStart, l_nNightEnd)) AS cr_npng1, ;
		     SUM(CFCalcInterval("NIGHT", cr_sysdate, wb_begin, wb_end, l_nMidnightStart, l_nMidnight1)) AS cr_npng2, ;
		     SUM(CFCalcInterval("NIGHT", cr_sysdate, wb_begin, wb_end, l_nMidnight1, l_nMidnightEnd)) AS cr_npng3, ;
		     CAST(0 AS N(8)) AS cr_whsun, CAST(0 AS N(8)) AS cr_whhol, CAST(0 AS N(8)) AS cr_whng1, CAST(0 AS N(8)) AS cr_whng2, CAST(0 AS N(8)) AS cr_whng3, ;
		     CAST(0 AS N(8)) AS cr_overtime, CAST(0 AS N(8)) AS cr_nwhours, CAST(0 AS N(8)) AS cr_nrwhours, ;
		     cr_sysdate AS cr_date, CAST(NVL(aq_sysdate,{}) AS D) AS aq_sysdate, ;
		     NVL(aq_charcod,"   ") AS cr_event, "  " AS cr_ttcode, ;
		     DTOT(cr_sysdate)+NVL(wi_begin-DTOT(TTOD(wi_begin)),0) AS c_order ;
		     FROM &l_curResult ;
		     LEFT JOIN (this.WorkIntAlias) ON wi_sysdate = cr_sysdate AND wi_emid = lp_nEmID ;
		     LEFT JOIN (this.WorkBrkAlias) ON wb_whid = wi_whid ;
		     LEFT JOIN (SELECT &l_curResult..cr_sysdate AS aq_sysdate, aq_charcod FROM &l_curResult ;
		                    INNER JOIN (this.AzePickAlias) ON aq_label = "HOLIDAY   " AND BETWEEN(&l_curResult..cr_sysdate, aq_dval1, aq_dval2) ;
		                    GROUP BY 1) aq ON cr_sysdate = aq_sysdate ;
		     GROUP BY c_order ;
		     ORDER BY c_order ;
		     INTO CURSOR &l_curResult READWRITE
		IF this.GetParam("pa_wbautoc")
		     SELECT cr_sysdate FROM &l_curResult WHERE NOT EMPTY(cr_npause) GROUP BY cr_sysdate INTO ARRAY l_aPauses
		     SELECT cr_sysdate, ROUND(cr_end-cr_begin,0), cr_whid FROM &l_curResult ;
		          WHERE NOT EMPTY(cr_whid) AND EMPTY(cr_npause) AND NOT EMPTY(cr_end) ;
		          ORDER BY 1, 2 DESC ;
		          INTO ARRAY l_aTimes
		ENDIF
		SCAN
		     IF this.GetParam("pa_wbautoc")
		          IF 0 = ASCAN(l_aPauses,cr_sysdate)
		               l_nRow = ASCAN(l_aTimes,cr_sysdate,1,0,1,8)
		               IF l_nRow > 0 AND cr_whid = l_aTimes(l_nRow,3)
		                    l_nWbMin = this.GetDefaultWorkBreak(@l_curBreaks, cr_sysdate, cr_begin, cr_end, .T.)
		                    REPLACE cr_dmin WITH l_nWbMin, cr_defbrk WITH .T.     && There is no pauses for this date. Add default pause only if no pause for date.
		               ENDIF
		          ENDIF
		     ENDIF
		     IF l_dDate = cr_sysdate
		          BLANK FIELDS cr_sysdate
		     ELSE
		          l_dDate = cr_sysdate
		     ENDIF
		ENDSCAN
		
		IF this.oFunctions.DLocate(l_curTimePLan, "cr_emid = " + this.oFunctions.SqlCnv(lp_nEmID))
		     l_cWhIntend = this.oFunctions.SqlCnv(&l_curTimePLan..cr_whintend)
		     l_cFieldExpr = "ICASE(NOT tt_setpl0, " + l_cWhIntend + ", tt_timepct=0, 0, tt_timunit=1, " + l_cWhIntend + "-tt_timepct*60, " + l_cWhIntend + "*(1-tt_timepct/100))"
		     REPLACE cr_ttcode WITH EVALUATE(l_curTimePLan+".cr_day"+TRANSFORM(cr_nday)), ;
		          cr_whintend WITH MAX(0,IIF(EMPTY(cr_ttcode), 0, this.oFunctions.DLookUp(this.timetypealias, "tt_ttnr = " + this.oFunctions.SqlCnv(EVALUATE(l_curTimePLan+".cr_ttnr"+TRANSFORM(cr_nday))), ;
		          l_cFieldExpr))) ;
		          FOR NOT EMPTY(cr_sysdate)
		ENDIF
		
		REPLACE cr_nwhours WITH MAX(ROUND(cr_end-cr_begin,0)-IIF(cr_defbrk, 60*cr_dmin, cr_npause), 0), ;
		        cr_nrwhours WITH this.GetRoundedHours(MAX(ROUND(cr_end-cr_begin,0)-IIF(cr_defbrk, 60*cr_dmin, cr_npause), 0)) FOR NOT EMPTY(cr_end)
		REPLACE cr_whsun WITH IIF(EMPTY(aq_sysdate) AND DOW(cr_date,1) = 1, cr_nwhours, 0), cr_whhol WITH IIF(EMPTY(aq_sysdate), 0, cr_nwhours), ;
		        cr_whng1 WITH CFCalcInterval("NIGHT", cr_date, cr_begin, cr_end, l_nNightStart, l_nNightEnd) - cr_npng1, ;
		        cr_whng2 WITH CFCalcInterval("NIGHT", cr_date, cr_begin, cr_end, l_nMidnightStart, l_nMidnight1) - cr_npng2, ;
		        cr_whng3 WITH CFCalcInterval("NIGHT", cr_date, cr_begin, cr_end, l_nMidnight1, l_nMidnightEnd) - cr_npng3 FOR NOT EMPTY(cr_end)
		SELECT SUM(cr_nrwhours) FROM &l_curResult GROUP BY cr_nday INTO ARRAY l_aSumRwhours
		REPLACE cr_overtime WITH l_aSumRwhours(cr_nday)-cr_whintend FOR NOT EMPTY(cr_whintend) OR NOT EMPTY(cr_sysdate) AND NOT EMPTY(cr_nrwhours)
		* Calculate SUM Values in last row
		STORE 0 TO l_nWhIntend, l_nPause, l_nDefPause, l_nWhours, l_nRWhours, l_nOvertime, l_nWhSun, l_nWhHol, l_nWhNg1, l_nWhNg2
		SUM cr_whintend, cr_npause, IIF(cr_defbrk, cr_dmin, 0), cr_nwhours, cr_nrwhours, cr_overtime, cr_whsun, cr_whhol, cr_whng1, cr_whng2, cr_whng3 ALL ;
		     TO l_nWhIntend, l_nPause, l_nDefPause, l_nWhours, l_nRWhours, l_nOvertime, l_nWhSun, l_nWhHol, l_nWhNg1, l_nWhNg2, l_nWhNg3
		INSERT INTO &l_curResult (cr_emid, cr_nday, cr_whintend, cr_npause, cr_dmin, cr_defbrk, cr_nwhours, cr_nrwhours, cr_overtime, cr_whsun, cr_whhol, cr_whng1, cr_whng2, cr_whng3) ;
		     VALUES (lp_nEmID, 99, l_nWhIntend, INT(l_nPause), INT(l_nDefPause), 0=0, INT(l_nWhours), INT(l_nRWhours), INT(l_nOvertime), INT(l_nWhSun), INT(l_nWhHol), INT(l_nWhNg1), INT(l_nWhNg2), INT(l_nWhNg3))
		
		SELECT &lp_curWhDetails
		ZAP
		APPEND FROM DBF(l_curResult)
		IF NOT EMPTY(l_curResult)
		     this.oFunctions.TbClose(l_curResult)
		ENDIF
		IF l_lCloseMonthPlan
		     this.oFunctions.TbClose(l_curTimePLan)
		ENDIF
		IF NOT EMPTY(l_curBreaks)
		     this.oFunctions.TbClose(l_curBreaks)
		ENDIF
		
		IF l_lReset
		     SET ENGINEBEHAVIOR this.nEngineBehavior
		ENDIF
		
		SELECT (l_nSelect)
		
		RETURN .T.
	ENDPROC

	PROCEDURE Init
		this.nEngineBehavior = SET("EngineBehavior")
	ENDPROC

	PROCEDURE mergeintervals
		LPARAMETERS lp_dSearchDate, lp_nJobNr, lp_curMonthPlan, lp_curMonthPlanCopy
		LOCAL l_nSelect, l_lReset, l_lChanged, l_curEmployeealias, l_curOldAeIntervals, l_curNewAeIntervals, l_cField, l_dDate, l_dFrom, l_dTo, l_oAsgempl
		
		l_nSelect = SELECT()
		
		IF SET("EngineBehavior") <> 70
		     l_lReset = .T.
		     SET ENGINEBEHAVIOR 70
		ENDIF
		
		l_nRecno = RECNO(lp_curMonthPlan)
		l_curEmployeealias = SYS(2015)
		l_curOldAeIntervals = SYS(2015)
		l_curNewAeIntervals = SYS(2015)
		l_dFrom = lp_dSearchDate
		l_dTo = GetRelDate(l_dFrom,,31)
		
		SELECT * FROM (this.employeealias) ;
		     WHERE EMPTY(lp_nJobNr) OR em_jbnr = lp_nJobNr ;
		     GROUP BY em_emid ;
		     INTO CURSOR &l_curEmployeealias
		SELECT ae.* FROM (this.AsgemplAlias) ae ;
		     INNER JOIN (l_curEmployeealias) ON em_emid = ae_emid ;
		     WHERE ae_from <= l_dTo+1 AND ae_to >= l_dFrom-1 ;
		     ORDER BY em_lname, em_fname, ae_from ;
		     INTO CURSOR &l_curOldAeIntervals READWRITE
		SELECT * FROM (this.AsgemplAlias) WHERE 0=1 INTO CURSOR &l_curNewAeIntervals READWRITE
		
		* Make new intervals from current browse on screen
		SELECT &lp_curMonthPlan
		SCAN
		     this.oFunctions.DLocate(lp_curMonthPlanCopy, "cr_emid = " + this.oFunctions.SqlCnv(&lp_curMonthPlan..cr_emid))
		     l_dDate = l_dFrom
		     DO WHILE l_dDate <= l_dTo
		          l_cField = "cr_ttnr" + TRANSFORM(DAY(l_dDate))
		          IF NOT EMPTY(&l_cField)
		               IF this.oFunctions.DLocate(l_curNewAeIntervals, "ae_emid = " + this.oFunctions.SqlCnv(&lp_curMonthPlan..cr_emid) + ;
		                         " AND ae_ttnr = " + this.oFunctions.SqlCnv(&lp_curMonthPlan..&l_cField) + " AND ae_to = " + this.oFunctions.SqlCnv(l_dDate-1))
		                    REPLACE ae_to WITH l_dDate IN &l_curNewAeIntervals
		               ELSE
		                    INSERT INTO &l_curNewAeIntervals (ae_emid, ae_ttnr, ae_from, ae_to) ;
		                         VALUES (&lp_curMonthPlan..cr_emid, &lp_curMonthPlan..&l_cField, l_dDate, l_dDate)
		               ENDIF
		          ENDIF
		          l_dDate = l_dDate + 1
		          IF &lp_curMonthPlan..&l_cField <> &lp_curMonthPlanCopy..&l_cField
		               l_lChanged = .T.
		          ENDIF
		     ENDDO
		ENDSCAN
		
		IF l_lChanged
		     * Merge edges with old intervals if exists and deleted old edges from cursor as processed.
		     SELECT &l_curNewAeIntervals
		     SCAN FOR ae_from = l_dFrom
		          IF this.oFunctions.DLocate(l_curOldAeIntervals, "ae_emid = " + this.oFunctions.SqlCnv(&l_curNewAeIntervals..ae_emid) + ;
		                    " AND ae_ttnr = " + this.oFunctions.SqlCnv(&l_curNewAeIntervals..ae_ttnr) + " AND BETWEEN(" + this.oFunctions.SqlCnv(l_dFrom-1) + ", ae_from, ae_to)")
		               REPLACE ae_aeid WITH &l_curOldAeIntervals..ae_aeid, ae_from WITH &l_curOldAeIntervals..ae_from IN &l_curNewAeIntervals
		               IF &l_curOldAeIntervals..ae_to > l_dTo
		                    REPLACE ae_aeid WITH 0, ae_from WITH l_dTo+1 IN &l_curOldAeIntervals
		               ELSE
		                    DELETE IN &l_curOldAeIntervals
		               ENDIF
		          ENDIF
		     ENDSCAN
		     SCAN FOR ae_to = l_dTo
		          IF this.oFunctions.DLocate(l_curOldAeIntervals, "ae_emid = " + this.oFunctions.SqlCnv(&l_curNewAeIntervals..ae_emid) + ;
		                    " AND ae_ttnr = " + this.oFunctions.SqlCnv(&l_curNewAeIntervals..ae_ttnr) + " AND BETWEEN(" + this.oFunctions.SqlCnv(l_dTo+1) + ", ae_from, ae_to)")
		               REPLACE ae_aeid WITH EVL(&l_curNewAeIntervals..ae_aeid,&l_curOldAeIntervals..ae_aeid), ;
		                    ae_to WITH &l_curOldAeIntervals..ae_to IN &l_curNewAeIntervals
		               DELETE IN &l_curOldAeIntervals
		          ENDIF
		     ENDSCAN
		
		     * Update tails from old interval cursor to asgempl.dbf
		     SELECT &l_curOldAeIntervals
		     SCAN FOR BETWEEN(l_dFrom-1, ae_from, ae_to) AND this.oFunctions.DLocate(this.AsgemplAlias, "ae_aeid = " + this.oFunctions.SqlCnv(&l_curOldAeIntervals..ae_aeid))
		          REPLACE ae_to WITH l_dFrom-1 IN (this.AsgemplAlias)
		          IF &l_curOldAeIntervals..ae_to > l_dTo
		               REPLACE ae_aeid WITH 0, ae_from WITH l_dTo+1 IN &l_curOldAeIntervals
		          ELSE
		               DELETE IN &l_curOldAeIntervals
		          ENDIF
		     ENDSCAN
		     SCAN FOR BETWEEN(l_dTo+1, ae_from, ae_to) AND ae_aeid > 0 AND this.oFunctions.DLocate(this.AsgemplAlias, "ae_aeid = " + this.oFunctions.SqlCnv(&l_curOldAeIntervals..ae_aeid))
		          REPLACE ae_from WITH l_dTo+1 IN (this.AsgemplAlias)
		          DELETE IN &l_curOldAeIntervals
		     ENDSCAN
		
		     * Get old IDs from cursor with old intervals and match (delete) them as processed.
		     SELECT &l_curNewAeIntervals
		     SCAN FOR ae_aeid = 0
		          IF this.oFunctions.DLocate(l_curOldAeIntervals, "ae_aeid > 0 AND ae_emid = " + this.oFunctions.SqlCnv(&l_curNewAeIntervals..ae_emid) + ;
		                    " AND ae_from = " + this.oFunctions.SqlCnv(&l_curNewAeIntervals..ae_from))
		               REPLACE ae_aeid WITH &l_curOldAeIntervals..ae_aeid IN &l_curNewAeIntervals
		               DELETE IN &l_curOldAeIntervals
		          ENDIF
		     ENDSCAN
		     APPEND FROM DBF(l_curOldAeIntervals) FOR ae_aeid = 0
		     DELETE FOR ae_aeid = 0 IN &l_curOldAeIntervals
		     GO TOP IN &l_curOldAeIntervals
		     LOCATE
		     SCAN FOR ae_aeid = 0 WHILE &l_curOldAeIntervals..ae_aeid > 0
		          REPLACE ae_aeid WITH &l_curOldAeIntervals..ae_aeid IN &l_curNewAeIntervals
		          DELETE IN &l_curOldAeIntervals
		          SKIP IN &l_curOldAeIntervals
		     ENDSCAN
		     * Commit new intervals to asgempl.dbf
		     SCAN
		          SCATTER MEMO NAME l_oAsgempl
		          DO CASE
		               CASE l_oAsgempl.ae_aeid = 0
		                    l_oAsgempl.ae_aeid = this.oFunctions.NextId("ASGEMPL", this.AsgemplAlias)
		                    INSERT INTO (this.AsgemplAlias) FROM NAME l_oAsgempl
		               CASE this.oFunctions.DLocate(this.AsgemplAlias, "ae_aeid = " + this.oFunctions.SqlCnv(&l_curNewAeIntervals..ae_aeid))
		                    IF RecordChanged(l_oAsgempl, this.AsgemplAlias)
		                         SELECT (this.AsgemplAlias)
		                         GATHER NAME l_oAsgempl MEMO
		                         SELECT &l_curNewAeIntervals
		                    ENDIF
		               OTHERWISE
		          ENDCASE
		     ENDSCAN
		     * Delete all unmatched intervals as dummy from asgempl.dbf.
		     SELECT &l_curOldAeIntervals
		     SCAN FOR this.oFunctions.DLocate(this.AsgemplAlias, "ae_aeid = " + this.oFunctions.SqlCnv(&l_curOldAeIntervals..ae_aeid))
		          DELETE IN (this.AsgemplAlias)
		     ENDSCAN
		     CommitChanges(this.AsgemplAlias)
		ENDIF
		
		this.oFunctions.TbClose(l_curOldAeIntervals)
		this.oFunctions.TbClose(l_curNewAeIntervals)
		this.oFunctions.TbClose(l_curEmployeealias)
		
		GO l_nRecno IN (lp_curMonthPlan)
		
		IF l_lReset
		     SET ENGINEBEHAVIOR this.nEngineBehavior
		ENDIF
		
		SELECT (l_nSelect)
		
		RETURN l_lChanged
	ENDPROC

	PROCEDURE settimetype
		LPARAMETERS lp_nTtNr, lp_nDay, lp_curMonthPlan
		LOCAL l_nStatus, l_cField, l_nOldTtNr, l_lOldTtVacation, l_lTtVacation
		
		l_nStatus = 0
		
		IF BETWEEN(lp_nTtNr, 1, 99) OR lp_nTtNr = 999     && Clear or set CODE
		     IF lp_nTtNr = 999
		          lp_nTtNr = 0
		     ENDIF
		     l_cField = "cr_ttnr"+TRANSFORM(lp_nDay)
		     l_nOldTtNr = &lp_curMonthPlan..&l_cField
		     l_lOldTtVacation = this.oFunctions.DLookUp(this.timetypealias, "tt_ttnr = " + this.oFunctions.SqlCnv(l_nOldTtNr), "tt_vacatio")
		     l_lTtVacation = this.oFunctions.DLookUp(this.timetypealias, "tt_ttnr = " + this.oFunctions.SqlCnv(lp_nTtNr), "tt_vacatio")
		     l_nStatus = 1
		     DO CASE
		          CASE l_lOldTtVacation = l_lTtVacation
		          CASE l_lOldTtVacation
		               REPLACE cr_usedvac WITH cr_usedvac-1 IN &lp_curMonthPlan
		          CASE &lp_curMonthPlan..cr_usedvac < &lp_curMonthPlan..cr_vacatio+&lp_curMonthPlan..cr_unusvac
		               REPLACE cr_usedvac WITH cr_usedvac+1 IN &lp_curMonthPlan
		          CASE EMPTY(&lp_curMonthPlan..cr_vacatio+&lp_curMonthPlan..cr_unusvac)
		               l_nStatus = -1
		          OTHERWISE
		               l_nStatus = -2
		     ENDCASE
		     IF l_nStatus > 0
		          REPLACE &l_cField WITH lp_nTtNr IN &lp_curMonthPlan
		          l_cField = "cr_day"+TRANSFORM(lp_nDay)
		          REPLACE &l_cField WITH this.oFunctions.DLookUp(this.timetypealias, "tt_ttnr = " + this.oFunctions.SqlCnv(lp_nTtNr), "tt_code") IN &lp_curMonthPlan
		     ENDIF
		ENDIF
		
		RETURN l_nStatus
	ENDPROC

	PROCEDURE userisemployee
	ENDPROC

	PROCEDURE workhourshandle
		LPARAMETERS lp_lLogin, lp_nWhId, lp_nWbId
		LOCAL l_lChanged, l_cEmployeeAlias, l_cWorkIntAlias, l_cWorkBrkAlias, l_cName, l_cTime, l_dSysDate, l_dBegin, l_dEnd, l_nWbMin, l_curBreaks, l_nEmpID
		
		l_cEmployeeAlias = this.EmployeeAlias
		l_cWorkIntAlias = this.WorkIntAlias
		l_cWorkBrkAlias = this.WorkBrkAlias
		
		l_nEmpID = &l_cEmployeeAlias..em_emid
		l_cName = ALLTRIM(&l_cEmployeeAlias..em_fname) + ' ' + ALLTRIM(&l_cEmployeeAlias..em_lname)
		l_cTime = LEFT(TIME(),5)
		
		IF this.oFunctions.DLocate(this.WorkIntAlias,'wi_emid = ' + sqlcnv(l_nEmpID) + ' AND EMPTY(wi_end)')
		     IF this.oFunctions.YesNo(this.oFunctions.GetLanguageText("A|1305|EMPLOYEE","%s1 goes am %s2. Please confirm.", l_cName, l_cTime))
		          lp_nWhId = &l_cWorkIntAlias..wi_whid
		          l_dEnd = DATETIME()
		          * Check Workpause
		          REPLACE wi_end WITH l_dEnd IN (this.WorkIntAlias)
		          IF this.oFunctions.DLocate((this.WorkBrkAlias), 'wb_whid = ' + sqlcnv(&l_cWorkIntAlias..wi_whid) + ' AND EMPTY(wb_end)')
		               lp_nWbId = &l_cWorkBrkAlias..wb_wbid
		               l_nWbMin = this.GetDefaultWorkBreak(@l_curBreaks,,&l_cWorkIntAlias..wi_begin, &l_cWorkIntAlias..wi_end)
		               REPLACE wb_end WITH MAX(&l_cWorkIntAlias..wi_end, &l_cWorkBrkAlias..wb_begin+60*l_nWbMin) IN (this.WorkBrkAlias)
		               CommitChanges(this.WorkBrkAlias)
		          ENDIF
		          l_lChanged = .T.
		          lp_lLogin = .F.
		          CommitChanges(this.WorkIntAlias)
		     ENDIF
		ELSE
		     IF this.oFunctions.YesNo(this.oFunctions.GetLanguageText("A|1304|EMPLOYEE","%s1 comes am %s2. Please confirm.", l_cName, l_cTime))
		          lp_nWhId = this.oFunctions.NextID('WORKINT', this.WorkIntAlias)
		          l_dSysDate = DATE()
		          l_dBegin = DATETIME()
		          INSERT INTO (this.WorkIntAlias) (wi_whid, wi_sysdate, wi_begin, wi_emid) ;
		               VALUES (lp_nWhId, l_dSysDate, l_dBegin, l_nEmpID)
		          l_lChanged = .T.
		          lp_lLogin = .T.
		          CommitChanges(this.WorkIntAlias)
		     ENDIF
		ENDIF
		FLUSH
		
		RETURN l_lChanged
	ENDPROC

	PROCEDURE workpausehandle
		LPARAMETERS lp_lPauseStart, lp_nWbId
		LOCAL l_lChanged, l_cEmployeeAlias, l_cWorkIntAlias, l_cWorkBrkAlias, l_cName, l_dBegin, l_dEnd, l_nEmpID, l_nWhID, l_nWbMin, l_curBreaks
		
		l_cEmployeeAlias = this.EmployeeAlias
		l_cWorkIntAlias = this.WorkIntAlias
		l_cWorkBrkAlias = this.WorkBrkAlias
		
		l_nEmpID = &l_cEmployeeAlias..em_emid
		l_cName = TRIM(&l_cEmployeeAlias..em_fname) + ' ' + TRIM(&l_cEmployeeAlias..em_lname)
		
		IF NOT this.oFunctions.DLocate(this.WorkIntAlias, 'wi_emid = ' + sqlcnv(l_nEmpID) + ' AND EMPTY(wi_end)')
		     this.oFunctions.Alert(this.oFunctions.GetLanguageText("A|1306|EMPLOYEE", "You must first sign on work period!"))
		     RETURN .F.
		ENDIF
		l_nWhID = &l_cWorkIntAlias..wi_whid
		IF this.oFunctions.DLocate(this.WorkBrkAlias, 'wb_whid = ' + sqlcnv(l_nWhID) + ' AND EMPTY(wb_end)')
		     l_nWbMin = this.GetDefaultWorkBreak(@l_curBreaks,,&l_cWorkIntAlias..wi_begin, DATETIME())
		     l_dEnd = MAX(DATETIME(), &l_cWorkBrkAlias..wb_begin+60*l_nWbMin)
		     IF this.oFunctions.YesNo(this.oFunctions.GetLanguageText("A|1307|EMPLOYEE","%s1 comes am %s2. Please confirm.", l_cName, LEFT(TTOC(l_dEnd,2),5)))
		          lp_nWbId = &l_cWorkBrkAlias..wb_wbid
		          REPLACE wb_end WITH l_dEnd IN (this.WorkBrkAlias)
		          l_lChanged = .T.
		          lp_lPauseStart = .F.
		          CommitChanges(this.WorkBrkAlias)
		     ENDIF
		ELSE
		     l_dBegin = DATETIME()
		     IF this.oFunctions.DLocate(this.WorkBrkAlias,'wb_whid = ' + sqlcnv(l_nWhID) + ' AND BETWEEN(' + sqlcnv(l_dBegin) + ', wb_begin, wb_end)')
		          this.oFunctions.Alert(this.oFunctions.GetLanguageText("A|1421|EMPLOYEE", "%s1 is still on a break!", l_cName))
		     ELSE
		          IF this.oFunctions.YesNo(this.oFunctions.GetLanguageText("A|1309|EMPLOYEE", "%s1 goes on break on %s2. Please confirm.", l_cName, LEFT(TTOC(l_dBegin,2),5)))
		               lp_nWbId = this.oFunctions.NextID('WORKBRK', this.WorkBrkAlias)
		               INSERT INTO (this.WorkBrkAlias) (wb_wbid, wb_whid, wb_begin) ;
		                    VALUES (lp_nWbId, l_nWhID, l_dBegin)
		               l_lChanged = .T.
		               lp_lPauseStart = .T.
		               CommitChanges(this.WorkBrkAlias)
		          ENDIF
		     ENDIF
		ENDIF
		FLUSH
		
		RETURN l_lChanged
	ENDPROC

ENDDEFINE
