*--------------------------------------------------------------------------------------------------------------------------------------------------------
* (ES) AUTOGENERADO - ¡¡ATENCIÓN!! - ¡¡NO PENSADO PARA EJECUTAR!! USAR SOLAMENTE PARA INTEGRAR CAMBIOS Y ALMACENAR CON HERRAMIENTAS SCM!!
* (EN) AUTOGENERATED - ATTENTION!! - NOT INTENDED FOR EXECUTION!! USE ONLY FOR MERGING CHANGES AND STORING WITH SCM TOOLS!!
*--------------------------------------------------------------------------------------------------------------------------------------------------------
*< FOXBIN2PRG: Version="1.19" SourceFile="cit_functions.vcx" /> (Solo para binarios VFP 9 / Only for VFP 9 binaries)
*
*
DEFINE CLASS functions AS custom 
 	*< CLASSDATA: Baseclass="custom" Timestamp="" Scale="Pixels" Uniqueid="" />

	*<DefinedPropArrayMethod>
		*m: alert
		*m: changedatasession
		*m: convsectotime
		*m: createcursorfromarray
		*m: cursoraddfield
		*m: dappend
		*m: dlocate
		*m: dlookup
		*m: dupdate
		*m: foarticlevatamounts
		*m: foartiininstr
		*m: fobillactioncheck
		*m: fobillinstr
		*m: fobillnumchange
		*m: fobillopenreason
		*m: fobillsresercheck
		*m: fogetbilldata
		*m: fogetfreewindow
		*m: fogetfreewindowpos
		*m: fogetparam
		*m: fogetwindowdata
		*m: fonextid
		*m: foreplcode
		*m: forestricted
		*m: fosetwindowdata
		*m: getdayname
		*m: getlanguagetext
		*m: getmaincompanylangcode
		*m: gettime
		*m: getusername
		*m: lastday
		*m: nextid
		*m: oncardpresent
		*m: oncardremove
		*m: pickavailtable
		*m: pickavailtableform
		*m: preparedataforreservation
		*m: prepareenvironment
		*m: procceedcardforreservat
		*m: restoredatasession
		*m: restoreenvironment
		*m: sqlcnv
		*m: sqlcursor
		*m: sqlwhere
		*m: strtomsg
		*m: tbclose
		*m: tblock
		*m: tbopen
		*m: tbunlock
		*m: uniquevouchernumber
		*m: winpc
		*m: yesno
		*m: yesnocancel
		*p: carticle
		*p: cbillinst
		*p: cbillnum
		*p: cpicklist
		*p: cpswindow
		*p: creservat
		*p: nolddatasessionid
		*p: odatasession
	*</DefinedPropArrayMethod>

	carticle = FOArticle
	cbillinst = FOBillInst
	cbillnum = FOBillnum
	cpicklist = FOPicklist
	cpswindow = FOPswindow
	creservat = FOReservat
	Name = "functions"
	nolddatasessionid = 0
	odatasession = .NULL.
	
	PROCEDURE alert
		LPARAMETERS tcText, tcHeader, tnButtons
	ENDPROC

	PROCEDURE changedatasession
		LPARAMETERS tnDataSessionId
		IF VARTYPE(tnDataSessionId) # "N"
			RETURN .T.
		ENDIF
		this.nOldDataSessionId = SET("Datasession")
		SET DATASESSION TO tnDataSessionId
		RETURN .T.
	ENDPROC

	PROCEDURE convsectotime
		LPARAMETERS tnSeconds, tnFormat, tlDummy
		
		RETURN ConvSecToTime(tnSeconds, tnFormat, tlDummy)
	ENDPROC

	PROCEDURE createcursorfromarray
		LPARAMETERS tcCursorName, taFields
		
		CreateCursorFromArray(@tcCursorName, @taFields)
	ENDPROC

	PROCEDURE cursoraddfield
		LPARAMETERS taFields, tcNewName, tcNewType, tnNewWidth, tnDecPlaces, tlNullValues
		
		CursorAddField(@taFields, tcNewName, tcNewType, tnNewWidth, tnDecPlaces, tlNullValues)
	ENDPROC

	PROCEDURE dappend
		LPARAMETERS tcAlias, toRecord, plForceODBC
		
		INSERT INTO (tcAlias) FROM NAME toRecord
	ENDPROC

	PROCEDURE dlocate
		LPARAMETERS tcAlias, tcExpr
	ENDPROC

	PROCEDURE dlookup
		LPARAMETERS tcAlias, tcWhere, tcExpr, tlCache
	ENDPROC

	PROCEDURE dupdate
		LPARAMETERS tcAlias, tcWhere, toRecord, plForceODBC
		
		IF this.DLocate(tcAlias, tcWhere)
			SELECT &tcAlias
			GATHER NAME toRecord
		ENDIF
	ENDPROC

	PROCEDURE foarticlevatamounts
		LPARAMETERS lp_nArtinum, lp_nAmount, lp_aVat, lp_lForPayment
		LOCAL l_cArtAlias, l_lExclvat, l_lCompvat, l_nVatPct1, l_nVatPct2, l_cVatTyp2, l_nPurchasePrice
		EXTERNAL ARRAY lp_aVat
		
		l_cArtAlias = this.cArticle
		IF this.DLocate(l_cArtAlias, "ar_artinum = " + this.SqlCnv(lp_nArtinum))
			lp_aVat(1,1) = &l_cArtAlias..ar_vat
			l_nVatPct1 = &l_cArtAlias..pl_numval
			lp_aVat(2,1) = &l_cArtAlias..ar_vat2
			l_nVatPct2 = &l_cArtAlias..pl_numval2
			l_cVatTyp2 = &l_cArtAlias..pl_user2
		ELSE
			lp_aVat(1,1) = 0
			l_nVatPct1 = 0
			lp_aVat(2,1) = 0
			l_nVatPct2 = 0
			l_cVatTyp2 = ""
		ENDIF
		IF this.FOGetParam("pa_exclvat", @l_lExclvat) AND l_lExclvat
			IF UPPER(ALLTRIM(l_cVatTyp2)) <> "PP"
				IF lp_lForPayment
					IF UPPER(ALLTRIM(l_cVatTyp2)) <> "BT"
						IF this.FOGetParam("pa_compvat", @l_lCompvat) AND l_lCompvat
							lp_nAmount = lp_nAmount * (100 / (100 + l_nVatPct1 + l_nVatPct2 + l_nVatPct1 * l_nVatPct2 / 100))
						ELSE
							lp_nAmount = lp_nAmount * (100 / (100 + l_nVatPct1 + l_nVatPct2))
						ENDIF
					ELSE
						lp_nAmount = (lp_nAmount - l_nVatPct2) * (100 / (100 + l_nVatPct1))
					ENDIF
				ENDIF
				lp_aVat(1,2) = lp_nAmount * (l_nVatPct1 / 100)
				IF UPPER(ALLTRIM(l_cVatTyp2)) <> "BT"
					IF this.FOGetParam("pa_compvat", @l_lCompvat) AND l_lCompvat
						lp_aVat(2,2) = (lp_nAmount + lp_aVat(1,2)) * (l_nVatPct2 / 100)					
					ELSE
						lp_aVat(2,2) = lp_nAmount * (l_nVatPct2 / 100)
					ENDIF
				ELSE
					lp_aVat(2,2) = l_nVatPct2
				ENDIF
			ELSE
				l_nPurchasePrice = &l_cArtAlias..ar_pprice
				IF lp_nAmount - l_nPurchasePrice > 0
					IF lp_lForPayment
						lp_nAmount = (lp_nAmount + l_nPurchasePrice * l_nVatPct2 / (100 - l_nVatPct2) * (1 + l_nVatPct1 / 100)) / ;
							(1 + l_nVatPct2 / (100 - l_nVatPct2) + l_nVatPct1 / 100 + l_nVatPct2 / (100 - l_nVatPct2) * l_nVatPct1 / 100)
					ENDIF
					lp_aVat(2,2) = (lp_nAmount - l_nPurchasePrice) * l_nVatPct2 / (100 - l_nVatPct2)
				ELSE
					lp_nAmount = lp_nAmount * 100 / (100 + l_nVatPct1)
				ENDIF
				lp_aVat(1,2) = (lp_nAmount + lp_aVat(2,2)) * (l_nVatPct1 / 100)
			ENDIF
		ELSE
			lp_aVat(1,2) = lp_nAmount * ( 1 - (100 / (100 + l_nVatPct1)))
			DO CASE
				CASE UPPER(ALLTRIM(l_cVatTyp2)) == "PP"
					l_nPurchasePrice = &l_cArtAlias..ar_pprice
					IF lp_nAmount - l_nPurchasePrice - lp_aVat(1,2) > 0
						lp_aVat(2,2) = (lp_nAmount - l_nPurchasePrice - lp_aVat(1,2)) * (l_nVatPct2 / 100)
					ENDIF
				CASE UPPER(ALLTRIM(l_cVatTyp2)) == "BT"
					lp_aVat(2,2) = l_nVatPct2
				OTHERWISE
					lp_aVat(2,2) = lp_nAmount * ( 1 - (100 / (100 + l_nVatPct2)))
			ENDCASE
		ENDIF
		
		RETURN
	ENDPROC

	PROCEDURE foartiininstr
		LPARAMETERS lp_nArtinum, lp_cInstr
		LOCAL i, l_lRetVal, l_lExclude, l_cExpr, l_nMinVal, l_nMaxVal
		
		lp_cInstr = UPPER(ALLTRIM(STRTRAN(EVL(lp_cInstr,""), " ")))
		DO CASE
		     CASE EMPTY(lp_cInstr)
		     CASE lp_cInstr == "*"                 && All articles
		          l_lRetVal = .T.
		     OTHERWISE
		          IF LEFT(lp_cInstr, 2) == "*/"
		               lp_cInstr = SUBSTR(lp_cInstr, 3)
		               l_lExclude = .T.            && Exclude article list
		          ENDIF
		          l_lRetVal = l_lExclude
		          this.FOReplCode(@lp_cInstr)
		          FOR i = 1 TO GETWORDCOUNT(lp_cInstr,",")
		               l_cExpr = ALLTRIM(GETWORDNUM(lp_cInstr,i,","))
		               DO CASE
		                    CASE TRANSFORM(lp_nArtinum) == l_cExpr
		                         l_lRetVal = NOT l_lExclude
		                         EXIT
		                    CASE "-" $ l_cExpr     && Article range
		                         l_nMinVal = INT(VAL(GETWORDNUM(l_cExpr,1,"-")))
		                         l_nMaxVal = INT(VAL(GETWORDNUM(l_cExpr,2,"-")))
		                         IF BETWEEN(lp_nArtinum, l_nMinVal, l_nMaxVal)
		                              l_lRetVal = NOT l_lExclude
		                              EXIT
		                         ENDIF
		               ENDCASE
		          ENDFOR
		ENDCASE
		
		RETURN l_lRetVal
	ENDPROC

	PROCEDURE fobillactioncheck
		LPARAMETERS lp_cAction, lp_cStatus, lp_lValid
		
		DO CASE
		     CASE lp_cAction = "PRINT"
		          lp_lValid = (lp_cStatus <> "CXL")
		     CASE INLIST(lp_cAction, "CANCEL", "BILL_ADDR", "PAY_NEW", "POST_NEW", "POST_EDT", "POST_DEL", "POST_MARK", "POST_SPLIT", "POST_INSERT", "POST_REDIRECT", "POST_RATECOD")
		          lp_lValid = EMPTY(lp_cStatus) OR (lp_cStatus=="OPN")
		     CASE lp_cAction = "CHKOUT"
		          lp_lValid = EMPTY(lp_cStatus) OR INLIST(lp_cStatus, "OPN", "PCO")
		*    CASE lp_cAction = "UPD_CHKOUT"
		*         lp_lValid = (lp_cStatus == "PCO")
		     CASE lp_cAction = "INVOICE"
		          lp_lValid = .T.
		     OTHERWISE
		          lp_lValid = .F.
		ENDCASE
		
		RETURN lp_lValid
	ENDPROC

	PROCEDURE fobillinstr
		LPARAMETERS lp_nArtinum, lp_cBillInstr, lp_nReserId, lp_nWindow, lp_lSilent, lp_oReservat
		LOCAL ARRAY l_aWin(1)
		LOCAL l_cResAlias, l_Id1, l_Instr1, l_Instr2, l_Instr3, l_Instr4, l_lAllow, l_nWindowSuggestion
		
		l_cResAlias = this.cReservat
		l_Id1 = VAL(STRTRAN(LEFT(MLINE(lp_cBillInstr,1), 12), ',', '.'))
		l_Instr1 = SUBSTR(MLINE(lp_cBillInstr,1), 13)
		l_Instr2 = SUBSTR(MLINE(lp_cBillInstr,2), 13)
		l_Instr3 = SUBSTR(MLINE(lp_cBillInstr,3), 13)
		l_Instr4 = SUBSTR(MLINE(lp_cBillInstr,4), 13)
		l_nWindowSuggestion = 0
		IF TYPE("lp_oReservat") <> "O"
		     lp_oReservat = .NULL.
		ENDIF
		DO CASE
		     CASE this.FOArtiInInstr(lp_nArtinum,l_Instr1) AND this.FORestricted(lp_nReserId, lp_oReservat)
		          this.PrepareDataForReservation(l_Id1)
		          IF this.DLocate(l_cResAlias, "rs_reserid = " + this.SqlCnv(l_Id1))
		               IF EMPTY(&l_cResAlias..rs_out) AND NOT INLIST(&l_cResAlias..rs_status, "CXL", "NS")
		                    l_nWindowSuggestion = this.FOGetFreeWindow(&l_cResAlias..rs_reserid,1)
		                    l_aWin(1) = l_nWindowSuggestion
		                    IF this.FOBillsReserCheck(&l_cResAlias..rs_reserid, @l_aWin, "POST_NEW", @l_lAllow, lp_lSilent)
		                         lp_nWindow = l_nWindowSuggestion
		                         lp_nReserId = l_Id1
		                    ENDIF
		               ENDIF
		          ENDIF
		     CASE this.FOArtiInInstr(lp_nArtinum,l_Instr2)
		          l_nWindowSuggestion = this.FOGetFreeWindow(&l_cResAlias..rs_reserid,2)
		          l_aWin(1) = l_nWindowSuggestion
		          IF this.FOBillsReserCheck(lp_nReserId, @l_aWin, "POST_NEW", @l_lAllow, lp_lSilent)
		               lp_nWindow = l_nWindowSuggestion
		          ENDIF
		     CASE this.FOArtiInInstr(lp_nArtinum,l_Instr3)
		          l_nWindowSuggestion = this.FOGetFreeWindow(&l_cResAlias..rs_reserid,3)
		          l_aWin(1) = l_nWindowSuggestion
		          IF this.FOBillsReserCheck(lp_nReserId, @l_aWin, "POST_NEW", @l_lAllow, lp_lSilent)
		               lp_nWindow = l_nWindowSuggestion
		          ENDIF
		ENDCASE
		
		RETURN
	ENDPROC

	PROCEDURE fobillnumchange
		LPARAMETERS lp_cBillNum, lp_cAction, lp_cReason, lp_nPayNum, lp_nAmount, lp_nAyID, lp_nBillType
		
		RETURN .T.
	ENDPROC

	PROCEDURE fobillopenreason
		LPARAMETERS lp_cBillStatus, lp_cWindows, lp_lSilent, lp_lForceReason, lp_cChangeReason
		
		lp_cChangeReason = ""
		
		RETURN lp_cChangeReason
	ENDPROC

	PROCEDURE fobillsresercheck
		LPARAMETERS lp_nReserId, lp_aWindows, lp_cAction, lp_lValid, lp_lSilent, lp_cForceReason, lp_lDontReopen
		EXTERNAL ARRAY lp_aWindows
		LOCAL i, l_cWindows, l_cBillnum, l_cStatus
		
		l_cWindows = ""
		FOR i = 1 TO ALEN(lp_aWindows)
		     IF NOT EMPTY(lp_aWindows(i))
		          l_cBillnum = this.FOGetBillData(lp_nReserId, lp_aWindows(i), "bn_billnum")
		          l_cStatus = this.FOGetBillData(lp_nReserId, lp_aWindows(i), "bn_status")
		          IF NOT EMPTY(l_cBillnum) AND NOT this.FOBillActionCheck(lp_cAction, l_cStatus)
		               l_cWindows = l_cWindows + IIF(EMPTY(l_cWindows),"",", ") + TRANSFORM(lp_aWindows(i))
		          ELSE
		               lp_aWindows(i) = 0
		          ENDIF
		     ENDIF
		ENDFOR
		IF EMPTY(l_cWindows)
		     lp_lValid = .T.
		ELSE
		     IF NOT lp_lDontReopen
		          LOCAL l_cChangeReason, l_cNewAction
		*         IF lp_cAction = "UPD_CHKOUT"
		*              l_cNewAction = "CANCEL"
		*              l_cChangeReason = "AUTOMATIC - CHECK OUT"
		*         ELSE
		               l_cNewAction = "OPEN"
		               l_cChangeReason = this.FOBillOpenReason(l_cStatus, l_cWindows, lp_lSilent, lp_lForceReason)
		*         ENDIF
		          IF NOT EMPTY(l_cChangeReason)
		               lp_lValid = .T.
		               FOR i = 1 TO ALEN(lp_aWindows)
		                    IF NOT EMPTY(lp_aWindows(i))
		                         l_cBillnum = this.FOGetBillData(lp_nReserId, lp_aWindows(i), "bn_billnum")
		                         IF NOT EMPTY(l_cBillnum)
		                             this.FOBillNumChange(l_cBillNum, l_cNewAction, l_cChangeReason)
		                         ENDIF
		                    ENDIF
		               ENDFOR
		          ENDIF
		     ENDIF
		ENDIF
		
		RETURN lp_lValid
	ENDPROC

	PROCEDURE fogetbilldata
		LPARAMETERS lp_nReserId, lp_nWindow, lp_cField
		
		RETURN this.DLookUp(this.cBillnum, "bn_reserid = " + SqlCnv(lp_nReserId) + " AND bn_status <> 'CXL' AND bn_window = " + SqlCnv(lp_nWindow), lp_cField)
	ENDPROC

	PROCEDURE fogetfreewindow
		LPARAMETERS lp_nReserid, lp_nWindow, lp_lSearchForHigherWindow, lp_lReturnZeroWhenNoFreeWindow, lp_nWindowPosition
		#DEFINE MAX_BILL_WINDOW		9999
		LOCAL l_nWindow, l_nWinpos, l_lFoundBill, i, l_nSelect, l_lValid, l_lSilent, l_lDontReopen, l_nRsId, l_nMaxBillWindow
		LOCAL ARRAY l_aWin(1)
		
		l_nWindow = EVL(lp_nWindow,1)          && 1 is default
		lp_nWindowPosition = EVL(lp_nWindowPosition,0)
		l_nMaxBillWindow = 9999
		IF NOT EMPTY(lp_nReserid)
		     l_nSelect = SELECT()
		     l_nRsId = this.DLookUp(this.cReservat, "rs_reserid = " + this.SqlCnv(lp_nReserid), "rs_rsid")
		     * First check is free wished window
		     l_aWin(1) = l_nWindow
		     l_lSilent = .T. && Dont show messages
		     l_lForce = .F.
		     l_lDontReopen = .T.
		     IF this.FOBillsReserCheck(lp_nReserid, @l_aWin, "POST_NEW", l_lValid, l_lSilent, l_lForce, l_lDontReopen)
		          l_lFoundBill = .T.
		     ELSE
		          * Wished bill is closed. Try to find first free bill, to post record.
		          FOR i = IIF(lp_lSearchForHigherWindow, l_nWindow, 1) TO MAX_BILL_WINDOW		&& MAX_BILL_WINDOW = 9999
		               IF i <> l_nWindow && We checked this bill already, and he is closed.
		                    l_aWin(1) = i
		                    IF this.FOBillsReserCheck(lp_nReserid, @l_aWin, "POST_NEW", l_lValid, l_lSilent, l_lForce, l_lDontReopen)
		                         * We found window which is not closed.
		                         l_nWindow = i
		                         l_lFoundBill = .T.
		                         EXIT
		                    ENDIF
		               ENDIF
		          ENDFOR
		     ENDIF
		     DO CASE
		          CASE NOT l_lFoundBill
		               l_nWinpos = 0
		          CASE NOT EMPTY(lp_nWindowPosition)
		               l_nWinpos = lp_nWindowPosition
		          CASE BETWEEN(l_nWindow, 1, 6)
		               l_nWinpos = l_nWindow
		          OTHERWISE
		               l_nWinpos = this.FOGetWindowData(l_nRsId, l_nWindow, "pw_winpos")
		               IF EMPTY(l_nWinpos)
		                    l_nWinpos = this.FOGetFreeWindowPos(l_nRsId)
		               ENDIF
		     ENDCASE
		     IF l_nWinpos = 0
		          * All bills are closed.
		          * Reactivate bill 6.
		          IF lp_lReturnZeroWhenNoFreeWindow
		               l_nWindow = 0
		          ELSE
		               l_nWindow = 6
		          ENDIF
		     ELSE
		          this.FOSetWindowData(l_nRsId, l_nWindow, "pw_winpos", l_nWinpos)
		          IF lp_nWindowPosition = 0
		               lp_nWindowPosition = l_nWinpos
		          ENDIF
		     ENDIF
		     SELECT(l_nSelect)
		ENDIF
		
		RETURN l_nWindow
	ENDPROC

	PROCEDURE fogetfreewindowpos
		LPARAMETERS lp_nRsId, lp_nWinpos, lp_nWindow
		LOCAL ARRAY l_aWin(1)
		LOCAL i, l_nWinpos, l_dSysDate
		
		l_nWinpos = 0
		FOR i = 4 TO 6
		     l_aWin(1) = 0
		     IF TYPE("g_AuditActive") = "U" OR NOT g_AuditActive
		          this.FOGetParam("pa_sysdate", @l_dSysDate)
		          SELECT bn_window FROM (this.cBillnum) ;
		               INNER JOIN (this.cPswindow) ON PADL(pw_rsid,10)+PADL(pw_window,10) = PADL(bn_rsid,10)+PADL(bn_window,10) ;
		               WHERE pw_rsid = lp_nRsId AND pw_winpos = i AND bn_status = 'PCO' AND bn_date = l_dSysDate ;
		               INTO ARRAY l_aWin
		     ENDIF
		     IF EMPTY(l_aWin(1))
		          * We didn't find any closed bill on sysdate on selected window position.
		          * So use this window position for bill.
		          l_nWinpos = i
		          EXIT
		     ENDIF
		ENDFOR
		
		RETURN l_nWinpos
	ENDPROC

	PROCEDURE fogetparam
		LPARAMETERS lp_cParamField, lp_uRetVal
		
		RETURN .F.
	ENDPROC

	PROCEDURE fogetwindowdata
		LPARAMETERS lp_nRsId, lp_nWindow, lp_cField, lp_lHistory
		
		RETURN this.DLookUp(this.cPswindow, "pw_rsid = " + this.SqlCnv(lp_nRsId) + " AND pw_window = " + this.SqlCnv(lp_nWindow), lp_cField)
	ENDPROC

	PROCEDURE fonextid
		LPARAMETERS tcCode, tcAlias
		
		RETURN this.NextId(tcCode, tcAlias)
	ENDPROC

	PROCEDURE foreplcode
		LPARAMETERS lp_cInstr
		LOCAL l_nArea, l_nRecno
		
		l_nArea = SELECT()
		SELECT (this.cPicklist)
		l_nRecno = RECNO()
		SCAN FOR pl_label = 'BILLINSTR'
		     IF (','+ALLTRIM(pl_charcod)+',') $ (','+lp_cInstr+',')
		          lp_cInstr = STRTRAN(','+lp_cInstr+',', ','+ALLTRIM(pl_charcod)+',', ALLTRIM(pl_memo))
		     ENDIF
		ENDSCAN
		GOTO l_nRecno
		SELECT (l_nArea)
		
		RETURN
	ENDPROC

	PROCEDURE forestricted
		LPARAMETERS lp_nReserid, lp_oReservat
		LOCAL l_lAllow, l_nArea, l_curReservat, l_dPostDate
		
		IF NOT USED(this.cBillInst)
		     RETURN .T.
		ENDIF
		
		l_nArea = SELECT()
		this.FOGetParam("pa_sysdate", @l_dPostDate)
		IF ISNULL(lp_oReservat) AND this.DLocate(this.cReservat, "rs_reserid = " + this.SqlCnv(lp_nReserid))
		     SELECT (this.cReservat)
		     SCATTER NAME lp_oReservat
		ENDIF
		l_lAllow = ISNULL(lp_oReservat) OR NOT SEEK(STR(lp_oReservat.rs_reserid,12,3)+STR(l_dPostDate - lp_oReservat.rs_arrdate,3),this.cBillInst,"tag2")
		SELECT (l_nArea)
		
		RETURN l_lAllow
	ENDPROC

	PROCEDURE fosetwindowdata
		LPARAMETERS lp_nRsId, lp_nWindow, lp_cField, lp_uValue, lp_cPwAlias
		LOCAL l_nSelect
		
		lp_cPwAlias = EVL(lp_cPwAlias, this.cPswindow)
		IF USED(lp_cPwAlias)
		     l_nSelect = SELECT()
		
		     IF NOT SEEK(PADL(lp_nRsId,10)+PADL(lp_nWindow,10),lp_cPwAlias,"tag4")
		          INSERT INTO &lp_cPwAlias (pw_pwid, pw_rsid, pw_window) VALUES (this.FoNextId("PSWINDOW", lp_cPwAlias), lp_nRsId, lp_nWindow)
		     ENDIF
		     REPLACE &lp_cField WITH lp_uValue IN &lp_cPwAlias
		
		     SELECT (l_nSelect)
		ENDIF
		
		RETURN .T.
	ENDPROC

	PROCEDURE getdayname
		LPARAMETERS tdDate
	ENDPROC

	PROCEDURE getlanguagetext
		LPARAMETERS tcLabel, tcText, tuParam1, tuParam2, tuParam3, tuParam4, tuParam5, tuParam6, tuParam7, tuParam8, tuParam9
		
		RETURN this.StrToMsg(tcText, tuParam1, tuParam2, tuParam3, tuParam4, tuParam5, tuParam6, tuParam7, tuParam8, tuParam9)
	ENDPROC

	PROCEDURE getmaincompanylangcode
	ENDPROC

	PROCEDURE gettime
		LPARAMETERS ttDateTime
		
		RETURN GetTime(ttDateTime)
	ENDPROC

	PROCEDURE getusername
		RETURN ""
	ENDPROC

	PROCEDURE Init
		this.oDatasession = CREATEOBJECT("Collection")
	ENDPROC

	PROCEDURE lastday
		LPARAMETERS tdDate
		
		RETURN LastDay(tdDate)
	ENDPROC

	PROCEDURE nextid
		LPARAMETERS tcCode, tcAlias, tlForceLocal
	ENDPROC

	PROCEDURE oncardpresent
	ENDPROC

	PROCEDURE oncardremove
	ENDPROC

	PROCEDURE pickavailtable
		LPARAMETERS toTableRes
		LOCAL llAccepted
		
		this.PickAvailTableForm(toTableRes)
		DO CASE
			CASE ISNULL(toTableRes.lOK)
				toTableRes.lOK = .F.
				this.Alert(this.GetLanguageText("A|1424|TBLRES","There is not available any table!"))
			CASE toTableRes.lOK
				llAccepted = .T.
			OTHERWISE
		ENDCASE
		
		RETURN llAccepted
	ENDPROC

	PROCEDURE pickavailtableform
		LPARAMETERS toTableRes
	ENDPROC

	PROCEDURE preparedataforreservation
		LPARAMETERS lp_nReserId
	ENDPROC

	PROCEDURE prepareenvironment
		LPARAMETERS tnDataSessionId, tcModule, tcTables
		LOCAL loDatasession, lcKey
		
		IF VARTYPE(tnDataSessionId) # "N"
			tnDataSessionId = SET("Datasession")
		ENDIF
		
		lcKey = TRANSFORM(tnDataSessionId)
		IF 0 = this.oDatasession.GetKey(lcKey)
			* Create new DataSession backup aliases
			loDatasession = CREATEOBJECT("Empty")
			ADDPROPERTY(loDatasession, "nDataSessionId", tnDataSessionId)
			ADDPROPERTY(loDatasession, "aTables[1]")
			this.oDatasession.Add(loDatasession, lcKey)
		ENDIF
		
		RETURN this.oDatasession.Item(lcKey)
	ENDPROC

	PROCEDURE procceedcardforreservat
	ENDPROC

	PROCEDURE restoredatasession
		IF this.nOldDataSessionId > 0
			SET DATASESSION TO this.nOldDataSessionId
			this.nOldDataSessionId = 0
		ENDIF
		
		RETURN .T.
	ENDPROC

	PROCEDURE restoreenvironment
		LPARAMETERS tnDataSessionId, tcModule
		LOCAL loDatasession, lnTableNo, lcPath, lcTable, lnCount
		
		lcKey = TRANSFORM(tnDataSessionId)
		IF 0 < this.oDatasession.GetKey(lcKey)
			loDatasession = this.oDatasession.Item(lcKey)
			IF NOT EMPTY(loDatasession.aTables[1])
				FOR i = 1 TO ALEN(loDatasession.aTables,1)
					IF USED(loDatasession.aTables[i])
						USE IN (loDatasession.aTables[i])
					ENDIF
				NEXT
			ENDIF
			this.oDatasession.Remove(lcKey)
		ENDIF
	ENDPROC

	PROCEDURE sqlcnv
		LPARAMETERS tuExpr, tlForceOdbc
	ENDPROC

	PROCEDURE sqlcursor
		LPARAMETERS tcSql, tcCursor, tlNoFilter, tcSqlDef, toParam, tlRemovesign, taResult, tnDatasessionId
	ENDPROC

	PROCEDURE sqlwhere
		LPARAMETERS tcWhere, tcExpr
	ENDPROC

	PROCEDURE strtomsg
		LPARAMETERS tcString, tuParam1, tuParam2, tuParam3, tuParam4, tuParam5, tuParam6, tuParam7, tuParam8, tuParam9
		LOCAL lnParameters, lnParamNo, lcMessage, lcMode, lcReplacement, lvExp
		
		lnParameters = PCOUNT() - 1
		lcMessage = STRTRAN(tcString, ";", CHR(13)+CHR(10))
		FOR lnParamNo = 1 TO lnParameters
			lvExp = EVALUATE("tuParam" + ALLTRIM(STR(lnParamNo)))
			DO CASE
				CASE INLIST(VARTYPE(lvExp), "N", "I")
					lcMode = "%n"
					lcReplacement = ALLTRIM(PADR(lvExp, 20))
				CASE VARTYPE(lvExp) = "D"
					lcMode = "%d"
					lvExp = MAX(lvExp, DATE(1601,1,1))
					lcReplacement = DTOC(lvExp)
				CASE VARTYPE(lvExp) = "T"
					lcMode = "%t"
					lvExp = MAX(lvExp, DATETIME(1601,1,1))
					lcReplacement = TTOC(lvExp)
				CASE INLIST(VARTYPE(lvExp), "C", "M")
					lcMode = "%s"
					lcReplacement = lvExp
				OTHERWISE
					LOOP
			ENDCASE
			lcMode = lcMode + ALLTRIM(STR(lnParamNo))
			lcMessage = STRTRAN(lcMessage, lcMode, lcReplacement)
			lcMessage = STRTRAN(lcMessage, UPPER(lcMode), lcReplacement)
		NEXT
		
		RETURN lcMessage
	ENDPROC

	PROCEDURE tbclose
		LPARAMETERS tcCursorName, tnDataSessionId
	ENDPROC

	PROCEDURE tblock
		LPARAMETERS tcAlias, tnReprocess
	ENDPROC

	PROCEDURE tbopen
		LPARAMETERS tcTable, tcAlias, tnDataSessionId
	ENDPROC

	PROCEDURE tbunlock
		LPARAMETERS tcAlias, tnRecno
	ENDPROC

	PROCEDURE uniquevouchernumber
		LPARAMETERS tdSysDate
		LOCAL lnDaysFromNewYear, lnSecondsFromMidnight
		
		lnDaysFromNewYear = tdSysDate - DATE(YEAR(tdSysDate),1,1) + 1
		lnSecondsFromMidnight = INT(SECONDS()*100)
		
		RETURN lnDaysFromNewYear*10000000 + lnSecondsFromMidnight	&& Format: DDDSSSSSSS
	ENDPROC

	PROCEDURE winpc
	ENDPROC

	PROCEDURE yesno
		LPARAMETERS tcText, tcHeader, tcString
	ENDPROC

	PROCEDURE yesnocancel
		LPARAMETERS tcText, tcHeader
	ENDPROC

ENDDEFINE
