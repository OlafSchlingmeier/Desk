*--------------------------------------------------------------------------------------------------------------------------------------------------------
* (ES) AUTOGENERADO - ¡¡ATENCIÓN!! - ¡¡NO PENSADO PARA EJECUTAR!! USAR SOLAMENTE PARA INTEGRAR CAMBIOS Y ALMACENAR CON HERRAMIENTAS SCM!!
* (EN) AUTOGENERATED - ATTENTION!! - NOT INTENDED FOR EXECUTION!! USE ONLY FOR MERGING CHANGES AND STORING WITH SCM TOOLS!!
*--------------------------------------------------------------------------------------------------------------------------------------------------------
*< FOXBIN2PRG: Version="1.19" SourceFile="proc_yield.vcx" /> (Solo para binarios VFP 9 / Only for VFP 9 binaries)
*
*
DEFINE CLASS citwebrates AS procyield OF "proc_yield.vcx" 
 	*< CLASSDATA: Baseclass="custom" Timestamp="" Scale="Pixels" Uniqueid="" />

	*<DefinedPropArrayMethod>
		*m: ondelete
		*m: ongetprices
		*m: oninit
		*m: onsave
		*m: onvalid
		*p: ccwrates
		*p: ccwvrrt
		*p: cpathcitweb
		*p: cvirtrconn
		*p: cvirtrooms
		*p: dfrom
		*p: dmaxdate
		*p: dmindate
		*p: dto
		*p: lcwrates
		*p: ninitmode
		*p: ocwvrrt
		*p: ocwvrrtold
	*</DefinedPropArrayMethod>

	ccwrates = .NULL.
	ccwvrrt = .NULL.
	cpathcitweb = 
	cpathdesk = 
	cvirtrconn = 
	cvirtrooms = 
	dfrom = {}
	dmaxdate = {}
	dmindate = {}
	dto = {}
	Name = "citwebrates"
	ocwvrrt = .NULL.
	ocwvrrtold = .NULL.
	
	PROCEDURE closealiases
		=TABLEREVERT(.F.,this.cCwvrrt)
		=TABLEREVERT(.T.,this.cCwrates)
		=CURSORSETPROP("Buffering", 1, this.cCwvrrt)
		=CURSORSETPROP("Buffering", 1, this.cCwrates)
		
		this.DClose("curNewPrices")
		
		DODEFAULT()
		
		RETURN .T.
	ENDPROC

	PROCEDURE closetables
		DODEFAULT()
		
		this.DClose(this.cCwvrrt)
		this.DClose(this.cCwrates)
		this.DClose(this.cvirtrooms)
		this.DClose(this.cvirtrconn)
		
		RETURN .T.
	ENDPROC

	PROCEDURE displayroomtypes
		LPARAMETERS tcRoomType
		#DEFINE CTW_PRICES				2
		LOCAL i, lcRoomType, lcRoomTypes, lnSelect
		
		IF this.lCwRates AND BITTEST(curResultRC.c_status,CTW_PRICES)
			lcRoomTypes = "CitWeb-"
			IF USED("curcwrt10")
				lnSelect = SELECT()
				SELECT curcwrt10
				SCAN FOR vc_vroom = PADR(ALLTRIM(tcRoomType),3)
					lcRoomTypes = lcRoomTypes + get_rt_roomtyp(curcwrt10.vc_room) + ","
				ENDSCAN
				IF RIGHT(lcRoomTypes,1)=","
					lcRoomTypes = SUBSTR(lcRoomTypes, 1, LEN(lcRoomTypes)-1)
				ENDIF
				SELECT (lnSelect)
			ELSE
				lcRoomTypes = lcRoomTypes + tcRoomType
			ENDIF
		ELSE
			lcRoomTypes = DODEFAULT(tcRoomType)
		ENDIF
		
		RETURN lcRoomTypes
	ENDPROC

	PROCEDURE getrates
		LPARAMETERS toParams
		
		DODEFAULT(toParams)
		
		IF this.lCwRates
			#DEFINE CTW_PRICES				2
			LOCAL lcSql, lcRateFld, lnCounter, ldFrom, ldTo, loRatecode
		
			lcRateFld = ""
			IF NOT EMPTY(this.oParams.nAdults)
				lcRateFld = lcRateFld + IIF(EMPTY(lcRateFld), "", "+") + "curCwData.ew_rate" + IIF(this.oParams.nAdults = 1, "", TRANSFORM(this.oParams.nAdults))
			ENDIF
			IF NOT EMPTY(this.oParams.nChild1)
				lcRateFld = lcRateFld + IIF(EMPTY(lcRateFld), "", "+") + "curCwData.ew_crate" + TRANSFORM(this.oParams.nChild1)
			ENDIF
			IF NOT EMPTY(this.oParams.nChild2)
				lcRateFld = lcRateFld + IIF(EMPTY(lcRateFld), "", "+") + "curCwData.ew_crate" + TRANSFORM(this.oParams.nChild2)
			ENDIF
			IF NOT EMPTY(this.oParams.nChild3)
				lcRateFld = lcRateFld + IIF(EMPTY(lcRateFld), "", "+") + "curCwData.ew_crate" + TRANSFORM(this.oParams.nChild3)
			ENDIF
			REPLACE c_rcrecid WITH curResultRC.c_recordid ALL IN curResultRC
		
			lnCounter = 0
			CALCULATE MAX(c_recordid), MIN(ca_date), MAX(ca_date) TO lnCounter, ldFrom, ldTo IN curRoomAvail
		
			TEXT TO lcSql TEXTMERGE NOSHOW PRETEXT 2 + 8
				SELECT * FROM <<this.ccwvrrt>> 
					INNER JOIN <<this.ccwrates>> ON ew_vroom = eq_vroom 
					WHERE BETWEEN(ew_date, <<SqlCnv(ldFrom,.T.)>>, <<SqlCnv(ldTo,.T.)>>)
					ORDER BY eq_ratecod, eq_vroom, ew_date
			ENDTEXT
			&lcSql INTO CURSOR curCwData READWRITE
			INDEX ON ew_vroom TAG ew_vroom
		
			SELECT DISTINCT eq_ratecod, eq_vroom, c_recordid FROM curCwData ;
				INNER JOIN curResultRC ON rc_ratecod = eq_ratecod ;
				ORDER BY c_recordid, eq_ratecod, eq_vroom ;
				INTO CURSOR tmpCwRatecodes
			SCAN FOR this.DLocate("curResultRC", "rc_ratecod = tmpCwRatecodes.eq_ratecod AND c_recordid = tmpCwRatecodes.c_recordid")
				lnCounter = lnCounter + 1
				SELECT curResultRC
				SCATTER NAME loRatecode
				loRatecode.c_recordid = lnCounter
				loRatecode.c_status = BITSET(loRatecode.c_status,CTW_PRICES)
				INSERT INTO curResultRC FROM NAME loRatecode
				SELECT * FROM curRoomAvail WHERE c_recordid = loRatecode.c_rcrecid INTO CURSOR tmpRoomAvail READWRITE
				REPLACE c_recordid WITH loRatecode.c_recordid, ;
					ca_roomtyp WITH tmpCwRatecodes.eq_vroom ALL IN tmpRoomAvail
				SELECT curCwData
				SCAN FOR ew_vroom = tmpCwRatecodes.eq_vroom
					REPLACE ca_rate WITH &lcRateFld FOR ca_date = curCwData.ew_date IN tmpRoomAvail
				ENDSCAN
				SELECT curRoomAvail
				APPEND FROM DBF("tmpRoomAvail")
			ENDSCAN
		
			this.DClose("curCwData")
			this.DClose("tmpCwRatecodes")
			this.DClose("tmpRoomAvail")
		
			SELECT curResultRC
			SET ORDER TO c_rcrecid
		ENDIF
	ENDPROC

	PROCEDURE Init
		DODEFAULT()
		
		this.ccwvrrt = SYS(2015)
		this.ccwrates = SYS(2015)
		this.cvirtrooms = SYS(2015)
		this.cvirtrconn = SYS(2015)
	ENDPROC

	PROCEDURE ondelete
		IF NOT EMPTY(this.dFrom) AND NOT EMPTY(this.dTo)
			DELETE FOR ew_vroom = this.oCwvrrt.eq_vroom AND BETWEEN(ew_date, this.dFrom, this.dTo) IN (this.cCwRates)
			DELETE FOR BETWEEN(ew_date, this.dFrom, this.dTo) IN curNewPrices
		ENDIF
		
		RETURN .T.
	ENDPROC

	PROCEDURE ongetprices
		LPARAMETERS tcRoomType, tnPersons, tnPriceType
		* tnPriceType = 1	- Minimal price
		* tnPriceType = 2	- Maximal price
		* tnPriceType = 3	- Custom price
		LOCAL ldFrom, ldTo, loParams, lcurPrices, lcField
		
		ldFrom = MAX(this.dFrom, this.dSysDate)
		ldTo = MAX(this.dTo, this.dSysDate)
		
		loParams = MakeStructure("oReservat, dFrom, dTo, nMinStay, cRoomtype, nAltId, cRateCode, nAdults, nChild1, nChild2, nChild3, nPriceSetting, lDontCheckClosArr")
		loParams.oReservat = .NULL.
		loParams.dFrom = ldFrom
		loParams.dTo = ldTo + 1
		loParams.nMinStay = 0
		loParams.cRoomtype = PADR(tcRoomType, INT(LEN(tcRoomType)/5)*5+4)
		loParams.nAltId = 0
		loParams.cRateCode = this.oCwvrrt.eq_ratecod
		loParams.nChild1 = 0
		loParams.nChild2 = 0
		loParams.nChild3 = 0
		IF tnPersons < 0
			loParams.nAdults = 0
			DO CASE
				CASE tnPersons = -1
					loParams.nChild1 = 1
				CASE tnPersons = -2
					loParams.nChild2 = 1
				CASE tnPersons = -3
					loParams.nChild3 = 1
			ENDCASE
		ELSE
			loParams.nAdults = EVL(tnPersons,1)
		ENDIF
		loParams.nPriceSetting = 0
		loParams.lDontCheckClosArr = .T.
		this.GetRates(loParams)	&& Result in curResultRC, curRoomAvail
		
		lcurPrices = SYS(2015)
		SELECT ca_date, MIN(ca_rate) AS c_ratemin, MAX(ca_rate) AS c_ratemax FROM curRoomAvail GROUP BY 1 INTO CURSOR &lcurPrices
		
		DELETE FOR NOT BETWEEN(ew_date, ldFrom, ldTo) IN curNewPrices
		
		IF tnPersons < 0
			lcField = "c_crate" + TRANSFORM(ABS(tnPersons))
		ELSE
			lcField = "c_rate" + IIF(tnPersons = 1, "", TRANSFORM(tnPersons))
		ENDIF
		SELECT &lcurPrices
		SCAN
			IF NOT SEEK(ca_date, "curNewPrices", "ew_date")
				INSERT INTO curNewPrices (ew_date, ew_rate, ew_rate2, ew_rate3, ew_rate4, ew_rate5, ew_minstay, ew_maxstay, c_rate, c_rate2, c_rate3, c_rate4, c_rate5, c_minstay, c_maxstay, ;
					ew_crate1, c_crate1, ew_crate2, c_crate2, ew_crate3, c_crate3 ;
					) ;
					VALUES (&lcurPrices..ca_date, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0)
			ENDIF
			REPLACE &lcField WITH IIF(tnPriceType = 1, &lcurPrices..c_ratemin, &lcurPrices..c_ratemax) IN curNewPrices
		ENDSCAN
		
		this.DClose(lcurPrices)
		
		RETURN .T.
	ENDPROC

	PROCEDURE oninit
		LPARAMETERS tnMode, tcVirtRoomtype
		LOCAL lnArea
		
		lnArea = SELECT()
		
		this.nInitMode = tnMode
		
		ZAP IN curNewPrices
		
		SELECT (this.ccwvrrt)
		IF this.nInitMode = 1	&& EDIT_MODE
			LOCATE FOR eq_vroom = tcVirtRoomtype
			SCATTER MEMO NAME this.oCwvrrtOld
			SCATTER MEMO NAME this.oCwvrrt
			INSERT INTO curNewPrices (ew_date, ew_rate, ew_rate2, ew_rate3, ew_rate4, ew_rate5, ew_minstay, ew_maxstay, ew_mealcod, ew_closed, c_rate, c_rate2, c_rate3, c_rate4, c_rate5, c_minstay, c_maxstay, c_closed, ;
				ew_crate1, ew_crate2, ew_crate3 ;
				) ;
				SELECT ew_date, ew_rate, ew_rate2, ew_rate3, ew_rate4, ew_rate5, ew_minstay, ew_maxstay, ew_mealcod, ew_closed, 0, 0, 0, 0, 0, 0, 0, 0, ;
					ew_crate1, ew_crate2, ew_crate3 ;
					FROM (this.ccwrates) WHERE ew_vroom = tcVirtRoomtype ORDER BY ew_date
		ELSE
			SCATTER MEMO BLANK NAME this.oCwvrrtOld
			SCATTER MEMO BLANK NAME this.oCwvrrt
			this.oCwvrrt.eq_adults = 1
		ENDIF
		
		CALCULATE MIN(av_date), MAX(av_date) TO this.dMinDate, this.dMaxDate IN (this.cavailab)
		CALCULATE MIN(ew_date), MAX(ew_date) TO this.dFrom, this.dTo IN curNewPrices
		IF EMPTY(this.dFrom)
			this.dMinDate = this.dSysdate
			this.dFrom = this.dSysdate
			this.dTo = this.dMaxDate
		ELSE
			this.dMinDate = this.dFrom
			this.dFrom = MAX(this.dFrom, this.dSysdate)
			this.dTo = MAX(this.dTo, this.dSysdate)
		ENDIF
		
		IF this.nInitMode = 1	&& EDIT_MODE
			IF NOT this.DLocate("curNewPrices", "ew_date = " + SqlCnv(this.dSysdate))
				this.DLocate("curNewPrices")
			ENDIF
		ENDIF
		
		SELECT (lnArea)
		
		RETURN .T.
	ENDPROC

	PROCEDURE onsave
		LOCAL loCwRates, lcurCwRates
		LOCAL ARRAY laDates(1)
		
		this.oCwvrrt.eq_updated = DATETIME()
		lcurCwRates = this.cCwrates
		
		SELECT (this.cCwvrrt)
		IF this.nInitMode = 2	&& NEW_MODE
			APPEND BLANK
		ENDIF
		GATHER NAME this.oCwvrrt MEMO
		
		SELECT MIN(ew_date), MAX(ew_date) FROM curNewPrices INTO ARRAY laDates
		IF ALEN(laDates) > 1	&& Delete dates lower then sysdate!
			DELETE FOR ew_vroom = this.oCwvrrt.eq_vroom AND ew_date < this.dSysDate AND NOT BETWEEN(ew_date, laDates(1), laDates(2)) IN &lcurCwRates
		ELSE
			DELETE FOR ew_vroom = this.oCwvrrt.eq_vroom AND ew_date < this.dSysDate IN &lcurCwRates
		ENDIF
		DO CASE
			CASE this.oCwvrrt.eq_adults = 1
				BLANK FIELDS ew_rate2, ew_rate3, ew_rate4, ew_rate5 FOR ew_vroom = this.oCwvrrt.eq_vroom IN &lcurCwRates
				BLANK FIELDS  c_rate2,  c_rate3,  c_rate4,  c_rate5 ALL IN curNewPrices
			CASE this.oCwvrrt.eq_adults = 2
				BLANK FIELDS ew_rate3, ew_rate4, ew_rate5 FOR ew_vroom = this.oCwvrrt.eq_vroom IN &lcurCwRates
				BLANK FIELDS  c_rate3,  c_rate4,  c_rate5 ALL IN curNewPrices
			CASE this.oCwvrrt.eq_adults = 3
				BLANK FIELDS ew_rate4, ew_rate5 FOR ew_vroom = this.oCwvrrt.eq_vroom IN &lcurCwRates
				BLANK FIELDS  c_rate4,  c_rate5 ALL IN curNewPrices
			CASE this.oCwvrrt.eq_adults = 4
				BLANK FIELDS ew_rate5 FOR ew_vroom = this.oCwvrrt.eq_vroom IN &lcurCwRates
				BLANK FIELDS  c_rate5 ALL IN curNewPrices
			OTHERWISE
		ENDCASE
		
		SELECT curNewPrices
		SCAN FOR ew_date >= this.dSysDate AND NOT (EMPTY(c_rate) AND EMPTY(c_rate2) AND EMPTY(c_rate3) AND EMPTY(c_rate4) AND ;
				EMPTY(c_rate5) AND EMPTY(c_minstay) AND EMPTY(c_maxstay) AND EMPTY(c_mealcod) AND EMPTY(c_closed) AND ;
				EMPTY(c_crate1) AND EMPTY(c_crate2) AND EMPTY(c_crate3))
			IF this.DLocate(lcurCwRates, "ew_vroom = " + SqlCnv(this.oCwvrrt.eq_vroom) + " AND ew_date = " + SqlCnv(ew_date))
				IF NOT EMPTY(c_rate) AND &lcurCwRates..ew_rate <> c_rate
					REPLACE ew_rate WITH IIF(curNewPrices.c_rate = -1, 0, curNewPrices.c_rate) IN &lcurCwRates
				ENDIF
				IF IIF(this.oCwvrrt.eq_adults < 2, NOT EMPTY(&lcurCwRates..ew_rate2), NOT EMPTY(c_rate2) AND &lcurCwRates..ew_rate2 <> c_rate2)
					REPLACE ew_rate2 WITH IIF(this.oCwvrrt.eq_adults < 2 OR curNewPrices.c_rate2 = -1, 0.00, curNewPrices.c_rate2) IN &lcurCwRates
				ENDIF
				IF IIF(this.oCwvrrt.eq_adults < 3, NOT EMPTY(&lcurCwRates..ew_rate3), NOT EMPTY(c_rate3) AND &lcurCwRates..ew_rate3 <> c_rate3)
					REPLACE ew_rate3 WITH IIF(this.oCwvrrt.eq_adults < 3 OR curNewPrices.c_rate3 = -1, 0.00, curNewPrices.c_rate3) IN &lcurCwRates
				ENDIF
				IF IIF(this.oCwvrrt.eq_adults < 4, NOT EMPTY(&lcurCwRates..ew_rate4), NOT EMPTY(c_rate4) AND &lcurCwRates..ew_rate4 <> c_rate4)
					REPLACE ew_rate4 WITH IIF(this.oCwvrrt.eq_adults < 4 OR curNewPrices.c_rate4 = -1, 0.00, curNewPrices.c_rate4) IN &lcurCwRates
				ENDIF
				IF IIF(this.oCwvrrt.eq_adults < 5, NOT EMPTY(&lcurCwRates..ew_rate5), NOT EMPTY(c_rate5) AND &lcurCwRates..ew_rate5 <> c_rate5)
					REPLACE ew_rate5 WITH IIF(this.oCwvrrt.eq_adults < 5 OR curNewPrices.c_rate5 = -1, 0.00, curNewPrices.c_rate5) IN &lcurCwRates
				ENDIF
				IF NOT EMPTY(c_minstay) AND &lcurCwRates..ew_minstay <> IIF(c_minstay = -1, 1, c_minstay)
					REPLACE ew_minstay WITH IIF(curNewPrices.c_minstay = -1, 1, curNewPrices.c_minstay) IN &lcurCwRates
				ENDIF
				IF NOT EMPTY(c_maxstay) AND &lcurCwRates..ew_maxstay <> IIF(c_maxstay = -1, 999, c_maxstay)
					REPLACE ew_maxstay WITH IIF(curNewPrices.c_maxstay = -1, 999, curNewPrices.c_maxstay) IN &lcurCwRates
				ENDIF
				IF NOT EMPTY(c_mealcod) AND &lcurCwRates..ew_mealcod <> c_mealcod
					REPLACE ew_mealcod WITH curNewPrices.c_mealcod IN &lcurCwRates
				ENDIF
				IF NOT EMPTY(c_closed) AND &lcurCwRates..ew_closed <> c_closed
					REPLACE ew_closed WITH curNewPrices.c_closed IN &lcurCwRates
				ENDIF
				IF NOT EMPTY(c_crate1) AND &lcurCwRates..ew_crate1 <> c_crate1
					REPLACE ew_crate1 WITH IIF(curNewPrices.c_crate1 = -1, 0, curNewPrices.c_crate1) IN &lcurCwRates
				ENDIF
				IF NOT EMPTY(c_crate2) AND &lcurCwRates..ew_crate2 <> c_crate2
					REPLACE ew_crate2 WITH IIF(curNewPrices.c_crate2 = -1, 0, curNewPrices.c_crate2) IN &lcurCwRates
				ENDIF
				IF NOT EMPTY(c_crate3) AND &lcurCwRates..ew_crate3 <> c_crate3
					REPLACE ew_crate3 WITH IIF(curNewPrices.c_crate3 = -1, 0, curNewPrices.c_crate3)  IN &lcurCwRates
				ENDIF
			ELSE
				SELECT &lcurCwRates
				SCATTER NAME loCwRates MEMO
				SELECT curNewPrices
				loCwRates.ew_vroom = this.oCwvrrt.eq_vroom
				loCwRates.ew_date = ew_date
				loCwRates.ew_rate = c_rate
				loCwRates.ew_rate2 = c_rate2
				loCwRates.ew_rate3 = c_rate3
				loCwRates.ew_rate4 = c_rate4
				loCwRates.ew_rate5 = c_rate5
				loCwRates.ew_minstay = c_minstay
				loCwRates.ew_maxstay = c_maxstay
				loCwRates.ew_mealcod = c_mealcod
				loCwRates.ew_closed = c_closed
				loCwRates.ew_crate1 = c_crate1
				loCwRates.ew_crate2 = c_crate2
				loCwRates.ew_crate3 = c_crate3
				INSERT INTO &lcurCwRates FROM NAME loCwRates
			ENDIF
		ENDSCAN
		
		DbTableUpdate(this.cCwrates, "ew_vroom = " + SqlCnv(this.oCwvrrt.eq_vroom))
		DoTableUpdate(.F., .T., this.cCwvrrt)
		EndTransaction()
		
		RETURN 0
	ENDPROC

	PROCEDURE onvalid
		LOCAL lnErrorCode, lnRecno, llDuplicateFound
		
		lnRecno = RECNO(this.ccwvrrt)
		
		this.cMessage = ""
		lnErrorCode = 0
		
		IF EMPTY(this.oCwvrrt.eq_vroom)
			this.cMessage = GetLangText("MNGCWR","TXT_EMPTY_CW_RT")
			lnErrorCode = 1
		ENDIF
		
		IF lnErrorCode = 0 AND this.nInitMode <> 1&& New mode
			IF EMPTY(this.oCwvrrt.eq_chvroom)
				IF this.DLocate(this.ccwvrrt, "eq_vroom = " + SqlCnv(this.oCwvrrt.eq_vroom,.T.))
					llDuplicateFound  = .T.
				ENDIF
			ELSE
				IF this.DLocate(this.ccwvrrt, ;
						"eq_chvroom = " + SqlCnv(this.oCwvrrt.eq_chvroom,.T.) + " AND eq_channel = " + SqlCnv(this.oCwvrrt.eq_channel,.T.) + ;
						" AND eq_rateid = " + SqlCnv(PADR(this.oCwvrrt.eq_rateid,16),.T.))
					llDuplicateFound  = .T.
				ENDIF
			ENDIF
			IF llDuplicateFound
				this.cMessage = GetLangText("MNGCWR","TXT_DUPLICATE_CW_RT")
				lnErrorCode = 2
			ENDIF
		ENDIF
		
		IF lnErrorCode = 0 AND this.nInitMode = 1 && Edit
			* Check when user has activated previously inactive rate if there already are active rates for same virtual room type
			IF EMPTY(this.oCwvrrt.eq_chvroom)
				* When Citweb virtual roomtype is stored in eq_vroom, then is not possible to change eq_vroom, and not validation is needed.
				* But we check it any way.
				IF this.oCwvrrtOld.eq_vroom <> this.oCwvrrt.eq_vroom
					this.cMessage = GetLangText("COMMON","TXT_PK_CHANGE_NOT_ALLOWED")
					lnErrorCode = 2
				ENDIF
			ELSE
				IF this.DLocate(this.ccwvrrt, ;
						"eq_vroom <> " + SqlCnv(this.oCwvrrt.eq_vroom,.T.) + " AND NOT EMPTY(eq_chvroom) AND eq_chvroom = " + SqlCnv(this.oCwvrrt.eq_chvroom,.T.) + " AND eq_channel = " + SqlCnv(this.oCwvrrt.eq_channel,.T.) + ;
						" AND eq_rateid = " + SqlCnv(PADR(this.oCwvrrt.eq_rateid,16),.T.))
					llDuplicateFound  = .T.
				ENDIF
			ENDIF
			IF llDuplicateFound
				this.cMessage = GetLangText("MNGCWR","TXT_DUPLICATE_CW_RT")
				lnErrorCode = 2
			ENDIF
		ENDIF
		
		GO lnRecno IN (this.ccwvrrt)
		
		RETURN lnErrorCode
	ENDPROC

	PROCEDURE openaliases
		LPARAMETERS tlDontUseDisplayRoomTypes
		
		IF tlDontUseDisplayRoomTypes
			this.ldisplayroomtypes = .F.
		ENDIF
		
		DODEFAULT()
		
		SetTransactable(this.cCwvrrt)
		SetTransactable(this.cCwrates)
		=CURSORSETPROP("Buffering", 5, this.cCwvrrt)
		=CURSORSETPROP("Buffering", 5, this.cCwrates)
		
		RETURN .T.
	ENDPROC

	PROCEDURE opentables
		DODEFAULT()
		
		this.DOpen("cwvrrt", this.cCwvrrt, this.cPathDesk)
		this.DOpen("cwrates", this.cCwrates, this.cPathDesk)
		this.DOpen("virtrooms", this.cvirtrooms, this.cPathCitweb)
		this.DOpen("virtrconn", this.cvirtrconn, this.cPathCitweb)
		
		RETURN .T.
	ENDPROC

	PROCEDURE preparecursors
		DODEFAULT()
		
		SELECT ew_date, ;
				ew_rate, ew_rate AS c_rate, ;
				ew_rate2, ew_rate2 AS c_rate2, ;
				ew_rate3, ew_rate3 AS c_rate3, ;
				ew_rate4, ew_rate4 AS c_rate4, ;
				ew_rate5, ew_rate5 AS c_rate5, ;
				ew_minstay, ew_minstay AS c_minstay, ;
				ew_maxstay, ew_maxstay AS c_maxstay, ;
				ew_mealcod, ew_mealcod AS c_mealcod, ;
				ew_closed, ew_closed AS c_closed, ;
				ew_crate1, ew_crate1 AS c_crate1, ;
				ew_crate2, ew_crate2 AS c_crate2, ;
				ew_crate3, ew_crate3 AS c_crate3 ;
			FROM (this.ccwrates) WHERE 0=1 INTO CURSOR curNewPrices READWRITE
		INDEX ON ew_date TAG ew_date
		
		RETURN .T.
	ENDPROC

ENDDEFINE

DEFINE CLASS procyield AS custom 
 	*< CLASSDATA: Baseclass="custom" Timestamp="" Scale="Pixels" Uniqueid="" />

	*<DefinedPropArrayMethod>
		*m: calcrate
		*m: calcrateforperiod
		*m: calcsplits
		*m: checkweekdaysarray
		*m: closealiases
		*m: closetables		&& Causes the tables and views associated with the data environment to close.
		*m: dclose
		*m: displayroomtypes
		*m: dlocate
		*m: dopen
		*m: getmessage
		*m: getnotes
		*m: getoccupancyforperiod
		*m: getrates
		*m: getratesforperiod
		*m: getrcroomtypes
		*m: openaliases
		*m: opentables		&& Programmatically opens the tables and views associated with the data environment.
		*m: preparecursors
		*m: ratecalculate
		*m: ratecodelocate
		*m: setenvironment
		*p: calthead
		*p: caltsplit
		*p: carticle
		*p: cavailab
		*p: clangnum
		*p: cmessage
		*p: cparam
		*p: cparam2
		*p: cpathdesk
		*p: cpaymetho
		*p: cratearti
		*p: crateartiresultcursor
		*p: cratecode
		*p: cratecodefilter
		*p: crateprop
		*p: crcyield
		*p: croomtype
		*p: croomtypefilter
		*p: cseason
		*p: cyieldmng
		*p: cymngprop
		*p: dsysdate
		*p: lcheckratepropblock
		*p: ldisplayroomtypes
		*p: ldontcheckclosarr		&& Don't check is ratecode valid for arrival date. Used for creating citweb prices
		*p: lfiltermaxpersons		&& When .T., include only roomtypes which have rt_maxpers >= nAdults
		*p: lgetsplits
		*p: lopentables
		*p: lsetenvironment
		*p: lshowminmaxblocked
		*p: lwithoutaps
		*p: oparams
	*</DefinedPropArrayMethod>

	calthead = 
	caltsplit = 
	carticle = 
	cavailab = 
	clangnum = ('3')
	cmessage = 
	cparam = 
	cparam2 = 
	cpathdesk = 
	cpaymetho = 
	cratearti = 
	crateartiresultcursor = 
	cratecode = 
	cratecodefilter = 
	crateprop = 
	crcyield = 
	croomtype = 
	croomtypefilter = 
	cseason = 
	cyieldmng = 
	cymngprop = 
	dsysdate = {}
	lcheckratepropblock = .F.
	ldisplayroomtypes = .T.
	ldontcheckclosarr = .F.		&& Don't check is ratecode valid for arrival date. Used for creating citweb prices
	lfiltermaxpersons = .F.		&& When .T., include only roomtypes which have rt_maxpers >= nAdults
	lopentables = .T.
	Name = "procyield"
	oparams = .NULL.
	
	PROCEDURE calcrate
		LPARAMETERS toRoomAvail, toResultRC
		#DEFINE CRLF			CHR(13)+CHR(10)
		#DEFINE APS_BLOCKED		0
		LOCAL ldDate, ldFromDate, lcSelectedRT, llFound, lcWhere, lnRate, lnMinRate, lnAllOccPct, lnOccPct, lnRtavl, lnRtdef, lnPricePct
		
		ldDate = toRoomAvail.ca_date
		ldFromDate = EVL(this.oParams.dFrom, this.dSysDate)
		lcSelectedRT = EVL(this.oParams.cRoomtype,"*   ")
		toRoomAvail.ca_roomtyp = this.GetRcRoomtypes(toResultRC.rc_ratecod, ldDate)
		
		IF this.Ratecodelocate(toResultRC.c_recordid, ldDate, lcSelectedRT)
			llFound = .T.
			lnRate = this.RateCalculate(ldDate, IIF(EMPTY(this.oParams.nAltId),"","!") + curRatecode.rc_ratecod, lcSelectedRT, this.oParams.nAltId, 0, this.oParams.nAdults, this.oParams.nChild1, this.oParams.nChild2, this.oParams.nChild3, ldFromDate,,,,"curRatecode")
		ELSE
			lnRate = 0.00
			IF NOT this.lFilterMaxPersons
				toRoomAvail.ca_note = GetLangText("RATEPOST","TA_RCNOTFOUND") + ": " + ALLTRIM(toResultRC.rc_ratecod) + ", " + this.DisplayRoomTypes(toRoomAvail.ca_roomtyp) + ", " + TRANSFORM(ldDate) + ", " + ALLTRIM(curRatecode.rc_season)
				IF EMPTY(toResultRC.rc_info)
					toResultRC.rc_info = toRoomAvail.ca_note
				ENDIF
			ENDIF
			toResultRC.c_status = BITSET(toResultRC.c_status,APS_BLOCKED)
		ENDIF
		toRoomAvail.ca_ratecod = curRatecode.rc_key
		toRoomAvail.ca_defrate = lnRate
		
		IF llFound
			IF NOT toResultRC.c_done
				toResultRC.c_done = .T.
				toResultRC.rc_lang = curRatecode.rc_lang
				toResultRC.rc_period = curRatecode.rc_period
				toResultRC.rc_minstay = curRatecode.rc_minstay
				toResultRC.rc_maxstay = curRatecode.rc_maxstay
				toResultRC.rc_citmoss = curRatecode.rc_citmoss
				toResultRC.rc_citmobd = curRatecode.rc_citmobd
			ENDIF
			IF INLIST(toRoomAvail.ca_roomtyp, PADR("*",230), PADR(lcSelectedRT,230))
				lnRtavl = toRoomAvail.ca_rtrms
				lnRtdef = toRoomAvail.ca_rtdef
			ELSE
				CALCULATE SUM(av_avail), SUM(av_definit) FOR av_date = ldDate AND (ALLTRIM(toRoomAvail.ca_roomtyp)="*" OR ","+ALLTRIM(av_roomtyp)+"," $ ","+ALLTRIM(toRoomAvail.ca_roomtyp)+",") TO lnRtavl, lnRtdef IN curAvailab
			ENDIF
			lnOccPct = ROUND(IIF(lnRtavl = 0, 0, 100*lnRtdef/lnRtavl),2)
			lnAllOccPct = ROUND(IIF(toRoomAvail.ca_allrms = 0, 0, 100*toRoomAvail.ca_alldef/toRoomAvail.ca_allrms),2)
			toRoomAvail.ca_occpct = lnOccPct
		
			lcWhere = "INLIST(yr_ratecod,'*',%s1) AND (ym_daytype = 0 AND %n2 <= ym_days OR ym_daytype = 1 AND %n3 >= ym_days) AND " + ;
					"(ym_avltype = 0 AND IIF(ym_avlhot,%n4,%n5) <= ym_avail OR ym_avltype = 1 AND IIF(ym_avlhot,%n6,%n7) >= ym_avail)"
			lcWhere = StrToSql(lcWhere, toRoomAvail.ca_ratecod, ldDate-this.dSysDate+1, ldDate-this.dSysDate+1, lnAllOccPct, lnOccPct, lnAllOccPct, lnOccPct)
		
			IF this.DLocate("curRcYieldCond", lcWhere)
				DO CASE
					CASE this.oParams.nAdults > 2 AND NOT EMPTY(curRcYieldCond.ym_prcpct3)
						lnPricePct = curRcYieldCond.ym_prcpct3
					CASE this.oParams.nAdults > 1 AND NOT EMPTY(curRcYieldCond.ym_prcpct2)
						lnPricePct = curRcYieldCond.ym_prcpct2
					OTHERWISE
						lnPricePct = curRcYieldCond.ym_prcpct
				ENDCASE
				DO CASE
					CASE curRcYieldCond.ym_blocked OR this.DLocate("curYmngProp", "yp_ymid = " + SqlCnv(curRcYieldCond.ym_ymid,.T.) + " AND yp_date = " + SqlCnv(ldDate,.T.) + " AND 'X' $ yp_flags")
						toRoomAvail.ca_note = ALLTRIM(curRcYieldCond.ym_lang)+" ("+TRANSFORM(curRcYieldCond.ym_ymnr)+")"+CRLF+"-"+GetLangText("MGRFINAN", "TXT_YMRC_BLOCKED")+IIF(curRcYieldCond.ym_blocked,""," ("+TRANSFORM(ldDate)+")")
						IF EMPTY(toResultRC.rc_info)
							toResultRC.rc_info = toRoomAvail.ca_note
						ENDIF
						toResultRC.c_status = BITSET(toResultRC.c_status,APS_BLOCKED)
					CASE lnPricePct = 0
					OTHERWISE
						toRoomAvail.ca_note = ALLTRIM(curRcYieldCond.ym_lang) + " (" + TRANSFORM(curRcYieldCond.ym_ymnr) + ")" + CRLF + ;
							"-" + StrToMsg(GetLangText("MGRFINAN", "TXT_YMRC_CHANGED"),ALLTRIM(SUBSTR("- +",SIGN(lnPricePct)+2,1)+TRANSFORM(ABS(lnPricePct), "999"+IIF(curRcYieldCond.ym_prcunit=0,"%",""))))
						IF curRcYieldCond.ym_prcunit = 0
							lnRate = lnRate * (100+lnPricePct)/100	&& lnPricePct [%] - relative correction
						ELSE
							lnRate = lnRate + lnPricePct			&& lnPricePct [] - absolute correction
						ENDIF
				ENDCASE
				toRoomAvail.ca_yrid = curRcYieldCond.yr_yrid
				IF NOT EMPTY(toRoomAvail.ca_note)
					toRoomAvail.ca_note = toRoomAvail.ca_note + CRLF + GetLangText("MGRFINAN","T_STANDARD") + ": " + TRANSFORM(toRoomAvail.ca_defrate,"99999999.99")
				ENDIF
		
			ENDIF
		
			lnMinRate = MAX(0, curRatecode.rc_minrate + MAX(0,curRatecode.rc_mratepr * (this.oParams.nAdults+this.oParams.nChild1+this.oParams.nChild2+this.oParams.nChild3-1)))
			toRoomAvail.ca_rate = MAX(lnRate,lnMinRate)
			IF this.lgetsplits
				this.calcsplits(this.oParams.nAdults, this.oParams.nChild1, this.oParams.nChild2, this.oParams.nChild3)
			ENDIF
		ELSE
			toRoomAvail.ca_rate = toRoomAvail.ca_defrate
		ENDIF
		
		RETURN .T.
	ENDPROC

	PROCEDURE calcrateforperiod
		LPARAMETERS toResultRC
		#DEFINE APS_ALLZEROS			1
		LOCAL lnArea, lnDays, lnSumRate, lnEuro, lnRound, loRoomAvail
		
		lnArea = SELECT()
		
		SELECT curRoomAvail
		STORE 0 TO lnDays, lnSumRate
		SCAN FOR c_recordid = toResultRC.c_recordid
			SCATTER MEMO NAME loRoomAvail
			this.CalcRate(loRoomAvail, toResultRC)
			GATHER NAME loRoomAvail MEMO
			lnDays = lnDays + 1
			lnSumRate = lnSumRate + loRoomAvail.ca_rate
		ENDSCAN
		
		IF NOT this.DLocate("curRoomAvail", "c_recordid = " + SqlCnv(toResultRC.c_recordid) + " AND ca_rate > 0")
			toResultRC.c_status = BITSET(toResultRC.c_status,APS_ALLZEROS)
		ENDIF
		IF this.DLocate("curRoomAvail", "c_recordid = " + SqlCnv(toResultRC.c_recordid) + " AND ca_yrid > 0") AND ;
				this.DLocate("curRcYieldCond", "yr_yrid = curRoomAvail.ca_yrid") AND (this.oParams.nPriceSetting = 1 OR BETWEEN(curRcYieldCond.ym_round, 1, 5))
			lnRound = 0
			DO CASE
				CASE curRcYieldCond.ym_round = 1	&& Rounding to 5 Cent
					lnEuro = 0.05
				CASE curRcYieldCond.ym_round = 2	&& Rounding to 10 Cent
					lnEuro = 0.10
				CASE curRcYieldCond.ym_round = 3	&& Rounding to 50 Cent
					lnEuro = 0.50
				CASE curRcYieldCond.ym_round = 4	&& Rounding to 1 Euro
					lnEuro = 1
				CASE curRcYieldCond.ym_round = 5	&& Rounding to 5 Euro
					lnEuro = 5
				OTHERWISE
					lnEuro = 0.01
					lnRound = 4
			ENDCASE
			REPLACE ca_rate WITH ROUND(ROUND(IIF(this.oParams.nPriceSetting = 1, lnSumRate/lnDays, curRoomAvail.ca_rate) / lnEuro, lnRound) * lnEuro, 2) ;
				FOR c_recordid = toResultRC.c_recordid ;
				IN curRoomAvail
		ENDIF
		
		SELECT (lnArea)
		
		RETURN .T.
	ENDPROC

	PROCEDURE calcsplits
		LPARAMETERS tnAdults, tnChild1, tnChild2, tnChild3
		LOCAL lcCurRatecode, lnSelect, lcSql, lcCur, lcrateartiresultcursor, lcRCKey, lnPmRate, lnAmount, lnTimes
		lcCurRatecode = "curRatecode"
		lcrateartiresultcursor = this.crateartiresultcursor
		lnSelect = SELECT()
		lcCur = SYS(2015)
		lnPmRate = 0
		IF NOT EMPTY(&lcCurRatecode..rc_paynum)
			IF this.DLocate(this.cpaymetho, "pm_paynum = "+SqlCnv(&lcCurRatecode..rc_paynum))
				lnPmRate = EVALUATE(this.cpaymetho+".pm_rate")
			ENDIF
		ENDIF
		
		lcRCKey = &lcCurRatecode..rc_key
		TEXT TO lcSql TEXTMERGE NOSHOW PRETEXT 15
		SELECT ra_artinum, <<"ar_lang" + this.clangnum>> AS ar_lang, ra_artityp, ra_pmlocal, ra_amnt AS c_price, ra_multipl, ra_onlyon 
			FROM <<this.cratearti>> 
			INNER JOIN <<this.carticle >> ON ra_artinum = ar_artinum 
			WHERE ra_ratecod = [<<lcRCKey>>] AND ra_artityp > 1 
			<<IIF(tnChild1>0,""," AND ra_multipl<>3")>> 
			<<IIF(tnChild2>0,""," AND ra_multipl<>5")>>
			<<IIF(tnChild3>0,""," AND ra_multipl<>6")>>
			INTO CURSOR <<lcCur>>
		ENDTEXT
		
		&lcSql
		
		IF USED(lcCur) AND RECCOUNT(lcCur)>0
			SELECT (lcCur)
			SCAN ALL
				SELECT (lcrateartiresultcursor)
				LOCATE FOR rc_ratecod = &lcCurRatecode..rc_ratecod AND ra_artinum = &lcCur..ra_artinum
				IF NOT FOUND()
					lnAmount = &lcCur..c_price
					IF &lcCur..ra_artityp=3
						IF &lcCur..ra_onlyon=0
							lnTimes = MAX(this.oParams.dTo-this.oParams.dFrom, 1)
						ELSE
							lnTimes = 1
						ENDIF
						DO CASE
							CASE &lcCur..ra_multipl=1
								lnAmount =lnAmount*tnAdults*lnTimes
							CASE &lcCur..ra_multipl=2
								lnAmount = lnAmount*(tnAdults+tnChild1)*lnTimes
							CASE &lcCur..ra_multipl=3
								lnAmount = lnAmount*tnChild1*lnTimes
							CASE &lcCur..ra_multipl=4
								lnAmount = lnAmount*lnTimes
							CASE &lcCur..ra_multipl=5
								lnAmount = lnAmount*tnChild2*lnTimes
							CASE &lcCur..ra_multipl=6
								lnAmount = lnAmount*tnChild3*lnTimes
						ENDCASE
					ENDIF
					IF NOT EMPTY(lnPmRate) AND &lcCur..ra_pmlocal && Must convert from RSD to EUR
						lnAmount = ROUND(lnAmount/lnPmRate,2)
					ENDIF
					INSERT INTO (lcrateartiresultcursor) ;
						(rc_ratecod, ra_artinum, ar_lang, c_extra, c_price) VALUES ;
						(&lcCurRatecode..rc_ratecod, &lcCur..ra_artinum, &lcCur..ar_lang, IIF(&lcCur..ra_artityp=3,.T.,.F.), lnAmount)
				ENDIF
			ENDSCAN
		ENDIF
		
		this.dclose(lcCur)
		
		SELECT (lnSelect)
		RETURN .T.
	ENDPROC

	PROCEDURE checkweekdaysarray
		IF TYPE("paDow(1)")="C"
			RETURN .T.
		ENDIF
		
		PUBLIC ARRAY paDow(7)
		
		paDow(1) = "SUNDAY"
		paDow(2) = "MONDAY"
		paDow(3) = "TUESDAY"
		paDow(4) = "WEDNESDAY"
		paDow(5) = "THURSDAY"
		paDow(6) = "FRIDAY"
		paDow(7) = "SATURDAY"
		
		RETURN .T.
	ENDPROC

	PROCEDURE closealiases
		this.DClose("curResultRC")
		this.DClose("curRoomAvail")
		
		IF this.lOpenTables
			this.CloseTables()
		ENDIF
	ENDPROC

	PROCEDURE closetables		&& Causes the tables and views associated with the data environment to close.
		this.DClose(this.cparam)
		this.DClose(this.cparam2)
		this.DClose(this.cavailab)
		this.DClose(this.croomtype)
		this.DClose(this.cratecode)
		this.DClose(this.crateprop)
		this.DClose(this.cseason)
		this.DClose(this.cyieldmng)
		this.DClose(this.cymngprop)
		this.DClose(this.crcyield)
		this.DClose(this.calthead)
		this.DClose(this.caltsplit)
		this.DClose(this.carticle)
		this.DClose(this.cratearti)
		this.DClose(this.cpaymetho)
	ENDPROC

	PROCEDURE dclose
		LPARAMETERS tcAlias
		
		IF EMPTY(tcAlias)
			RETURN .T.
		ENDIF
		IF USED(tcAlias)
			USE IN (tcAlias)
		ENDIF
		
		RETURN .T.
	ENDPROC

	PROCEDURE Destroy
		this.CloseAliases()
	ENDPROC

	PROCEDURE displayroomtypes
		LPARAMETERS tcRoomType
		LOCAL i, lcRoomType, lcRoomTypes
		
		lcRoomTypes = ""
		
		IF this.ldisplayroomtypes
			FOR i = 1 TO GETWORDCOUNT(tcRoomType,",")
				lcRoomType = GETWORDNUM(tcRoomType,i,",")
				lcRoomTypes = lcRoomTypes + IIF(EMPTY(lcRoomTypes), "", ",") + ALLTRIM(IIF(lcRoomType = "*", lcRoomType, Get_rt_roomtyp(lcRoomType)))
				IF LEN(lcRoomTypes)>255
					lcRoomTypes = LEFT(lcRoomTypes,255)
					EXIT
				ENDIF
			NEXT
		ENDIF
		
		RETURN lcRoomTypes
	ENDPROC

	PROCEDURE dlocate
		LPARAMETER tcAlias, tcExpression, tlOptimized
		LOCAL lcOrder, lnArea, llFound
		
		lnArea = SELECT()
		
		SELECT (tcAlias)
		
		IF tlOptimized
			lcOrder = ORDER()
			SET ORDER TO
		ENDIF
		
		IF EMPTY(tcExpression)
			LOCATE
		ELSE
			LOCATE FOR &tcExpression
		ENDIF
		llFound = FOUND()
		
		IF tlOptimized
			SET ORDER TO lcOrder
		ENDIF
		
		SELECT (lnArea)
		
		RETURN llFound
	ENDPROC

	PROCEDURE dopen
		LPARAMETERS tcTable, tcAlias, tcPath
		LOCAL i, lcAlias, loErr
		
		IF EMPTY(tcTable)
			RETURN .F.
		ENDIF
		
		IF EMPTY(tcAlias)
			lcAlias = ""
			tcAlias = tcTable
		ELSE
			lcAlias = "ALIAS " + tcAlias
		ENDIF
		IF EMPTY(tcPath)
			tcPath = ""
		ELSE
			tcPath = ADDBS(tcPath)
		ENDIF
		IF USED(tcAlias) AND NOT JUSTPATH(DBF(tcAlias)) == JUSTPATH(FULLPATH(tcPath))
			this.DClose(tcAlias)
		ENDIF
		
		IF NOT USED(tcAlias)
			FOR i = 1 TO 2
				loErr = .NULL.
				TRY
					USE (tcPath+tcTable) IN 0 &lcAlias AGAIN SHARED 
				CATCH TO loErr
				ENDTRY
				DO CASE
					CASE TYPE("loErr.ErrorNo") <> "N"
					CASE loErr.ErrorNo = 1707		&& CDX file was deleted
						LOOP
					OTHERWISE
				ENDCASE
				EXIT
			NEXT
		ENDIF
		
		RETURN USED(tcAlias)
	ENDPROC

	PROCEDURE getmessage
		LPARAMETERS toResultRC
		#DEFINE APS_BLOCKED				0
		LOCAL l_nArea, lcMessage, l_cCurRateprop, l_cRcProp, l_dDateBlocked, l_lMinStay, l_nMinStay, l_lMultiple, l_lFound, l_nDOW, l_nDOW1
		
		ldFrom = this.oParams.dFrom
		ldTo = MAX(this.oParams.dTo - 1, ldFrom)
		lnMinStay = this.oParams.nMinStay
		
		l_lMinStay = NOT EMPTY(ldFrom) OR (lnMinStay > 0)
		ldFrom = IIF(EMPTY(ldFrom), curRatecode.rc_fromdat, MAX(ldFrom, curRatecode.rc_fromdat))
		ldTo = IIF(EMPTY(ldTo), curRatecode.rc_todat, MIN(ldTo, curRatecode.rc_todat))
		l_dDateBlocked = {}
		IF curRatecode.rc_minstay <= lnMinStay OR this.lShowMinMaxBlocked && When invalid ratecodes which have minstay or maxstay limit should be showed in webbooking, we must check for ratecode blocks
			l_cRcProp = ""
			TEXT TO l_cSql TEXTMERGE NOSHOW PRETEXT 2 + 8
				SELECT * FROM <<this.crateprop>>
					WHERE rd_ratecod = <<SqlCnv(curRatecode.rc_key,.T.)>>
					ORDER BY rd_valdate
			ENDTEXT
			l_nArea = SELECT()
			l_cCurRateprop = SYS(2015)
			&l_cSql INTO CURSOR &l_cCurRateprop
		
			IF RECCOUNT(l_cCurRateprop) > 0
		
				* Check for blocking for some day in week
		
				l_nDOW = DOW(ldFrom, 2)
				l_nDOW1 = 7
				SELECT (l_cCurRateprop)
				SCAN FOR EMPTY(rd_valdate)
					IF "BLOCK_DOW" $ rd_rcpname
						IF l_nDOW1 > MOD(VAL(RIGHT(ALLTRIM(rd_rcpname),1)) - l_nDOW, 7)
							l_cRcProp = ALLTRIM(rd_rcpname)
							l_nDOW1 = MOD(VAL(RIGHT(l_cRcProp,1)) - l_nDOW, 7)
						ENDIF
					ENDIF
				ENDSCAN
				DO CASE
					CASE l_nDOW1 = 7
					CASE ldFrom + l_nDOW1 <= ldTo
						l_dDateBlocked = ldFrom + l_nDOW1
						l_lMultiple = .T.
						l_lFound = .T.
					OTHERWISE
						l_cRcProp = ""
				ENDCASE
		
				* Check for blocking for arrival date for some day in week
		
				IF NOT l_lFound
		
					l_nDOW = DOW(ldFrom, 2)
					SELECT (l_cCurRateprop)
					SCAN FOR EMPTY(rd_valdate)
						IF "BLOCK_ARR_DOW" $ rd_rcpname AND rd_valuel
							IF l_nDOW = INT(VAL(RIGHT(ALLTRIM(rd_rcpname),1)))
								l_cRcProp = ALLTRIM(rd_rcpname)
								l_lFound = .T.
								EXIT
							ENDIF
						ENDIF
					ENDSCAN
		
				ENDIF
		
				* Check for blocking for departure date for some day in week
		
				IF NOT l_lFound
		
					l_nDOW = DOW(ldTo +1, 2)
					SELECT (l_cCurRateprop)
					SCAN FOR EMPTY(rd_valdate)
						IF "BLOCK_DEP_DOW" $ rd_rcpname AND rd_valuel
							IF l_nDOW = INT(VAL(RIGHT(ALLTRIM(rd_rcpname),1)))
								l_cRcProp = ALLTRIM(rd_rcpname)
								l_lFound = .T.
								EXIT
							ENDIF
						ENDIF
					ENDSCAN
		
				ENDIF
		
				* Check for blocking for specific date
				IF NOT l_lFound
					SCAN FOR BETWEEN(rd_valdate, ldFrom, ldTo) AND NOT (l_lFound AND l_lMultiple)
						DO CASE
							CASE rd_valuen > 0 AND (EMPTY(ldFrom) AND EMPTY(lnMinStay) OR rd_valuen <= lnMinStay)
							CASE l_lFound
								l_lMultiple = .T.
							CASE EMPTY(l_dDateBlocked) OR rd_valdate <= l_dDateBlocked
								l_cRcProp = ALLTRIM(rd_rcpname)
								l_dDateBlocked = rd_valdate
								l_nMinStay = INT(rd_valuen)
								l_lFound = .T.
							OTHERWISE
						ENDCASE
					ENDSCAN
				ENDIF
		
			ENDIF
		
			this.DClose(l_cCurRateprop)
			SELECT (l_nArea)
		ELSE
			l_lMultiple = (ldTo - ldFrom > 1)
			l_cRcProp = "MIN_STAY_DATE"
			l_nMinStay = curRatecode.rc_minstay
		ENDIF
		DO CASE
			CASE l_cRcProp = "BLOCK_DATE"
				lcMessage = StrToMsg(GetLangText("MGRFINAN", "TXT_ISBLOCKED"),DTOC(l_dDateBlocked)) + IIF(l_lMultiple,"..","")
			CASE l_cRcProp = "MIN_STAY_DATE"
				IF this.lcheckratepropblock
					IF curRatecode.rc_minstay < l_nMinStay
						toResultRC.rc_minstay = l_nMinStay
					ENDIF
				ENDIF
				lcMessage = StrToMsg(GetLangText("MGRFINAN", "TXT_MINSTAY"),TRANSFORM(l_nMinStay) + IIF(EMPTY(l_dDateBlocked),""," (" + DTOC(l_dDateBlocked) + ")")) + IIF(l_lMultiple,"..","")
			CASE "BLOCK_DOW" $ l_cRcProp
				lcMessage = StrToMsg(GetLangText("MGRFINAN", "TXT_ISBLOCKED"),paDow(DOW(l_dDateBlocked))) + IIF(l_lMultiple,"..","")
			CASE "BLOCK_ARR_DOW" $ l_cRcProp
				lcMessage = GetLangText("MGRFINAN", "TXT_ARR_WEEKLY_BLOCK")
			CASE "BLOCK_DEP_DOW" $ l_cRcProp
				lcMessage = GetLangText("MGRFINAN", "TXT_DEP_WEEKLY_BLOCK")
		ENDCASE
		IF NOT EMPTY(lcMessage)
			toResultRC.rc_info = lcMessage
			toResultRC.c_status = BITSET(toResultRC.c_status,APS_BLOCKED)
		ENDIF
		
		RETURN .T.
	ENDPROC

	PROCEDURE getnotes
		LPARAMETERS toResultRC
		LOCAL lnArea, lcCurRateprop, lcSql, lcRateCode, loRateprop, ldFromDate, ldFromDate, ldToDate, lcMessage
		
		lnArea = SELECT()
		
		lcMessage = ""
		ldFromDate = MAX(this.oParams.dFrom, curRatecode.rc_fromdat)
		ldToDate = IIF(EMPTY(this.oParams.dTo), curRatecode.rc_todat, MIN(this.oParams.dTo, curRatecode.rc_todat))
		
		IF NOT EMPTY(curRatecode.rc_minstay)
			lcMessage = StrToMsg(GetLangText("MGRFINAN", "TXT_MINSTAY")+";",TRANSFORM(curRatecode.rc_minstay))
		ENDIF
		lcRateCode = curRatecode.rc_ratecod+curRatecode.rc_roomtyp+DTOS(curRatecode.rc_fromdat)+curRatecode.rc_season
		TEXT TO lcSql TEXTMERGE NOSHOW PRETEXT 2 + 8
			SELECT * FROM <<this.crateprop>>
				WHERE rd_ratecod = <<SqlCnv(lcRateCode,.T.)>> AND BETWEEN(rd_valdate,<<SqlCnv(ldFromDate,.T.)>>,<<SqlCnv(ldToDate,.T.)>>) AND (rd_valuel OR rd_valuen > 0)
				ORDER BY rd_rcpname, rd_valdate
		ENDTEXT
		lcCurRateprop = SYS(2015)
		&lcSql INTO CURSOR &lcCurRateprop
		SCATTER NAME loRateprop
		ldFromDate = loRateprop.rd_valdate
		DO WHILE NOT EOF()
			SKIP
			IF rd_rcpname <> loRateprop.rd_rcpname OR rd_valuen <> loRateprop.rd_valuen OR rd_valdate > loRateprop.rd_valdate + 1 OR EOF()
				DO CASE
					CASE loRateprop.rd_rcpname = "BLOCK_DATE"
						lcMessage = lcMessage + StrToMsg(GetLangText("MGRFINAN", "TXT_INTERVALBLOCKED")+";", DTOC(ldFromDate), DTOC(loRateprop.rd_valdate))
					CASE loRateprop.rd_rcpname = "MIN_STAY_DATE"
						lcMessage = lcMessage + StrToMsg(GetLangText("MGRFINAN", "TXT_INTERVALMINSTAY")+";", DTOC(ldFromDate), DTOC(loRateprop.rd_valdate), TRANSFORM(loRateprop.rd_valuen))
				ENDCASE
				ldFromDate = rd_valdate
			ENDIF
			SCATTER NAME loRateprop
		ENDDO
		TEXT TO lcSql TEXTMERGE NOSHOW PRETEXT 2 + 8
			SELECT * FROM <<this.crateprop>>
				WHERE rd_ratecod = <<SqlCnv(lcRateCode,.T.)>> AND rd_rcpname = 'BLOCK_DOW'
				ORDER BY rd_rcpname
		ENDTEXT
		&lcSql INTO CURSOR &lcCurRateprop
		SCAN
			lcMessage = lcMessage + StrToMsg(GetLangText("MGRFINAN", "TXT_ISBLOCKED")+";",paDow(MOD(VAL(RIGHT(ALLTRIM(rd_rcpname),1)),7)+1))
		ENDSCAN
		this.DClose(lcCurRateprop)
		
		IF NOT EMPTY(lcMessage)
			toResultRC.rc_note = lcMessage
		ENDIF
		
		SELECT (lnArea)
	ENDPROC

	PROCEDURE getoccupancyforperiod
		LPARAMETERS tdFromDate, tdToDate, toOldReservat
		LOCAL lnArea, loParam, loParam2, lcSql, lcurDates, lcurRoomtype, ldArrdate, ldDepdate, lcRoomtype, lnRooms
		
		lnArea = SELECT()
		
		SELECT (this.cparam)
		SCATTER MEMO NAME loParam
		SELECT (this.cparam2)
		SCATTER MEMO NAME loParam2
		
		lcurDates = MakeDatesCursor(tdFromDate, tdToDate)	&&c_date
		lcurRoomtype = SYS(2015)
		
		TEXT TO lcSql TEXTMERGE NOSHOW PRETEXT 2 + 8
		SELECT rt_roomtyp, 000000 AS c_maxavail 
		     FROM <<this.croomtype>> 
		     WHERE INLIST(rt_group, 1, 4) <<IIF(this.lFilterMaxPersons," AND rt_maxpers >= " + TRANSFORM(this.oParams.nAdults),"")>> 
		     <<IIF(NOT EMPTY(this.cRoomTypeFilter)," AND " + this.cRoomTypeFilter,"")>> 
		     INTO CURSOR <<lcurRoomtype>> READWRITE
		ENDTEXT
		&lcSql
		
		* Get availability for given date period
		TEXT TO lcSql TEXTMERGE NOSHOW PRETEXT 2 + 8
			SELECT av_date, av_roomtyp, av_avail, av_ooorder, av_definit
				<<IIF(loParam.pa_allodef, "+CallFunc('MAX(p1,0)',av_allott+av_altall-av_pick)", "")>>
				<<IIF(loParam.pa_optidef, "+av_option", "")>>
				<<IIF(loParam.pa_tentdef, "+av_tentat", "")>>
				<<IIF(loParam2.pa_oosdef, "+av_ooservc", "")>> AS av_definit
				FROM <<this.cavailab>>
				INNER JOIN <<lcurRoomtype>> ON rt_roomtyp = av_roomtyp
				WHERE av_date BETWEEN <<SqlCnv(tdFromDate,.T.)>> AND <<SqlCnv(tdToDate,.T.)>> 
		ENDTEXT
		&lcSql INTO CURSOR curAvailab
		
		SELECT (lcurRoomtype)
		SCAN ALL
			SELECT curAvailab
			LOCATE FOR av_roomtyp = &lcurRoomtype..rt_roomtyp
			IF FOUND()
				REPLACE c_maxavail WITH curAvailab.av_avail+curAvailab.av_ooorder IN &lcurRoomtype
			ENDIF
		ENDSCAN
		
		IF ISNULL(toOldReservat)
			ldArrdate = {}
			ldDepdate = {}
			lcRoomtype = ""
			lnRooms = 0
		ELSE
			ldArrdate = toOldReservat.rs_arrdate
			ldDepdate = toOldReservat.rs_depdate
			lcRoomtype = toOldReservat.rs_roomtyp
			lnRooms = toOldReservat.rs_rooms
		ENDIF
		
		* For roomtypes without records in availab table, set availability to sysdate availability ???
		SELECT rt_roomtyp AS av_roomtyp, c_date AS av_date, NVL(av_avail,c_maxavail) AS av_avail, ;
				NVL(av_definit,0) - IIF(lnRooms > 0 AND BETWEEN(c_date, ldArrdate, ldDepdate-1) AND rt_roomtyp = lcRoomtype, lnRooms, 0) AS av_definit ;
			FROM (SELECT rt_roomtyp, c_maxavail, c_date FROM &lcurRoomtype, &lcurDates ORDER BY 1,3) c ;
			LEFT JOIN curAvailab ON av_date = c_date AND av_roomtyp = rt_roomtyp ;
			INTO CURSOR curAvailab
		
		this.DClose(lcurDates)
		this.DClose(lcurRoomtype)
		
		SELECT(lnArea)
	ENDPROC

	PROCEDURE getrates
		LPARAMETERS toParams
		LOCAL i, ldFrom, ldTo, ldDate, lnMinStay, lcRoomtype, lnAltId, lcSetId, lcRateCode, lcForClause, lcForClauseAs, lcForClauseYp
		LOCAL llHasDate, lcSql, lcSelectedRc, loResultRC, lcNear, lnCounter, llLockScreen, lcurRatecode, lcMessage
		LOCAL ARRAY laAvailab(1)
		
		this.oParams = toParams
		
		IF TYPE("this.oParams.lDontCheckClosArr")="L" AND this.oParams.lDontCheckClosArr
			this.lDontCheckClosArr = .T.
		ENDIF
		IF TYPE("this.oParams.lFilterMaxPersons")="L" AND this.oParams.lFilterMaxPersons
		     this.lFilterMaxPersons = .T.
		ENDIF
		
		STORE "" TO lcForClause, lcForClauseAs, lcForClauseYp
		IF NOT EMPTY(this.oParams.dFrom)
			lcForClause = " AND rc_todat > " + SqlCnv(this.oParams.dFrom,.T.) + " AND rc_fromdat <= " + SqlCnv(this.oParams.dTo,.T.)
			lcForClauseAs = " AND BETWEEN(as_date, " + SqlCnv(this.oParams.dFrom,.T.) + ", " + SqlCnv(this.oParams.dTo,.T.) + ")"
			lcForClauseYp = " AND BETWEEN(yp_date, " + SqlCnv(this.oParams.dFrom,.T.) + ", " + SqlCnv(this.oParams.dTo,.T.) + ")"
			llHasDate = .T.
		ENDIF
		
		DO CASE
			CASE EMPTY(this.oParams.cRoomtype)
			CASE this.oParams.cRoomtype = "*   "
				lcForClause = lcForClause + " AND rc_roomtyp = '*   '"
			OTHERWISE
				lcForClause = lcForClause + " AND (rc_roomtyp = '*   ' OR ','+rc_roomtyp+',' $ " + SqlCnv(","+this.oParams.cRoomtype+",",.T.) + ")"
				lcForClauseAs = lcForClauseAs + " AND (as_roomtyp = '*   ' OR ','+as_roomtyp+',' $ " + SqlCnv(","+this.oParams.cRoomtype+",",.T.) + ")"
		ENDCASE
		
		IF NOT EMPTY(this.oParams.cRateCode)
			lcForClause = lcForClause + " AND rc_ratecod = " + SqlCnv(this.oParams.cRateCode,.T.)
			lcForClauseAs = lcForClauseAs + " AND as_ratecod = " + SqlCnv(this.oParams.cRateCode,.T.)
		ENDIF
		
		IF EMPTY(this.cRatecodeFilter)
			lcForClause = lcForClause + " AND rc_period = 3"
		ELSE
			lcForClause = lcForClause + " AND " + this.cRatecodeFilter
		ENDIF
		* Get APS for rate codes conditions
		* Cursor 'curRcYieldCond'
		TEXT TO lcSql TEXTMERGE NOSHOW PRETEXT 2 + 8
			SELECT CAST(IIF(ym_avltype=0,ym_avail,999999-ym_avail) AS Numeric(6)) AS yr_ymkey, yr_yrid, yr_ratecod, ym_lang<<this.cLangnum>> AS ym_lang,
				ym_avail, ym_avltype, ym_avlhot, ym_blocked, ym_days, ym_daytype, ym_prcpct, ym_prcpct2, ym_prcpct3, ym_prcunit, ym_round, ym_ymid, ym_ymnr FROM <<this.crcyield>>
				INNER JOIN <<this.cyieldmng>> ON yr_ymid = ym_ymid
				WHERE <<IIF(this.lWithoutAPS, "0=1", "ym_active")>>
				ORDER BY yr_ymkey, yr_ratecod
		ENDTEXT
		&lcSql INTO CURSOR curRcYieldCond
		
		* Cursor 'curYmngProp'
		TEXT TO lcSql TEXTMERGE NOSHOW PRETEXT 2 + 8
			SELECT * FROM <<this.cymngprop>>
				WHERE <<IIF(this.lWithoutAPS, "0=1", "0=0")>><<lcForClauseYp>>
				ORDER BY yp_date
		ENDTEXT
		&lcSql INTO CURSOR curYmngProp
		
		* Get availability for specified interval
		* Cursor 'curAvailab'
		this.GetOccupancyForPeriod(EVL(this.oParams.dFrom, this.dSysDate), IIF(llHasDate, MAX(this.oParams.dFrom,this.oParams.dTo-1), this.dSysDate), this.oParams.oReservat)
		
		* Group rate codes by rate code name and set of room types.
		* Cursor 'curRatecode'
		
		IF this.lFilterMaxPersons
			* When filtering on persons, get only ratecodes for available roomtypes
			SELECT av_roomtyp AS rt_roomtyp FROM curAvailab WHERE 1=1 GROUP BY 1 ORDER BY 1 INTO CURSOR curavrts
		ENDIF
		
		TEXT TO lcSql TEXTMERGE NOSHOW PRETEXT 2 + 8
		SELECT <<this.cratecode>>.*, rc_lang<<this.cLangnum>> AS rc_lang, rc_citmob<<this.cLangnum>> AS rc_citmobd, CAST(0 AS Int) AS c_recordid 
			FROM <<this.cratecode>>
			<<IIF(EMPTY(this.oParams.nAltId), "", "INNER JOIN " + this.caltsplit + " ON as_altid = " + SqlCnv(this.oParams.nAltId,.T.) + lcForClauseAs + " AND as_ratecod = rc_ratecod")>>
			INNER JOIN <<IIF(this.lFilterMaxPersons,"curavrts",this.croomtype)>> ON rt_roomtyp = rc_roomtyp OR rc_roomtyp = '*   '
			LEFT JOIN <<this.cSeason>> ON <<IIF(EMPTY(this.oParams.dFrom), "", "BETWEEN(se_date, " + SqlCnv(this.oParams.dFrom,.T.) + ", " + SqlCnv(this.oParams.dTo-1,.T.) + ") AND ")>>se_season = rc_season
			WHERE rc_ratecod <> 'DUM       '<<lcForClause>> AND NOT rc_inactiv AND NOT rc_complim AND INLIST(rc_season, ' ', NVL(se_season,' '))
			<<IIF(EMPTY(this.oParams.dFrom) OR this.lShowMinMaxBlocked, "", " AND rc_minstay <= " + SqlCnv(this.oParams.dTo - this.oParams.dFrom) + " AND (rc_maxstay = 0 OR rc_maxstay >= " + SqlCnv(this.oParams.dTo - this.oParams.dFrom) + ")")>>
		ENDTEXT
		&lcSql INTO CURSOR curRatecode READWRITE
		INDEX ON PADL(c_recordid,10)+rc_roomtyp+rc_season+DTOS(rc_fromdat) TAG rc_locate DESCENDING
		INDEX ON rc_ratecod TAG rc_ratecod
		SET ORDER TO
		
		this.DClose("curavrts")
		
		* Fill curResultRC with groupped ratecodes.
		* Fill curRoomAvail with availability data for every record in curResultRC.
		ZAP IN curResultRC
		ZAP IN curRoomAvail
		
		lcurRatecode = SYS(2015)
		SELECT rc_ratecod, CAST(0 AS Int) AS c_recordid ;
			FROM curRatecode ;
			GROUP BY 1 ;
			ORDER BY 1 ;
			INTO CURSOR (lcurRatecode)
		SCATTER BLANK NAME loRatecode
		* Set relation between curResultRC and curRatecode (foeign key is 'c_recordid')
		lnCounter = 0
		SCAN
			IF loRatecode.rc_ratecod <> rc_ratecod
				lnCounter = lnCounter + 1
				SCATTER NAME loRatecode
				loRatecode.c_recordid = lnCounter
				INSERT INTO curResultRC FROM NAME loRatecode
				IF EVL(this.oParams.cRoomtype,"*   ") = "*   "
					INSERT INTO curRoomAvail (c_recordid, ca_date, ca_alldef, ca_allrms, ca_rtdef, ca_rtrms) ;
						SELECT lnCounter, av_date, SUM(av_definit), SUM(av_avail), SUM(av_definit), SUM(av_avail) ;
							FROM curAvailab ;
							GROUP BY av_date
				ELSE
					INSERT INTO curRoomAvail (c_recordid, ca_date, ca_alldef, ca_allrms, ca_rtdef, ca_rtrms) ;
						SELECT lnCounter, av_date, SUM(av_definit), SUM(av_avail), ;
							SUM(IIF(','+av_roomtyp+',' $ ','+toParams.cRoomtype+',', av_definit, 0)), ;
							SUM(IIF(','+av_roomtyp+',' $ ','+toParams.cRoomtype+',', av_avail, 0)) ;
							FROM curAvailab ;
							GROUP BY av_date
				ENDIF
			ENDIF
			lcSetId = rc_ratecod
			REPLACE c_recordid WITH lnCounter FOR rc_ratecod = lcSetId IN curRatecode
		ENDSCAN
		this.DClose(lcurRatecode)
		
		SET ORDER TO rc_locate IN curRatecode
		
		SELECT curResultRC
		SCAN
			SCATTER MEMO NAME loResultRC
			this.CalcRateForPeriod(loResultRC)
			IF EMPTY(loResultRC.rc_info) AND NOT this.lfiltermaxpersons&& Check if ratecode is already blocked
				this.GetMessage(loResultRC)
			ENDIF
			*this.GetNotes(loResultRC)
			GATHER NAME loResultRC MEMO
		ENDSCAN
		this.DClose("curRcYieldCond")
		this.DClose("curYmngProp")
		this.DClose("curAvailab")
		this.DClose("curRatecode")
	ENDPROC

	PROCEDURE getratesforperiod
		LPARAMETERS tdFromDate, tdToDate, tcCurResult, tcRatecodeFilter, ;
			tnAdults, tnChild1, tnChild2, tnChild3, tcRoomType, ;
			tlGetSplits, tcLangNum, tcCurSplits, tlEnableStayRatecodes, tlShowMinMaxBlocked, tlDontUseDisplayRoomTypes, tlDontCheckClosArr, tlFilterMaxPersons, tcRoomTypeFilter
		LOCAL lcWhere, loData
		
		this.OpenAliases()
		this.dSysDate = EVALUATE(this.cparam + ".pa_sysdate")
		
		loParams = MakeStructure("oReservat, dFrom, dTo, nMinStay, cRoomtype, nAltId, cRateCode, nAdults, nChild1, nChild2, nChild3, nPriceSetting, lDontCheckClosArr, lFilterMaxPersons")
		loParams.oReservat = .NULL.
		loParams.dFrom = tdFromDate
		loParams.dTo = tdToDate+1
		loParams.nMinStay = 0
		loParams.cRoomtype = PADR(tcRoomType,4)
		loParams.nAltId = 0
		loParams.cRateCode = ""
		loParams.nAdults = tnAdults
		loParams.nChild1 = tnChild1
		loParams.nChild2 = tnChild2
		loParams.nChild3 = tnChild3
		loParams.nPriceSetting = 0
		loParams.lDontCheckClosArr = IIF(tlDontCheckClosArr,.T.,.F.)
		loParams.lFilterMaxPersons = IIF(tlFilterMaxPersons ,.T.,.F.)
		IF tlDontUseDisplayRoomTypes
			this.ldisplayroomtypes = .F.
		ENDIF
		
		this.lcheckratepropblock = .T.
		this.cRatecodeFilter = tcRatecodeFilter
		
		IF tlGetSplits
			this.lGetSplits = .T.
			this.crateartiresultcursor = SYS(2015)
			tcCurSplits = this.crateartiresultcursor
			SELECT CAST('' AS Char(10)) AS rc_ratecod, CAST(0 AS Numeric(4)) AS ra_artinum, CAST ('' AS Char(35)) AS ar_lang, .F. AS c_extra, CAST(0 AS Numeric(12,2)) AS c_price ;
				FROM (this.cparam) ;
				WHERE 0=1 ;
				INTO CURSOR (this.crateartiresultcursor) READWRITE
		ENDIF
		IF NOT EMPTY(tcLangNum)
		     this.cLangNum = tcLangNum
		ENDIF
		this.lShowMinMaxBlocked = tlShowMinMaxBlocked
		
		IF tlEnableStayRatecodes
			this.cRatecodeFilter = this.cRatecodeFilter + " AND rc_period IN (3,6,7)"
		ELSE
			this.cRatecodeFilter = this.cRatecodeFilter + " AND rc_period = 3"
		ENDIF
		
		IF NOT EMPTY(tcRoomTypeFilter)
		     this.cRoomTypeFilter = tcRoomTypeFilter
		ELSE
		     this.cRoomTypeFilter = ""
		ENDIF
		
		this.GetRates(loParams)
		
		lcWhere = IIF(tlDontCheckClosArr,[1=1],[EMPTY(STRTRAN(STRTRAN(rc_info,"TXT_MINSTAY",""),".",""))])
		
		IF tlFilterMaxPersons
		     * Return only available rooms, and min rate pro date
		     SELECT ca_date AS av_date, 0000 AS av_avail, ca_rate AS av_rate FROM curRoomAvail WHERE 1=0 INTO CURSOR (tcCurResult) READWRITE
		     INDEX ON av_date TAG TAG1
		     SELECT curRoomAvail
		     SCAN ALL
		          SELECT &tcCurResult
		          LOCATE FOR av_date = curRoomAvail.ca_date
		          IF FOUND()
		               IF curRoomAvail.ca_rate > 0.00 AND curRoomAvail.ca_rate < av_rate
		                    REPLACE av_rate WITH curRoomAvail.ca_rate
		               ENDIF
		          ELSE
		               SCATTER NAME loData BLANK
		               loData.av_date = curRoomAvail.ca_date
		               loData.av_avail = curRoomAvail.ca_rtrms-curRoomAvail.ca_rtdef
		               loData.av_rate = curRoomAvail.ca_rate
		               INSERT INTO &tcCurResult FROM NAME loData
		          ENDIF
		     ENDSCAN
		ELSE
		     SELECT ca_date AS av_date, ;
		             ca_rtrms-ca_rtdef AS av_avail, ;
		             ca_rtdef AS av_definit, ;
		             rc_ratecod, ;
		             ca_ratecod AS rc_key, ;
		             ca_rate AS rc_rate, ;
		             rc_period, ;
		             rc_minstay, ;
		             rc_maxstay, ;
		             rc_citmoss, ;
		             rc_citmobd, ;
		             rc_lang ;
		             FROM curRoomAvail INNER JOIN curResultRC ON curRoomAvail.c_recordid = curResultRC.c_recordid ;
		             WHERE &lcWhere ;
		             ORDER BY 1 ;
		             INTO CURSOR (tcCurResult)
		
		ENDIF
		
		RETURN .T.
		
	ENDPROC

	PROCEDURE getrcroomtypes
		LPARAMETERS tcRatecode, tdDate
		LOCAL lnArea, lcRoomTypes, lcSeason, lnRow, lAdd, lnRecNo, lcRT
		
		lnArea = SELECT()
		
		* Find season for tdDate
		SELECT (this.cSeason)
		LOCATE FOR se_date = tdDate
		IF FOUND()
			lcSeason = se_season
		ELSE
			lcSeason = " "
		ENDIF
		
		* Get all roomtypes for tcRatecode for tdDate, and store these in lcRoomTypes variable, comma delimited
		
		lcRoomTypes = ","
		
		SELECT curRatecode
		
		IF NOT EOF()
			lnRecNo = RECNO()
		ENDIF
		
		SCAN FOR rc_ratecod = tcRatecode AND BETWEEN(tdDate, rc_fromdat, rc_todat-1) AND INLIST(rc_season, " ", lcSeason)
			lcRT = ALLTRIM(rc_roomtyp)
			IF NOT "," + lcRT + "," $ lcRoomTypes
				* Store every roomtype with comma delimiter, for checking if this roomtype is already added to lcRoomTypes
				lcRoomTypes = lcRoomTypes + lcRT + ","
			ENDIF
		ENDSCAN
		
		IF NOT EMPTY(lnRecNo)
			GO lnRecNo
		ENDIF
		
		IF lcRoomTypes==","
			* No roomtype is found
			lcRoomTypes = ""
		ELSE
			* Remove comma from begining and end of string
			lcRoomTypes = SUBSTR(SUBSTR(lcRoomTypes, 1, LEN(lcRoomTypes)-1),2)
		ENDIF
		
		SELECT (lnArea)
		
		RETURN lcRoomTypes
	ENDPROC

	PROCEDURE Init
		LPARAMETERS tcPath
		IF NOT EMPTY(tcPath)
			this.cpathdesk = ADDBS(tcPath)
		ENDIF
		
		DODEFAULT()
		
		this.cparam = SYS(2015)
		this.cparam2 = SYS(2015)
		this.cavailab = SYS(2015)
		this.croomtype = SYS(2015)
		this.cratecode = SYS(2015)
		this.crateprop = SYS(2015)
		this.cseason = SYS(2015)
		this.cyieldmng = SYS(2015)
		this.cymngprop = SYS(2015)
		this.crcyield = SYS(2015)
		this.calthead = SYS(2015)
		this.caltsplit = SYS(2015)
		this.carticle = SYS(2015)
		this.cratearti = SYS(2015)
		this.cpaymetho = SYS(2015)
		
		this.CheckWeekDaysArray()
	ENDPROC

	PROCEDURE openaliases
		IF this.lSetEnvironment
			this.SetEnvironment()
		ENDIF
		IF this.lOpenTables
			this.OpenTables()
		ENDIF
		this.PrepareCursors()
	ENDPROC

	PROCEDURE opentables		&& Programmatically opens the tables and views associated with the data environment.
		this.DOpen("param", this.cparam, this.cPathDesk)
		this.DOpen("param2", this.cparam2, this.cPathDesk)
		this.DOpen("availab", this.cavailab, this.cPathDesk)
		this.DOpen("roomtype", this.croomtype, this.cPathDesk)
		this.DOpen("ratecode", this.cratecode, this.cPathDesk)
		this.DOpen("rateprop", this.crateprop, this.cPathDesk)
		this.DOpen("season", this.cseason, this.cPathDesk)
		this.DOpen("yieldmng", this.cyieldmng, this.cPathDesk)
		this.DOpen("ymngprop", this.cymngprop, this.cPathDesk)
		this.DOpen("rcyield", this.crcyield, this.cPathDesk)
		this.DOpen("althead", this.calthead, this.cPathDesk)
		this.DOpen("altsplit", this.caltsplit, this.cPathDesk)
		this.DOpen("ratearti", this.cratearti, this.cPathDesk)
		this.DOpen("article", this.carticle, this.cPathDesk)
		this.DOpen("paymetho", this.cpaymetho, this.cPathDesk)
	ENDPROC

	PROCEDURE preparecursors
		CREATE CURSOR curRoomAvail (c_recordid I, ca_date d, ca_alldef n(5), ca_allrms n(5), ca_rtdef n(5), ca_rtrms n(5), ca_occpct n(6,2), ca_ratecod c(23), ca_roomtyp C(230), ca_defrate n(11,2), ca_rate n(11,2), ca_yrid i, ca_note m)
		INDEX ON ca_date TAG ca_date
		INDEX ON c_recordid TAG c_recordid
		
		CREATE CURSOR curResultRC (c_recordid I, c_rcrecid I, c_status I, rc_ratecod C(10), rc_lang C(35), rc_info C(254), rc_note M, rc_citmobd M, rc_period N(1), rc_minstay N(2), rc_maxstay N(3), rc_citmoss L, c_done L)
		INDEX ON rc_ratecod TAG rc_ratecod
		INDEX ON c_rcrecid TAG c_rcrecid
		SET ORDER TO
		SET RELATION TO c_recordid INTO curRoomAvail
	ENDPROC

	PROCEDURE ratecalculate
		LPARAMETERS tdDate, tcRateCode, tcRoomType, tnAltId, tnRate, tnAdults, tnChilds, tnChilds2, tnChilds3, tdArrdate, tdDepdate, tcArrtime, tcDeptime, tcRcAlias
		
		***********************************************************************************
		*
		* Don't forget to also change function RateCalculate in commonprocs.prg, in Desk !
		*
		***********************************************************************************
		
		LOCAL lnArea, lnRate, llFound, lnDOWcurrent, lnDOWarrival, ldDate, lnPeriods, lcAdFld, lcChFld, lcAsRateFld, lcPaAlias, l_nSelect, l_cRoomCur, lnPersons, ;
				lnAddonPersons, lnAddonPrice
		
		lnArea = SELECT()
		lnRate = tnRate
		llFound = .F.
		ldDate = IIF(EMPTY(tdDate), MIN(tdDepdate, MAX(tdArrdate, this.dSysdate)), tdDate)
		IF EMPTY(tcRcAlias)
			tcRcAlias = this.cRateCode
		ENDIF
		lcPaAlias = this.cparam
		
		IF LEFT(tcRateCode,1) = "!"	&& changed ratecode in allotments
			IF SEEK(tnAltId,this.calthead,"tag1")
				SELECT (this.caltsplit)
				LOCATE FOR as_altid = tnAltId AND as_date = ldDate AND as_ratecod = STRTRAN(tcRateCode,"!") AND ;
					(","+as_roomtyp+"," $ ","+tcRoomType+"," OR as_roomtyp = "*   ")
				IF FOUND()
					IF tnAdults > 0
						lcAsRateFld = "as_rate" + TRANSFORM(tnAdults)
						IF tnAdults > 5 OR EMPTY(&lcAsRateFld)
							lnRate = tnAdults * as_rate1
						ELSE
							lnRate = &lcAsRateFld
						ENDIF
					ELSE
						lnRate = 0
					ENDIF
					lnRate = lnRate + tnChilds * as_crate1 + tnChilds2 * as_crate2 + tnChilds3 * as_crate3
					llFound = .T.
				ENDIF
			ENDIF
		ENDIF
		
		IF NOT "*" $ tcRateCode AND NOT llFound
			SELECT &tcRcAlias
			lnRate = rc_base
			lnDOWcurrent = DOW(ldDate, 2)
			lnDOWarrival = DOW(tdArrdate, 2)
			IF SUBSTR(rc_weekend, lnDOWcurrent, 1) = '1' AND IIF(this.lDontCheckClosArr,.T.,SUBSTR(rc_closarr, lnDOWarrival, 1) = ' ')
				IF TYPE("rc_wbase")<>"U" AND NOT EMPTY(rc_wbase)
					lnRate = rc_wbase
				ENDIF
				lcAdFld = 'rc_wamnt'
				lcChFld = 'rc_wcamnt'
			ELSE
				lcAdFld = 'rc_amnt'
				lcChFld = 'rc_camnt'
			ENDIF
			IF NOT BETWEEN(tnAdults, 1, 5) OR EVALUATE(lcAdFld+TRANSFORM(tnAdults)) = 0
				lnRate = lnRate + EVALUATE(lcAdFld+'1')*IIF(&lcPaAlias..pa_chkadts, MAX(tnAdults,1), tnAdults)
			ELSE
				lnRate = lnRate + EVALUATE(lcAdFld+TRANSFORM(MAX(tnAdults,1)))
			ENDIF
			IF tnChilds > 0
				lnRate = lnRate + EVALUATE(lcChFld+'1') * tnChilds
			ENDIF
			IF tnChilds2 > 0
				lnRate = lnRate + EVALUATE(lcChFld+'2') * tnChilds2
			ENDIF
			IF tnChilds3 > 0
				lnRate = lnRate + EVALUATE(lcChFld+'3') * tnChilds3
			ENDIF
		
			IF TYPE("_screen.oGlobal.lAgency") = "L" AND _screen.oGlobal.lAgency
		
				* Here lookup room table over rc_ratecod = rm_roomnum, and get min and max persons. Only price should be in ratecode.
				* rm_beds - Room standad occupancy
				* rm_bedchfr - Kleinkinder frei bis (one value from param.pa_childs: 0,1,2,3)
		
				IF &tcRcAlias..rc_adperra <> 0
					l_nSelect = SELECT()
					l_cRoomCur = sqlcursor("SELECT rm_beds, rm_bedchfr FROM room WHERE rm_rmname = '" + &tcRcAlias..rc_ratecod + "'")
		
					lnPersons = tnAdults + IIF(rm_bedchfr <> 1, tnChilds, 0) + IIF(rm_bedchfr <> 2, tnChilds2, 0) + IIF(rm_bedchfr <> 3, tnChilds3, 0)
					IF rm_beds > 0 AND lnPersons > rm_beds
						lnAddonPersons = lnPersons - rm_beds
						lnAddonPrice = &tcRcAlias..rc_adperra
						lnRate = lnRate + (lnAddonPersons * lnAddonPrice)
					ENDIF
					dclose(l_cRoomCur)
					SELECT (l_nSelect)
				ENDIF
		
			ENDIF
		
		ENDIF
		
		lnPeriods = 1
		IF NOT EMPTY(tdDate)
			DO CASE
				CASE &tcRcAlias..rc_period = 1
					lnPeriods = Hours(tcArrtime, tcDeptime, tdArrdate, tdDepdate, tdDate)
				CASE &tcRcAlias..rc_period = 2
					lnPeriods = DayParts(tcArrtime, tcDeptime, tdArrdate, tdDepdate, tdDate, lcPaAlias)
			ENDCASE
		ENDIF
		lnRate = lnRate * lnPeriods
		tnRate = lnRate
		
		SELECT (lnArea)
		
		RETURN lnRate
	ENDPROC

	PROCEDURE ratecodelocate
		LPARAMETERS tnRecordId, tdDate, tcRoomType
		LOCAL lnArea, lcSeason, llFound
		
		IF NOT EMPTY(tnRecordId) AND SEEK(PADL(tnRecordId,10),"curRatecode","rc_locate")
			lnArea = SELECT()
			this.DLocate(this.cSeason, "se_date = " + SqlCnv(tdDate))
			lcSeason = EVALUATE(this.cSeason + ".se_season")
			SELECT curRatecode
			LOCATE FOR BETWEEN(tdDate, rc_fromdat, rc_todat-1) AND INLIST(rc_season, " ", lcSeason) AND ;
				(tcRoomType = "*   " OR rc_roomtyp = "*   " OR ","+rc_roomtyp+"," $ ","+tcRoomType+",") ;
				WHILE c_recordid = tnRecordId
			IF FOUND()
				llFound = .T.
			ELSE
				=SEEK(PADL(tnRecordId,10),"curRatecode","rc_locate")
			ENDIF
			SELECT (lnArea)
		ENDIF
		
		RETURN llFound
	ENDPROC

	PROCEDURE setenvironment
		SET DECIMALS TO 2
		SET HOURS TO 24
		SET DATE GERMAN
		SET MARK TO .
		SET CENTURY ON
		SET DELETED ON
		SET SAFETY OFF
		SET TALK OFF
		SET ANSI OFF
		SET MULTILOCKS ON
	ENDPROC

ENDDEFINE
