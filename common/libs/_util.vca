*--------------------------------------------------------------------------------------------------------------------------------------------------------
* (ES) AUTOGENERADO - ¡¡ATENCIÓN!! - ¡¡NO PENSADO PARA EJECUTAR!! USAR SOLAMENTE PARA INTEGRAR CAMBIOS Y ALMACENAR CON HERRAMIENTAS SCM!!
* (EN) AUTOGENERATED - ATTENTION!! - NOT INTENDED FOR EXECUTION!! USE ONLY FOR MERGING CHANGES AND STORING WITH SCM TOOLS!!
*--------------------------------------------------------------------------------------------------------------------------------------------------------
*< FOXBIN2PRG: Version="1.19" SourceFile="_util.vcx" /> (Solo para binarios VFP 9 / Only for VFP 9 binaries)
*
*
DEFINE CLASS tcollection AS _collection OF "_lbasec.vcx" 
 	*< CLASSDATA: Baseclass="collection" Timestamp="" Scale="Pixels" Uniqueid="" />

	Name = "tcollection"

ENDDEFINE

DEFINE CLASS tcustom AS _custom OF "_lbasec.vcx" 
 	*< CLASSDATA: Baseclass="custom" Timestamp="" Scale="Pixels" Uniqueid="" />

	#INCLUDE "_lconstants.h"
	*<DefinedPropArrayMethod>
		*m: apiclear
		*m: apideclarations
		*m: geterror
		*m: reseterror
		*p: cerrorfilename
		*p: cerrormessage
		*p: clastcompleteerror
		*p: lshowerrormessage
		*p: nerrorcode
	*</DefinedPropArrayMethod>

	cerrorfilename = cerror.txt
	cerrormessage = 
	clastcompleteerror = 
	Name = "tcustom"
	nerrorcode = 0
	
	PROCEDURE apiclear
		CLEAR DLLS GetDesktopWindow, GetSystemDirectory, ShellExecute, FindWindowA, SetWindowPos, GetFileAttributes, SetFileAttributes
	ENDPROC

	PROCEDURE apideclarations
		DECLARE INTEGER GetDesktopWindow IN user32.dll
		DECLARE INTEGER GetSystemDirectory IN kernel32.dll STRING @, INTEGER
		DECLARE INTEGER ShellExecute IN shell32.dll INTEGER, STRING @, STRING @, STRING @, STRING @, INTEGER
		* FindWindowA returns the window handle from the window's caption
		DECLARE LONG FindWindowA IN WIN32API STRING class, STRING title
		* SetWindowPos moves the window to the top, using the window handle
		* Example: SetWindowPos(hwnd, -1, 0, 0, 0, 0, 3)
		DECLARE SetWindowPos IN WIN32API LONG hwnd, LONG hwndafter, LONG x, LONG y, LONG cx, LONG cy, LONG flags
		DECLARE LONG GetFileAttributes IN WIN32API STRING FileName
		DECLARE SetFileAttributes IN WIN32API STRING FileName, LONG FileAttributes
	ENDPROC

	PROCEDURE Error
		LPARAMETERS tnError, tcMethod, tnLine
		LOCAL i, lcErrorMsg, lcErrorDescription, lcCallStack, lnStackCount, lcProgram
		LOCAL ARRAY laError(1)
		
		IF tnError = 5 && Record is out of range
			RETURN .T.
		ENDIF
		
		AERROR(laError)
		this.nErrorCode = tnError
		
		IF BETWEEN(tnError, 1427, 1429) OR tnError = 1526
			this.cErrorMessage = TRANSFORM(laError(3))
		ELSE
			this.cErrorMessage = MESSAGE()
		ENDIF
		
		lcErrorDescription = "Line: " + TRANSFORM(tnLine) + CRLF
		FOR i = 1 TO 7
			lcErrorDescription = lcErrorDescription + STR(i,1) + ":" + TRANSFORM(NVL(laError(i),"")) + CRLF
		NEXT 
		
		lnStackCount = 1
		lcCallStack = ""
		lcProgram = PROGRAM()
		DO WHILE PROGRAM(lnStackCount) <> lcProgram
			lcCallStack = lcCallStack + PROGRAM(lnStackCount) + " "
			lnStackCount = lnStackCount + 1
		ENDDO
		
		lcErrorMsg = TTOC(DATETIME()) + " ::" + _VFP.FullName + ":: " + this.Name + CRLF + ALLTRIM(_Screen.Caption) + " :: "
		lcErrorMsg = lcErrorMsg + IIF(TYPE("this.nClientCode")="N", "Client code: " + LTRIM(STR(this.nClientCode)),"") + CRLF
		lcErrorMsg = lcErrorMsg + lcErrorDescription + ALLTRIM(lcCallStack) + CRLF + CRLF
		
		this.cLastCompleteError = lcErrorMsg
		
		Logdata(lcErrorMsg, FORCEEXT(this.cErrorFileName, "err"))
		
		IF Application.StartMode = 0
			SET STEP ON
			IF .F.
				RETRY		&& Step here in debuger, to retry program execution
			ENDIF
		ENDIF
		
		IF this.lShowErrorMessage
			MESSAGEBOX(this.cLastCompleteError, 16, "Error")
		ENDIF
	ENDPROC

	PROCEDURE geterror
		LPARAMETERS tcErrorMessage
		
		tcErrorMessage = this.cErrorMessage
		
		RETURN this.nErrorCode
	ENDPROC

	PROCEDURE reseterror
		this.nErrorCode = NO_ERROR
		this.cErrorMessage = ""
	ENDPROC

ENDDEFINE
