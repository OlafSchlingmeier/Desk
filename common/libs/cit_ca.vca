*--------------------------------------------------------------------------------------------------------------------------------------------------------
* (ES) AUTOGENERADO - ¡¡ATENCIÓN!! - ¡¡NO PENSADO PARA EJECUTAR!! USAR SOLAMENTE PARA INTEGRAR CAMBIOS Y ALMACENAR CON HERRAMIENTAS SCM!!
* (EN) AUTOGENERATED - ATTENTION!! - NOT INTENDED FOR EXECUTION!! USE ONLY FOR MERGING CHANGES AND STORING WITH SCM TOOLS!!
*--------------------------------------------------------------------------------------------------------------------------------------------------------
*< FOXBIN2PRG: Version="1.19" SourceFile="cit_ca.vcx" /> (Solo para binarios VFP 9 / Only for VFP 9 binaries)
*
*
DEFINE CLASS cabase AS cursoradapter 
 	*< CLASSDATA: Baseclass="cursoradapter" Timestamp="" Scale="Pixels" Uniqueid="" />

	*<DefinedPropArrayMethod>
		*m: aftersave
		*m: alias_assign
		*m: beforesave
		*m: connectioncheck
		*m: createindexes
		*m: cursornullsadd
		*m: cursornullsremove
		*m: cursorquery
		*m: dclose
		*m: dotablerevert
		*m: dotableupdate
		*m: getjuststructure
		*m: initafter
		*m: makeforclause
		*m: openfile
		*m: release		&& Releases a FormSet or Form from memory.
		*m: setcommandprops
		*m: setprop
		*m: setsource
		*p: capp
		*p: cerrfile
		*p: cfilterclause
		*p: cglobal
		*p: cindexlist		&& Here enter indexes, which should be created, with character | as delimiter, after each tag. Example: TAG1|TAG4|TAG6
		*p: cinnerclause		&& set here INNER JOIN filter. Example: address ON rs_addrid =  ad_addrid AND NOT ad_vip
		*p: corder
		*p: corderby
		*p: cremotealias
		*p: cremotedatabase
		*p: cremotefilter
		*p: lbufferedsource
		*p: lcreateindexes		&& When .T., indexes are automaticly created, as defined for tanle in files.dbf
		*p: ldetach		&& When .T., after first cursorfill, deatach cursor from source. Can be used, to create cursor with exact structure as table, but without sending updates to database.
		*p: ldontfill
		*p: lexternalodbc
		*p: lreconnected
		*p: mainselectcmd
		*p: maintables
		*p: mainupdatenamelist
		*p: nrecno
		*p: nresults		&& RECCOUNT() from cursor after cursorfill
		*p: ntopclause		&& Used for TOP clause in SQL
		*a: aindexes[1,0]		&& Here is stored in array definition of indexes for table
	*</DefinedPropArrayMethod>

	BufferModeOverride = 5
	capp = 
	cerrfile = 
	cfilterclause = 
	cglobal = 
	cindexlist = 		&& Here enter indexes, which should be created, with character | as delimiter, after each tag. Example: TAG1|TAG4|TAG6
	cinnerclause = 		&& set here INNER JOIN filter. Example: address ON rs_addrid =  ad_addrid AND NOT ad_vip
	corder = 
	corderby = 
	cremotealias = 
	cremotedatabase = 
	cremotefilter = 
	DataSourceType = "Native"
	Height = 22
	mainselectcmd = 
	maintables = 
	mainupdatenamelist = 
	Name = "cabase"
	nrecno = 0
	nresults = 0		&& RECCOUNT() from cursor after cursorfill
	ntopclause = 0		&& Used for TOP clause in SQL
	UseCursorSchema = .T.
	WhereType = 1
	Width = 23
	
	PROCEDURE AfterCursorFill
		LPARAMETERS luseCursorSchema, lNoDataOnLoad, cSelectCmd, lResult
		LOCAL lcErrorText, lnStackCount, lcCallStack, lcProgram, lcSource, lcArrayName, lnRecno
		
		IF NOT EMPTY(this.Alias) AND USED(this.Alias)
			this.CursorDetach()
			DO CASE
				CASE NOT this.lDetach
				CASE RECCOUNT(this.Alias) > 100
					CURSORSETPROP("Buffering",3,this.Alias) && We don't need buffering 5 for detached cursor
				OTHERWISE
					SELECT * FROM (this.Alias) INTO CURSOR (this.Alias) READWRITE
			ENDCASE
			this.CreateIndexes()
			this.CursorNullsRemove(.T.)
			IF CURSORGETPROP("Buffering",this.Alias) > 1
				lnRecno = RECNO(this.Alias)
				TABLEUPDATE(.T.,.T.,this.Alias)
				GO lnRecno IN (this.Alias)
			ENDIF
			IF NOT this.lDetach
				this.CursorAttach()
			ELSE
				this.lDetach = .F.
			ENDIF
			this.nResults = RECCOUNT(this.Alias)
		ELSE
			this.nResults = 0
			lnStackCount = 1
			lcCallStack = ""
			lcProgram = PROGRAM()
			DO WHILE PROGRAM(lnStackCount) <> lcProgram
				lcCallStack = lcCallStack + PROGRAM(lnStackCount) + " "
				lnStackCount = lnStackCount + 1
			ENDDO
			lcErrorText = getaerrortext() + CHR(13) + lcProgram + CHR(13) + lcCallStack
			lcGlobal = this.cGlobal
			IF UPPER(this.DataSourceType) = "ODBC" AND NOT this.lReconnected AND &lcGlobal..oGData.Reconnected(this.lExternalODBC)
				this.lReconnected = .T.
				RETURN
			ENDIF
			ASSERT .F. MESSAGE lcErrorText
			MESSAGEBOX(lcErrorText,48,"CA Error")
			LogData(TRANSFORM(DATETIME())+" " + lcErrorText, this.cErrFile)
		ENDIF
		this.lReconnected = .F.
	ENDPROC

	PROCEDURE AfterCursorRefresh
		LPARAMETERS cSelectCmd, lResult
		
		this.CursorNullsRemove(.T.)
		
		IF NOT EMPTY(this.Alias) AND NOT EMPTY(this.nRecNo)
			TRY
				GO this.nRecNo IN (this.Alias)
			CATCH
			ENDTRY
		ENDIF
	ENDPROC

	PROCEDURE AfterCursorUpdate
		LPARAMETERS nRows, lTableUpdateResult, cErrorArray
		this.UseTransactions = .T.
	ENDPROC

	PROCEDURE AfterInsert
		LPARAMETERS cFldState, lForce, cInsertCmd, lResult
		this.AfterSave()
	ENDPROC

	PROCEDURE AfterRecordRefresh
		LPARAMETERS nRecords, nRecordOffset, nRefreshed
		
		this.CursorNullsRemove(.F.)
	ENDPROC

	PROCEDURE aftersave
		this.CursorNullsRemove()
	ENDPROC

	PROCEDURE AfterUpdate
		LPARAMETERS cFldState, lForce, nUpdateType, cUpdateInsertCmd, cDeleteCmd, lResult
		this.AfterSave()
	ENDPROC

	PROCEDURE alias_assign
		LPARAMETERS tcNewVal
		
		IF LOWER(tcNewVal) == this.MainTables AND UPPER(this.DataSourceType) = "NATIVE"
			this.SetSource(this.MainTables + " Sr" + this.MainTables)
		ENDIF
		
		this.Alias = tcNewVal
	ENDPROC

	PROCEDURE BeforeCursorFill
		LPARAMETERS luseCursorSchema, lNoDataOnLoad, cSelectCmd
		LOCAL i, lcWhere, lcTable, lcAlias, lcOrder
		
		IF UPPER(this.DataSourceType) = "NATIVE"
			FOR i = 1 TO GETWORDCOUNT(this.MainTables, ",")
				lcTable = ALLTRIM(GETWORDNUM(this.MainTables, i, ","))
				IF GETWORDCOUNT(lcTable) > 1
					lcAlias = GETWORDNUM(lcTable, 2)
					lcTable = GETWORDNUM(lcTable, 1)
				ELSE
					lcAlias = lcTable
				ENDIF
				this.OpenFile(lcTable, lcAlias)
			NEXT
			cSelectCmd = this.SelectCmd
		ENDIF
		
		* If cursor already has order set, but this order is not stored in cOrder property, store it in cOrder property
		IF NOT EMPTY(this.Alias) AND USED(this.Alias) AND EMPTY(this.cOrder)
			lcOrder = ORDER(this.Alias)
			IF NOT EMPTY(lcOrder)
				this.cOrder = lcOrder
			ENDIF
		ENDIF
		
		lcWhere = ""
		* cSelectCmd Variable is returned by reference, so we can adjust it here before select is performed
		
		* read from buffer
		IF UPPER(this.DataSourceType) = "NATIVE" AND this.lBufferedSource
			cSelectCmd = cSelectCmd + [ WITH (BUFFERING = .T.)]
		ENDIF
		
		* set inner join
		IF NOT EMPTY(this.cInnerClause)
			cSelectCmd = STRTRAN(cSelectCmd, "SELECT ", "SELECT DISTINCT ")
			cSelectCmd = cSelectCmd + [ INNER JOIN ] + this.cInnerClause
		ENDIF
		
		IF NOT EMPTY(this.ntopclause)
			cSelectCmd = STRTRAN(cSelectCmd, ;
				IIF(EMPTY(this.cInnerClause),"SELECT ", "SELECT DISTINCT "), ;
				IIF(EMPTY(this.cInnerClause),"SELECT ", "SELECT DISTINCT ") + "TOP " + TRANSFORM(this.ntopclause) + " ")
		ENDIF
		
		* set the where clause/s
		IF this.lDontFill OR lNoDataOnLoad
			lcWhere = sqland(lcWhere, [ 0=1 ])
		ENDIF
		
		IF NOT EMPTY(this.cFilterClause)
			lcWhere = sqland(lcWhere, this.cFilterClause)
		ENDIF
		
		IF NOT EMPTY(lcWhere)
			cSelectCmd = cSelectCmd + [ WHERE ] + lcWhere
		ENDIF
		
		
		* set the orderby clause
		IF NOT EMPTY(this.cOrderBy)
			cSelectCmd = cSelectCmd + [ ORDER BY ] + this.cOrderBy
		ENDIF
		
		IF UPPER(this.DataSourceType) = "NATIVE"
			cSelectCmd = cSelectCmd + [ NOFILTER]
		ENDIF
		
		cSelectCmd = SqlParse(cSelectCmd, UPPER(this.DataSourceType) = "ODBC",,this.lExternalODBC)
		
		*!*	IF this.lDontFill
		*!*		cSelectCmd = cSelectCmd + [ LIMIT 0]
		*!*	ENDIF
		
		IF UPPER(this.DataSourceType) = "ODBC" AND this.FetchAsNeeded
			IF NOT SQLGETPROP(this.DataSource,"Asynchronous")
				SQLSETPROP(this.DataSource,"Asynchronous",.T.)
			ENDIF
		ENDIF
		
		RETURN .T.
	ENDPROC

	PROCEDURE BeforeCursorRefresh
		LPARAMETERS cSelectCmd
		
		IF NOT EMPTY(this.Alias)
			this.nRecNo = RECNO(this.Alias)
		ENDIF
	ENDPROC

	PROCEDURE BeforeCursorUpdate
		LPARAMETERS nRows, lForce
		IF TYPE("plInTransaction") = "L" AND plInTransaction
			this.UseTransactions = .F.
		ENDIF
	ENDPROC

	PROCEDURE BeforeDelete
		LPARAMETERS cFldState, lForce, cDeleteCmd
		LOCAL i, loDatabaseProp, lcSrcTable, lcMainTables, lcTable, lcGlobal, lcSql, llSuccess
		
		lcGlobal = this.cGlobal
		IF NOT EMPTY(this.cRemoteDatabase)
			loDatabaseProp = goDatabases.Item(this.cRemoteDatabase)
		ENDIF
		FOR i = 1 TO GETWORDCOUNT(this.Tables, ",")
			lcSql = cDeleteCmd
			lcSrcTable = ALLTRIM(GETWORDNUM(this.MainTables, i, ","))
			lcTable = ALLTRIM(GETWORDNUM(this.Tables, i, ","))
			IF GETWORDCOUNT(lcTable) > 1
				lcMainTables = GETWORDNUM(lcTable, 1)
				lcTable = GETWORDNUM(lcTable, 2)
			ELSE
				lcMainTables = lcTable
			ENDIF
			lcTable = &lcGlobal..oGData.CheckTableName(lcTable)
			cDeleteCmd = STRTRAN(cDeleteCmd, "DELETE FROM " + lcMainTables, "DELETE FROM " + lcTable)
			IF NOT EMPTY(this.cRemoteDatabase)
				lcSrcTable = &lcGlobal..oGData.CheckTableName(lcSrcTable)
				lcSql = STRTRAN(lcSql, "DELETE FROM " + lcMainTables, "DELETE FROM " + lcSrcTable, -1, -1, 1)
				lcSql = STRTRAN(lcSql, "OLDVAL(", "__SQLPARAM__OLDVAL(", -1, -1, 1)
				SqlRemote("SQLDELETE", lcSql,,loDatabaseProp,,@llSuccess)
			ENDIF
		NEXT
		
		RETURN .T.
	ENDPROC

	PROCEDURE BeforeInsert
		LPARAMETERS cFldState, lForce, cInsertCmd
		LOCAL i, loDatabaseProp, lcSrcTable, lcMainTables, lcTable, lcGlobal, lcSql, llSuccess
		
		lcGlobal = this.cGlobal
		IF NOT EMPTY(this.cRemoteDatabase)
			loDatabaseProp = goDatabases.Item(this.cRemoteDatabase)
		ENDIF
		FOR i = 1 TO GETWORDCOUNT(this.Tables, ",")
			lcSql = cInsertCmd
			lcSrcTable = ALLTRIM(GETWORDNUM(this.MainTables, i, ","))
			lcTable = ALLTRIM(GETWORDNUM(this.Tables, i, ","))
			IF GETWORDCOUNT(lcTable) > 1
				lcMainTables = GETWORDNUM(lcTable, 1)
				lcTable = GETWORDNUM(lcTable, 2)
			ELSE
				lcMainTables = lcTable
			ENDIF
			lcTable = &lcGlobal..oGData.CheckTableName(lcTable)
			cInsertCmd = STRTRAN(cInsertCmd, "INSERT INTO " + lcMainTables, "INSERT INTO " + lcTable)
			IF NOT EMPTY(this.cRemoteDatabase)
				lcSrcTable = &lcGlobal..oGData.CheckTableName(lcSrcTable)
				lcSql = STRTRAN(lcSql, "INSERT INTO " + lcMainTables, "INSERT INTO " + lcSrcTable, -1, -1, 1)
				lcSql = STRTRAN(lcSql, "("+this.Alias+".", "(__SQLPARAM__"+this.Alias+".", -1, -1, 1)
				lcSql = STRTRAN(lcSql, ","+this.Alias+".", ",__SQLPARAM__"+this.Alias+".", -1, -1, 1)
				SqlRemote("SQLINSERT", lcSql,,loDatabaseProp,,@llSuccess)
			ENDIF
		NEXT
		this.BeforeSave()
		
		RETURN .T.
	ENDPROC

	PROCEDURE beforesave
		this.CursorNullsAdd()
	ENDPROC

	PROCEDURE BeforeUpdate
		LPARAMETERS cFldState, lForce, nUpdateType, cUpdateInsertCmd, cDeleteCmd
		LOCAL i, loDatabaseProp, lcMainTables, lcSrcTable, lcTable, lcGlobal, lcSql, llSuccess
		
		lcGlobal = this.cGlobal
		IF NOT EMPTY(this.cRemoteDatabase)
			loDatabaseProp = goDatabases.Item(this.cRemoteDatabase)
		ENDIF
		FOR i = 1 TO GETWORDCOUNT(this.Tables, ",")
			lcSql = cUpdateInsertCmd
			lcSrcTable = ALLTRIM(GETWORDNUM(this.MainTables, i, ","))
			lcTable = ALLTRIM(GETWORDNUM(this.Tables, i, ","))
			IF GETWORDCOUNT(lcTable) > 1
				lcMainTables = GETWORDNUM(lcTable, 1)
				lcTable = GETWORDNUM(lcTable, 2)
			ELSE
				lcMainTables = lcTable
			ENDIF
			lcTable = &lcGlobal..oGData.CheckTableName(lcTable)
			cUpdateInsertCmd = STRTRAN(cUpdateInsertCmd, "UPDATE " + lcMainTables, "UPDATE " + lcTable)
			IF NOT EMPTY(this.cRemoteDatabase)
				lcSrcTable = &lcGlobal..oGData.CheckTableName(lcSrcTable)
				lcSql = STRTRAN(lcSql, "UPDATE " + lcMainTables, "UPDATE " + lcSrcTable, -1, -1, 1)
				lcSql = STRTRAN(lcSql, "OLDVAL(", "__SQLPARAM__OLDVAL(", -1, -1, 1)
				lcSql = STRTRAN(lcSql, "="+this.Alias+".", "=__SQLPARAM__"+this.Alias+".", -1, -1, 1)
				SqlRemote("SQLUPDATE", lcSql,,loDatabaseProp,,@llSuccess)
			ENDIF
		NEXT
		this.BeforeSave()
		
		RETURN .T.
	ENDPROC

	PROCEDURE connectioncheck
		LOCAL lcGlobal
		
		IF UPPER(this.DataSourceType) = "ODBC"
			lcGlobal = this.cGlobal
			this.DataSource = &lcGlobal..oGData.GetHandle(this.lExternalODBC)
		ENDIF
	ENDPROC

	PROCEDURE createindexes
		* Create indexes for cursor, as defined for dbf in files.dbf.
		* Must set this.lCreateIndexes = .T.
		* In this.cIndexList can be set as | delimited list, indexes which should be created. Otherwise, all indexes are created.
		
		LOCAL lnSelect, llHaveIndexesStructure
		LOCAL ARRAY laTag(1)
		LOCAL ARRAY laIndexes(1)
		
		IF NOT this.lCreateIndexes
			RETURN .T.
		ENDIF
		
		lnSelect = SELECT()
		
		SELECT (this.Alias)
		IF 0 = ATAGINFO(laTag)
			lcTable = ALLTRIM(GETWORDNUM(this.Tables, 1, ","))
			IF GETWORDCOUNT(lcTable) > 1
				lcTable = GETWORDNUM(lcTable, 2)
			ENDIF
			llHaveIndexesStructure = NOT VARTYPE(this.aIndexes(1))="L"
			IF llHaveIndexesStructure
				* We have already stored indexes structure in this.aIndexes property, so use it.
				DIMENSION laIndexes(ALEN(this.aIndexes,1),MAX(ALEN(this.aIndexes,2),1))
				ACOPY(this.aIndexes, laIndexes)
			ENDIF
			SetIndexes(lcTable, this.Alias, this.cOrder, this.cIndexList, @laIndexes, this.lExternalODBC, this.cRemoteDatabase)
			IF NOT llHaveIndexesStructure
				* Store indexes structure for later calls
				DIMENSION this.aIndexes(ALEN(laIndexes,1),MAX(ALEN(laIndexes,2),1))
				ACOPY(laIndexes, this.aIndexes)
			ENDIF
		ENDIF
		
		SELECT (lnSelect)
		
		RETURN .T.
	ENDPROC

	PROCEDURE cursornullsadd
		LPARAMETERS tlAllRecords
		
		CFCursorNullsAdd(tlAllRecords, this.Alias, this.lExternalODBC)
		
		RETURN .T.
	ENDPROC

	PROCEDURE cursornullsremove
		LPARAMETERS tlAllRecords
		
		CFCursorNullsRemove(tlAllRecords, this.Alias, this.lExternalODBC)
		
		RETURN .T.
	ENDPROC

	PROCEDURE cursorquery
		LPARAMETERS tlCursorFill, tcFilterClause, tcInnerClause, tcOrderBy, tnTopClause, tcOrder
		
		IF VARTYPE(tcFilterClause) = "C"
			this.cFilterClause = tcFilterClause
		ENDIF
		IF VARTYPE(tcInnerClause) = "C"
			this.cInnerClause = tcInnerClause
		ENDIF
		IF VARTYPE(tcOrderBy) = "C"
			this.cOrderBy = tcOrderBy
		ENDIF
		IF VARTYPE(tnTopClause) = "N"
			this.nTopClause = tnTopClause
		ENDIF
		IF VARTYPE(tcOrder) = "C"
			this.cOrder = tcOrder
		ENDIF
		IF tlCursorFill
			pcodbctable = this.MainTables
			this.CursorFill()
			IF this.lReconnected
				this.CursorFill()
			ENDIF
		ENDIF
	ENDPROC

	PROCEDURE dclose
		* Close cursor, and release cursoradapter object!
		DClose(this.Alias)
		this.Release()
	ENDPROC

	PROCEDURE dotablerevert
		LPARAMETERS tlAllRecords
		LOCAL i, llSuccess, lcTable
		
		llSuccess = .T.
		
		DoTableRevert(tlAllRecords, this.Alias)
		IF UPPER(this.DataSourceType) = "NATIVE"
			FOR i = 1 TO GETWORDCOUNT(this.Tables, ",")
				lcTable = ALLTRIM(GETWORDNUM(this.Tables, i, ","))
				IF GETWORDCOUNT(lcTable) > 1
					lcTable = GETWORDNUM(lcTable, 2)
				ENDIF
				IF USED(lcTable)
					DoTableRevert(tlAllRecords, lcTable)
				ENDIF
			NEXT
		ENDIF
		
		RETURN llSuccess
	ENDPROC

	PROCEDURE dotableupdate
		LPARAMETERS tnRows, tlNoEndTransaction, tlNoTransaction
		LOCAL i, llSuccess, lcTable
		
		llSuccess = DoTableUpdate(tnRows, .T., this.Alias, tlNoTransaction,,this.lExternalODBC)
		IF UPPER(this.DataSourceType) = "NATIVE"
			FOR i = 1 TO GETWORDCOUNT(this.Tables, ",")
				lcTable = ALLTRIM(GETWORDNUM(this.Tables, i, ","))
				IF GETWORDCOUNT(lcTable) > 1
					lcTable = GETWORDNUM(lcTable, 2)
				ENDIF
				DoTableUpdate(tnRows, .T., lcTable, tlNoTransaction,,this.lExternalODBC)
			NEXT
		ENDIF
		IF NOT tlNoTransaction
			llSuccess = TransactionIsOK()
			IF NOT tlNoEndTransaction
				EndTransaction()
			ENDIF
		ENDIF
		
		RETURN llSuccess
	ENDPROC

	PROCEDURE getjuststructure
		LPARAMETERS tcTable
		LOCAL llJustStructure
		
		DO CASE
			CASE this.cRemoteDatabase = "DESK" AND (","+LOWER(tcTable)+",") $ (",address,billnum,post,pswindow,reservat,workint,workbrk,astat,orstat,"+;
					"histors,histpost,hpwindow,hpostcng,histres,histstat,hresext,hresplit,hresrart,hresrate,hresroom,")
				llJustStructure = .T.
			OTHERWISE
		ENDCASE
		
		RETURN llJustStructure
	ENDPROC

	PROCEDURE Init
		LPARAMETERS tlExternalODBC, tcRemoteDatabase
		
		this.lExternalODBC = tlExternalODBC
		this.cRemoteDatabase = tcRemoteDatabase
		
		IF TYPE("gcApplication") = "C" AND UPPER(gcApplication) = "CITADEL DESK"
			this.cApp = "DESK"
		ELSE && Argus
			this.cApp = "ARGUS"
		ENDIF
		
		DO CASE
			CASE this.cApp = "DESK"
				this.cGlobal = "_screen.oGlobal"
				this.cErrFile = "Hotel.err"
			CASE this.cApp = "ARGUS"
				this.cGlobal = "goGlobal"
				this.cErrFile = EVALUATE("goGlobal.cappname") + ".err"
			OTHERWISE
		ENDCASE
		
		this.SetCommandProps()
		
		IF SET("Multilocks") <> "ON"
			SET MULTILOCKS ON
		ENDIF
		IF Odbc() OR this.lExternalODBC
			this.DataSourceType = "ODBC"
			this.ConnectionCheck()
		ENDIF
		this.InitAfter()
		this.MainTables = LOWER(this.Tables)
		this.MainSelectCmd = this.SelectCmd
		this.MainUpdateNameList = this.UpdateNameList
	ENDPROC

	PROCEDURE initafter
	ENDPROC

	PROCEDURE makeforclause
		LOCAL i, lcExpression, lnFields, lcField, lnRow
		LOCAL ARRAY laFields(1)
		
		lnFields = GETWORDCOUNT(this.KeyFieldList,",")
		IF lnFields = 1
			lcExpression = this.KeyFieldList
		ELSE
			AFIELDS(laFields, this.Alias)
			lcExpression = ""
			FOR i = 1 TO lnFields
				lcField = GETWORDNUM(this.KeyFieldList,i,",")
				lnRow = ASCAN(laFields, UPPER(lcField), 1, 0, 1, 14)
				DO CASE
					CASE lnRow < 1
					CASE laFields(lnRow,2) = "C"
						lcExpression = lcExpression + IIF(EMPTY(lcExpression), "", "+") + lcField
					CASE laFields(lnRow,2) = "D"
						lcExpression = lcExpression + IIF(EMPTY(lcExpression), "", "+") + "DTOS("+lcField+")"
					CASE laFields(lnRow,2) = "T"
						lcExpression = lcExpression + IIF(EMPTY(lcExpression), "", "+") + "TTOC("+lcField+",1)"
					CASE laFields(lnRow,2) = "I"
						lcExpression = lcExpression + IIF(EMPTY(lcExpression), "", "+") + "PADL("+lcField+",11)"
					CASE laFields(lnRow,2) = "N"
						lcExpression = lcExpression + IIF(EMPTY(lcExpression), "", "+") + "PADL("+lcField+","+TRANSFORM(laFields(lnRow,3)+laFields(lnRow,4)+1)+")"
					OTHERWISE
				ENDCASE
			NEXT
		ENDIF
		
		RETURN lcExpression
	ENDPROC

	PROCEDURE openfile
		LPARAMETERS tcTable, tcAlias
		LOCAL llSuccess, lcTable, loDatabaseProp, llJustStructure
		
		DO CASE
			CASE NOT EMPTY(this.cRemoteDatabase)
				llJustStructure = this.GetJustStructure(tcTable)
				loDatabaseProp = goDatabases.Item(this.cRemoteDatabase)
				IF EMPTY(this.cRemoteAlias) OR NOT USED(this.cRemoteAlias)
					this.cRemoteAlias = SqlRemote(IIF(llJustStructure, "SQLTABLESTRUCT", "SQLTABLE"), tcTable, this.cRemoteAlias, loDatabaseProp,,@llSuccess)
					IF llSuccess
						lcTable = JUSTSTEM(DBF(this.cRemoteAlias))
						this.SetSource(lcTable + IIF(lcTable = this.cRemoteAlias, "", " "+this.cRemoteAlias))
					ENDIF
				ELSE
					llSuccess = .T.
				ENDIF
				IF llSuccess AND llJustStructure AND NOT EMPTY(this.cRemoteFilter)
					IF NOT " INNER JOIN " $ " "+this.cRemoteFilter
						this.cRemoteFilter = "WHERE "+this.cRemoteFilter
					ENDIF
					lcCurName = SqlRemote("SQLCURSOR", "SELECT "+tcTable+".* FROM "+tcTable+" "+this.cRemoteFilter,, loDatabaseProp,,@llSuccess)
					IF USED(lcCurName)
						SELECT (JUSTSTEM(DBF(this.cRemoteAlias)))
						ZAP
						APPEND FROM DBF(lcCurName)
						USE IN &lcCurName
					ENDIF
				ENDIF
			CASE USED(tcAlias)
				llSuccess = .T.
			CASE this.cApp = "DESK"
				llSuccess = EVALUATE("OpenFileDirect(,tcTable, tcAlias)")
			CASE this.cApp = "ARGUS"
				llSuccess = EVALUATE("TbOpen(tcTable, tcAlias)")
			OTHERWISE
		ENDCASE
		
		RETURN llSuccess
	ENDPROC

	PROCEDURE release		&& Releases a FormSet or Form from memory.
		LOCAL lcPath
		
		IF NOT EMPTY(this.cRemoteAlias) AND USED(this.cRemoteAlias)
			lcPath = DBF(this.cRemoteAlias)
			DClose(this.cRemoteAlias)
			DELETE FILE (FORCEEXT(lcPath,"*"))
		ENDIF
		
		RELEASE this
	ENDPROC

	PROCEDURE setcommandprops
		* Set following properties from cadef<app>.prg
		*	this.SelectCmd = ""
		*	this.CursorSchema = ""
		*	this.UpdatableFieldList = ""
		*	this.UpdateNameList = ""
		*	this.InsertCmdRefreshKeyFieldList = ""
		*	this.InsertCmdRefreshFieldList = ""
		*	this.InsertCmdRefreshCmd = ""
	ENDPROC

	PROCEDURE setprop
		LPARAMETERS tlFillAlias, tlFillEmptyWhere
		
		IF tlFillAlias
			this.Alias = SYS(2015)
		ENDIF
		
		IF tlFillEmptyWhere
			this.cFilterClause = "0=1"
		ENDIF
	ENDPROC

	PROCEDURE setsource
		LPARAMETERS tcTables
		LOCAL i, lcMainTable, lcTable, lcGlobal
		
		lcGlobal = this.cGlobal
		this.Tables = LOWER(tcTables)
		this.SelectCmd = this.MainSelectCmd
		this.UpdateNameList = this.MainUpdateNameList
		FOR i = 1 TO GETWORDCOUNT(this.MainTables, ",")
			lcMainTable = &lcGlobal..oGData.CheckTableName(ALLTRIM(GETWORDNUM(this.MainTables, i, ",")))
			lcTable = ALLTRIM(GETWORDNUM(this.Tables, i, ","))
			IF GETWORDCOUNT(lcTable) > 1
				lcTable = &lcGlobal..oGData.CheckTableName(GETWORDNUM(lcTable, 2))
			ENDIF
			this.SelectCmd = ALLTRIM(STRTRAN(" "+this.SelectCmd+" ", " "+lcMainTable+" ", " "+lcTable+" "))
			this.UpdateNameList = ALLTRIM(STRTRAN(this.UpdateNameList, " "+lcMainTable+".", " "+lcTable+"."))
		NEXT
	ENDPROC

ENDDEFINE
